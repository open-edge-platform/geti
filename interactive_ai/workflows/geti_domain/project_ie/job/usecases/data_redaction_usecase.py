# Copyright (C) 2022-2025 Intel Corporation
# LIMITED EDGE SOFTWARE DISTRIBUTION LICENSE
"""
This module is responsible for data redaction during the import and export processes.
"""

import logging
import os
import random
import re
import shutil
from abc import ABC
from datetime import datetime, timedelta, timezone
from typing import cast
from uuid import UUID
from zipfile import ZipFile

from bson import ObjectId, UuidRepresentation
from bson.json_util import JSONOptions, dumps
from defusedxml import ElementTree
from iai_core.repos.mappers import DatetimeToMongo, MediaIdentifierToMongo
from iai_core.utils.time_utils import now

from job.entities.exceptions import ExportDataRedactionFailedException, ImportDataRedactionFailedException

logger = logging.getLogger(__name__)


def get_random_objectid_between_dates(min_date: datetime, max_date: datetime) -> ObjectId:
    """
    Generate a random ObjectId with a timestamp component in range [min_date, max_date]

    :param min_date: Lower bound date
    :param max_date: Upper bound date
    :return: ObjectId
    """
    epoch_lower_bound = int(min_date.timestamp())
    epoch_upper_bound = int(max_date.timestamp())
    random_epoch = random.randint(epoch_lower_bound, epoch_upper_bound)  # noqa: S311 # nosec
    random_milliseconds = random.randint(0, 999)  # noqa: S311 # nosec
    random_datetime = datetime.fromtimestamp(random_epoch) + timedelta(milliseconds=random_milliseconds)
    random_hex = os.urandom(8).hex()  # random 8 bytes to use as lowest bytes in the ObjectId
    return ObjectId(ObjectId.from_datetime(random_datetime).binary[:4].hex() + random_hex)


class BaseDataRedactionUseCase(ABC):
    """Base class for the common logic between import and export data redaction use cases."""

    # for all the keys listed below we also consider their variants with '_id', '_uid' or '_name' suffix
    USER_RELATED_KEYS = ("author", "creator", "editor", "uploader", "user")

    @staticmethod
    def _is_file_label_schema_json(file_basename: str) -> bool:
        """Determine if a file is a label schema representation in JSON format"""
        if not file_basename.endswith(".json"):
            return False
        return any(pattern in file_basename for pattern in ("label-schema", "label_schema"))

    @staticmethod
    def _is_file_model_xml(file_basename: str) -> bool:
        """Determine if a file is a model representation in XML format"""
        if not file_basename.endswith(".xml"):
            return False
        return any(pattern in file_basename for pattern in ("model", "openvino"))

    @staticmethod
    def _is_file_exportable_code(file_basename: str) -> bool:
        """Determine if a file is an exportable code archive"""
        if not file_basename.endswith(".whl"):
            return False
        return any(pattern in file_basename for pattern in ("exportable-code", "exportable_code"))

    @staticmethod
    def _is_file_reference_features_json(file_basename: str) -> bool:
        """Determine if a file is a reference features representation in JSON format"""
        if not file_basename.endswith(".json"):
            return False
        return "reference_features" in file_basename


class ExportDataRedactionUseCase(BaseDataRedactionUseCase):
    """
    This class is responsible for data modification during the export process.

    On export:
    - Replace the ObjectIDs in the documents
    - Remove the project, workspace and organization ID from the documents
    - Remove user IDs and personal data from documents
    """

    def __init__(self) -> None:
        self.objectid_replacement_base_oid: ObjectId = self._generate_random_base_oid()
        self.objectid_replacement_base_int = int(str(self.objectid_replacement_base_oid), 16)
        self.objectid_replacement_min_int: int | None = None  # this attribute is updated during the redaction

    @staticmethod
    def _generate_random_base_oid() -> ObjectId:
        # Generate a random datetime in range [1970, 2010], earlier than any random ObjectIds generated by Geti.
        return get_random_objectid_between_dates(
            min_date=datetime(1970, 1, 1, tzinfo=timezone.utc),
            max_date=datetime(2010, 1, 1, tzinfo=timezone.utc),
        )

    def __shift_back_objectid_hex(self, objectid_hex: str) -> str:
        """
        Transform an ObjectId encoded as hex string according to the replacement algorithm for project export.

        Algorithm:
            1.	Generate a random ObjectId "base" (B) such that it is lower than any existing ObjectId of the project.
                Since highest bytes of an ObjectId represent a timestamp, the base can be chosen randomly
                in the range of years [1970, 2010].
            2.	Replace all ObjectIds X with Y = (X - B). This is a simple translation (subtraction)
            3.	During or after the replacement, identify the minimum value among the transformed ids (M).
                Such value M must be exported along with the project because necessary on import.

        :param: Hex string representing the ObjectId to transform
        :return: Hex string representing the transformed (back-shifted) ObjectId
        """
        objectid_int = int(objectid_hex, 16)
        if objectid_int < self.objectid_replacement_base_int:
            logger.error(
                "While replacing IDs, found a document containing an ObjectId (%s) lower than the base (%s)",
                str(objectid_hex),
                str(self.objectid_replacement_base_oid),
            )
            raise ExportDataRedactionFailedException

        # Compute the new id value
        objectid_int_shifted = objectid_int - self.objectid_replacement_base_int
        objectid_hex_shifted = f"{objectid_int_shifted:024x}"

        # Cache the minimum transformed value
        if self.objectid_replacement_min_int is None or objectid_int_shifted < self.objectid_replacement_min_int:
            self.objectid_replacement_min_int = objectid_int_shifted

        return objectid_hex_shifted

    @property
    def objectid_replacement_min_id(self) -> str:
        """Value of the minimum transformed id (ObjectId) as a hex string"""
        if self.objectid_replacement_min_int is None:
            raise ValueError("The minimum id has not been initialized yet")
        return f"{self.objectid_replacement_min_int:024x}"

    def replace_objectid_in_mongodb_doc(self, bson_doc: str) -> str:
        """
        Replace the ObjectIDs in a document with substitute ids, which preserve the ordering of the original ids
        but do not allow one to reconstruct their value without further information. This is needed for project export.

        :param bson_doc: MongoDB document encoded as BSON
        :return: Document after the replacement
        """

        def objectid_replacer(match: re.Match) -> str:
            # Parse the ObjectId ($oid)
            objectid_hex_original = match.group(1)
            objectid_hex_shifted = self.__shift_back_objectid_hex(objectid_hex_original)
            # Return transformed id string. The marker '$oid' with '$sid' (substitute) to make the conversion explicit.
            return f'"$sid": "{objectid_hex_shifted}"'

        return re.sub(r"\"\$oid\": \"([0-9a-fA-F]{24})\"", objectid_replacer, bson_doc)

    def replace_media_based_objectid_in_mongodb_doc(self, doc: dict) -> dict:
        """
        Replace (in-place) the _id field of a document where such an ObjectId was generated from the media identifier,
        rather than normally initialized with bson.ObjectId().

        Other regular ids present in the document are NOT edited by this method.

        :param doc: MongoDB document dictionary
        :return: Document after the replacement
        """
        if "media_identifier" not in doc:
            logger.error(
                "Document does not have required key 'media_identifier'. Available keys: %s",
                list(doc.keys()),
            )
            raise ExportDataRedactionFailedException
        doc["_id"] = ObjectId()
        return doc

    def remove_job_id_in_mongodb_doc(self, doc: dict) -> dict:
        """
        Remove (in-place) the 'job_id' key from the document, if present.

        :param doc: MongoDB document dictionary
        :return: Document after the replacement
        """
        doc.pop("job_id", None)
        return doc

    def replace_objectid_in_url(self, url: str) -> str:
        """
        Replace the ObjectIDs in a URL with substitute ids, which preserve the ordering of the original ids
        but do not allow one to reconstruct their value without further information. This is needed for project export.

        Example of URLs:
          - /dataset_storages/659bb165c7d3a5f9a02be30a/659bb180c7d3a5f9a02be30b_thumbnail.jpg
          - /model_storages/659bb165c7d3a5f9a02be30a/model.xml

        Check the method 'replace_objectid_in_mongodb_doc' for details about the replacing algorithm.

        :param url: String-like URL that may contain ids to replace
        :return: URL after substituting the ids
        """

        def objectid_replacer(match: re.Match) -> str:
            # Parse the old id
            old_id, trailing_char = match.group(1), match.group(2)
            old_id_as_int = int(old_id, 16)

            # Compute the new substitute id
            shifted_value_int = old_id_as_int - self.objectid_replacement_base_int
            shifted_value_hex = f"{shifted_value_int:024x}"

            return f"{shifted_value_hex}{trailing_char}"

        # use lookbehind to not eat the leading slash; the suffix may be a slash, extension, thumbnail or nothing
        return re.sub(
            r"(?<=/)([0-9a-fA-F]{24})(/|$|(?:_thumbnail)?\.[0-9a-zA-Z]{2,4}$)",
            objectid_replacer,
            url,
        )

    def replace_objectid_based_binary_filename_in_mongodb_doc(self, bson_doc: str) -> str:
        """
        Replace the 'binary_filename' of documents where this field is generated from the entity '_id'.
        This is especially relevant for images and videos, as they have filenames like '<some_object_id>.mp4'

        :param bson_doc: MongoDB document encoded as BSON
        :return: Document after the replacement
        """

        def objectid_replacer(match: re.Match) -> str:
            # Parse the filename (ObjectId) and the extension
            objectid_hex_original = match.group(1)
            extension = match.group(2)
            objectid_hex_shifted = self.__shift_back_objectid_hex(objectid_hex_original)
            # Return the transformed filename, preserving the extension
            return f'"binary_filename": "{objectid_hex_shifted}.{extension}"'

        return re.sub(
            r"\"binary_filename\": \"([0-9a-fA-F]{24})\.([0-9a-zA-Z]{3,4})\"",
            objectid_replacer,
            bson_doc,
        )

    def replace_objectid_in_config_json(self, config_data: str) -> str:
        """
        Replace the ObjectIds that are embedded in JSON configuration files (e.g. exported label schema)

        :param config_data: JSON file parsed as UTF-8 string
        :return: Data after redaction
        """

        def objectid_replacer(match: re.Match) -> str:
            objectid_hex_original = match.group(1)
            return self.__shift_back_objectid_hex(objectid_hex_original)

        return re.sub(r"([0-9a-fA-F]{24})", objectid_replacer, config_data)

    def replace_objectid_in_model_xml(self, model_xml_data: str) -> bytes:
        """
        Replace the ObjectIds (label_ids) that are embedded in OpenVINO model .xml files.

        :param model_xml_data: Model .xml file data parsed as UTF-8
        :return: Redacted data (as Unicode string)
        """

        def _objectid_replacer(match: re.Match) -> str:
            objectid_hex_original = match.group(1)
            return self.__shift_back_objectid_hex(objectid_hex_original)

        def _redact_model_info_node(node_name: str) -> None:
            elem = model_info_elem.find(node_name)
            if elem is not None:
                old_value = elem.get("value")
                new_value = re.sub(r"([0-9a-fA-F]{24})", _objectid_replacer, old_value)
                elem.set("value", new_value)
                logger.debug(f"Updated node '{node_name}'")
            else:
                logger.debug(f"Node '{node_name}' is not present in model_info")

        xml_root = ElementTree.fromstring(model_xml_data)
        model_info_elem = xml_root.find("./rt_info/model_info")
        if model_info_elem is not None:
            _redact_model_info_node(node_name="label_ids")  # <label_ids value="..." />
            _redact_model_info_node(node_name="labels")  # <labels value="..." />
            _redact_model_info_node(node_name="label_info")  # <label_info value="..." />
        else:
            logger.warning("Could not locate 'rt_info/model_info' node")
        return ElementTree.tostring(xml_root, encoding="utf-8", xml_declaration=True)  # note: this outputs a bytestring

    def replace_objectid_in_exportable_code_wheel(self, wheel_file_path: str) -> None:
        """
        Replace the ObjectIds that are embedded in exportable code .whl files.

        :param wheel_file_path: Path to the .whl file to modify (in-place)
        """
        tmp_out_path = wheel_file_path + ".tmp"
        with (
            ZipFile(wheel_file_path, mode="r") as zip_in,
            ZipFile(tmp_out_path, mode="w") as zip_out,
        ):
            for item in zip_in.infolist():
                out_data: str | bytes
                match item.filename:
                    case "model/model.xml":
                        xml_file_data = zip_in.read(item).decode("utf-8")
                        out_data = self.replace_objectid_in_model_xml(xml_file_data)
                    case "model/config.json":
                        json_file_data = zip_in.read(item.filename).decode("utf-8")
                        out_data = self.replace_objectid_in_config_json(json_file_data)
                    case _:  # no redaction needed
                        out_data = zip_in.read(item.filename)
                zip_out.writestr(item, out_data)
        shutil.move(tmp_out_path, wheel_file_path)

    def replace_objectid_in_file(self, file_path: str) -> str:
        """
        Replace the ObjectIds that are embedded in a model-related object file.

        This function can detect and redact the following types of files:
          - OpenVINO IR model (.xml)
          - Serialized label schema (.json)
          - Exported visual prompt model reference features (.json)
          - Exportable code archive (.whl)

        :param file_path: Path to the file to modify (in-place)
        :return Path of the file
        """
        base_name = os.path.basename(file_path)
        if self._is_file_label_schema_json(base_name) or self._is_file_reference_features_json(base_name):
            with open(file_path) as file:
                config_data = file.read()
            redacted_config_data = self.replace_objectid_in_config_json(config_data=config_data)
            with open(file_path, "w") as file:
                file.write(redacted_config_data)
        elif self._is_file_model_xml(base_name):
            with open(file_path) as file:
                xml_data = file.read()
            redacted_xml_data = self.replace_objectid_in_model_xml(model_xml_data=xml_data)
            with open(file_path, "wb") as file:
                file.write(redacted_xml_data)
        elif self._is_file_exportable_code(base_name):
            self.replace_objectid_in_exportable_code_wheel(wheel_file_path=file_path)
        return file_path

    def mask_user_info_in_mongodb_doc(self, bson_doc: str) -> str:
        """
        Redact a document replacing all the fields that refer to users and personal data with a placeholder.

        :param bson_doc: MongoDB document encoded as BSON
        :return: Document after the replacement
        """

        def user_id_masker_str(match: re.Match) -> str:
            # Replace the value with the placeholder '$user_id_str'
            matched_key = match.group(1)
            return f'"{matched_key}": "$user_id_str"'

        def user_id_masker_uuid(match: re.Match) -> str:
            # Replace the value with the placeholder '$user_id_uuid4'
            matched_key = match.group(1)
            return f'"{matched_key}": "$user_id_uuid4"'

        # Build a regex to match all the known keys relative to user info
        keys_to_match = "|".join(re.escape(k) for k in self.USER_RELATED_KEYS)
        key_match_regex = r"\"((?:" + keys_to_match + r")(?:_id|_name|_uid)?)\""
        # User ids can be either stored as plain strings or UUID
        out_doc = re.sub(key_match_regex + r": \"(?:[^\"]*)\"", user_id_masker_str, bson_doc)
        return re.sub(
            key_match_regex + r": \{\"\$binary\": \{\"base64\": \"[A-Za-z0-9+/]*={0,2}\", \"subType\": \"04\"}}",
            user_id_masker_uuid,
            out_doc,
        )

    @staticmethod
    def remove_container_info_in_mongodb_doc(doc: dict) -> dict:
        """
        Remove (in-place) all keys relative to the project and its parent containers from the document to export.
        Keys to remove:
          - organization_id
          - workspace_id
          - project_id
          - location
        :param doc: Document to transform
        :return: Same document after removing the keys
        """
        keys_to_remove = ("organization_id", "workspace_id", "project_id", "location")
        for k in keys_to_remove:
            doc.pop(k, None)
        return doc

    @staticmethod
    def remove_lock_in_mongodb_doc(doc: dict) -> dict:
        """
        Remove in-place any lock stored in the document

        :param doc: Document to transform
        :return: Same document after removing the lock
        """
        keys_to_remove: list[str] = []
        for key in doc:
            if key.startswith("locked_until"):
                keys_to_remove.append(key)
        for key in keys_to_remove:
            doc.pop(key, None)
        return doc


class ImportDataRedactionUseCase(BaseDataRedactionUseCase):
    """
    This class is responsible for data modification during the import process.
    On import:
    - Create new ObjectIDs using the mapped object IDs in the imported documents
    - Generate new project, workspace and organization IDs for the imported data
    - Add the user ID of the importing user to the documents
    - Refresh the creation date of documents. Should only be used if query parameter keep_original_timestamps is False.

    :param objectid_replacement_min_int: Lowest ObjectId found during project export as integer.
        Only needed for ObjectId reconstruction.
    :param user_replacement_new_id: Identifier to use when updating user-relative data.
        Only needed for personal data replacement.
    """

    def __init__(
        self,
        objectid_replacement_min_int: int | None = None,
        user_replacement_new_id: UUID | None = None,
    ) -> None:
        self.objectid_replacement_min_int = objectid_replacement_min_int
        self.objectid_replacement_seed_int = int(str(self._generate_random_seed_oid()), 16)
        self.user_replacement_new_id = user_replacement_new_id
        self.user_replacement_new_id_encoded = (
            dumps(
                user_replacement_new_id,
                json_options=JSONOptions(uuid_representation=UuidRepresentation.STANDARD),
            )
            if user_replacement_new_id
            else None
        )
        self.import_date = DatetimeToMongo.forward(now())  # Used to overwrite old dates in imported project

    @staticmethod
    def _generate_random_seed_oid() -> ObjectId:
        # Generate a random datetime in range [2010, 2020], earlier than any random ObjectIds generated by Geti.
        return get_random_objectid_between_dates(
            min_date=datetime(2010, 1, 1, tzinfo=timezone.utc),
            max_date=datetime(2020, 1, 1, tzinfo=timezone.utc),
        )

    def __shift_forward_objectid_hex(self, objectid_hex: str) -> str:
        """
        Transform an ObjectId encoded as hex string according to the replacement algorithm for project import.

        Algorithm:
            1.	Get the minimum transformed id M, computed during project export
            2.	Generate a new ObjectId, let's call it “seed” (S). The same seed is used for all documents imported
                within the same operation. The seed has timestamp component in range [2010, 2020] to ensure that
                all new ids are 'in the past' with the respect to the import time.
            3.	Replace each id Y with Z = S + Y - M

        :param: Hex string representing the ObjectId to transform
        :return: Hex string representing the transformed (forward-shifted) ObjectId
        """
        objectid_int = int(objectid_hex, 16)
        return (
            f"{self.objectid_replacement_seed_int + objectid_int - cast('int', self.objectid_replacement_min_int):024x}"
        )

    def recreate_objectid_in_mongodb_doc(self, bson_doc: str) -> str:
        """
        Replace the substitute ids in a document with newly generated ObjectIds. This is needed for project import.

        :param bson_doc: MongoDB document encoded as BSON
        :return: Document after the replacement
        """

        def objectid_maker(match: re.Match) -> str:
            # Parse the substitute id ($sid)
            sid_hex = match.group(1)
            objectid_hex_shifted = self.__shift_forward_objectid_hex(sid_hex)
            # Return the transformed id string. The marker '$sid' (substitute) is also reverted to '$oid'.
            return f'"$oid": "{objectid_hex_shifted}"'

        if self.objectid_replacement_min_int is None:
            logger.error("Cannot reconstruct ObjectIds for imported docs if the minimum transformed id is not provided")
            raise ImportDataRedactionFailedException

        return re.sub(r"\"\$sid\": \"([0-9a-fA-F]{24})\"", objectid_maker, bson_doc)

    def recreate_media_based_objectid_in_mongodb_doc(self, doc: dict) -> dict:
        """
        Recreate (in-place) the _id field of a document where such an ObjectId was generated from the media identifier,
        rather than normally initialized with bson.ObjectId().

        Other regular ids present in the document are NOT edited by this method.

        :param doc: MongoDB document dictionary
        :return: Document after the replacement
        """
        if "media_identifier" not in doc:
            logger.error(
                "Cannot reconstruct id without key 'media_identifier'. Available keys: %s",
                list(doc.keys()),
            )
            raise ImportDataRedactionFailedException
        doc["_id"] = ObjectId(str(MediaIdentifierToMongo.backward(doc["media_identifier"]).as_id()))
        return doc

    def recreate_objectid_in_url(self, url: str) -> str:
        """
        Replace the substitute ids in a URL with newly generated ObjectIds. This is needed for project import.

        Example URL: /dataset_storages/659bb165c7d3a5f9a02be30a/images/659bb180c7d3a5f9a02be30b/foo.jpg

        Check the method 'recreate_objectid_in_mongodb_doc' for details about the replacing algorithm.

        :param url: String-like URL that may contain ids to replace
        :return: URL after substituting the ids
        """

        def objectid_maker(match: re.Match) -> str:
            # Parse the substitute id
            sid_as_int, trailing_char = int(match.group(1), 16), match.group(2)

            # Compute the new value
            objectid_replacement_min_int = cast("int", self.objectid_replacement_min_int)
            shifted_value = self.objectid_replacement_seed_int + sid_as_int - objectid_replacement_min_int
            shifted_value_hex = f"{shifted_value:024x}"

            return f"{shifted_value_hex}{trailing_char}"

        if self.objectid_replacement_min_int is None:
            logger.error("Cannot reconstruct ObjectIds for imported docs if the minimum transformed id is not provided")
            raise ImportDataRedactionFailedException

        # use lookbehind to not eat the leading slash; the suffix may be a slash, extension, thumbnail or nothing
        return re.sub(
            r"(?<=/)([0-9a-fA-F]{24})(/|$|(?:_thumbnail)?\.[0-9a-zA-Z]{2,4}$)",
            objectid_maker,
            url,
        )

    def recreate_objectid_based_binary_filename_in_mongodb_doc(self, bson_doc: str) -> str:
        """
        Reconstruct the 'binary_filename' of documents where this field is generated from the entity '_id'.
        This is especially relevant for images and videos, as they have filenames like '<some_object_id>.mp4'

        :param bson_doc: MongoDB document encoded as BSON
        :return: Document after the replacement
        """

        def objectid_maker(match: re.Match) -> str:
            # Parse the filename (substitute id) and the extension
            sid_hex = match.group(1)
            extension = match.group(2)
            objectid_hex_shifted = self.__shift_forward_objectid_hex(sid_hex)
            # Return the reconstructed filename, preserving the extension
            return f'"binary_filename": "{objectid_hex_shifted}.{extension}"'

        if self.objectid_replacement_min_int is None:
            logger.error("Cannot reconstruct ObjectIds for imported docs if the minimum transformed id is not provided")
            raise ImportDataRedactionFailedException

        return re.sub(
            r"\"binary_filename\": \"([0-9a-fA-F]{24})\.([0-9a-zA-Z]{3,4})\"",
            objectid_maker,
            bson_doc,
        )

    def recreate_objectid_in_config_json(self, config_data: str) -> str:
        """
        Recreate the ObjectIds that are embedded in JSON configuration files (e.g. exported label schema)

        :param config_data: JSON file parsed as UTF-8 string
        :return: Data after redaction
        """

        def objectid_replacer(match: re.Match) -> str:
            objectid_hex_original = match.group(1)
            return self.__shift_forward_objectid_hex(objectid_hex_original)

        return re.sub(r"([0-9a-fA-F]{24})", objectid_replacer, config_data)

    def recreate_objectid_in_model_xml(self, model_xml_data: str) -> bytes:
        """
        Recreate the ObjectIds (label_ids) that are embedded in OpenVINO model .xml files.

        :param model_xml_data: Model .xml file data parsed as UTF-8
        :return: Redacted data (as Unicode string)
        """

        def _objectid_replacer(match: re.Match) -> str:
            objectid_hex_original = match.group(1)
            return self.__shift_forward_objectid_hex(objectid_hex_original)

        def _redact_model_info_node(node_name: str) -> None:
            elem = model_info_elem.find(node_name)
            if elem is not None:
                old_value = elem.get("value")
                new_value = re.sub(r"([0-9a-fA-F]{24})", _objectid_replacer, old_value)
                elem.set("value", new_value)
                logger.debug(f"Updated node '{node_name}'")
            else:
                logger.debug(f"Node '{node_name}' is not present in model_info")

        xml_root = ElementTree.fromstring(model_xml_data)
        model_info_elem = xml_root.find("./rt_info/model_info")
        if model_info_elem is not None:
            _redact_model_info_node(node_name="label_ids")  # <label_ids value="..." />
            _redact_model_info_node(node_name="labels")  # <labels value="..." />
            _redact_model_info_node(node_name="label_info")  # <label_info value="..." />
        else:
            logger.warning("Could not locate 'rt_info/model_info' node")
        return ElementTree.tostring(xml_root, encoding="utf-8", xml_declaration=True)  # note: this outputs a bytestring

    def recreate_objectid_in_exportable_code_wheel(self, wheel_file_path: str) -> None:
        """
        Recreate the ObjectIds that are embedded in exportable code .whl files.

        :param wheel_file_path: Path to the .whl file to modify (in-place)
        """
        tmp_out_path = wheel_file_path + ".tmp"
        with (
            ZipFile(wheel_file_path, mode="r") as zip_in,
            ZipFile(tmp_out_path, mode="w") as zip_out,
        ):
            for item in zip_in.infolist():
                out_data: str | bytes
                match item.filename:
                    case "model/model.xml":
                        xml_file_data = zip_in.read(item).decode("utf-8")
                        out_data = self.recreate_objectid_in_model_xml(xml_file_data)
                    case "model/config.json":
                        json_file_data = zip_in.read(item.filename).decode("utf-8")
                        out_data = self.recreate_objectid_in_config_json(json_file_data)
                    case _:  # no redaction needed
                        out_data = zip_in.read(item.filename)
                zip_out.writestr(item, out_data)
        shutil.move(tmp_out_path, wheel_file_path)

    def recreate_objectid_in_file(self, file_path: str) -> str:
        """
        Recreate the ObjectIds that are embedded in a model-related object file.

        This function can detect and redact the following types of files:
          - OpenVINO IR model (.xml)
          - Serialized label schema (.json)
          - Exported visual prompt model reference features (.json)
          - Exportable code archive (.whl)

        :param file_path: Path to the file to modify (in-place)
        :return Path of the file
        """
        base_name = os.path.basename(file_path)
        if self._is_file_label_schema_json(base_name) or self._is_file_reference_features_json(base_name):
            with open(file_path) as file:
                config_data = file.read()
            redacted_config_data = self.recreate_objectid_in_config_json(config_data=config_data)
            with open(file_path, "w") as file:
                file.write(redacted_config_data)
        elif self._is_file_model_xml(base_name):
            with open(file_path) as file:
                xml_data = file.read()
            redacted_xml_data = self.recreate_objectid_in_model_xml(model_xml_data=xml_data)
            with open(file_path, "wb") as file:
                file.write(redacted_xml_data)
        elif self._is_file_exportable_code(base_name):
            self.recreate_objectid_in_exportable_code_wheel(wheel_file_path=file_path)
        return file_path

    def update_user_info_in_mongodb_doc(self, bson_doc: str) -> str:
        """
        Replace any placeholder for user-relative data in a document with the actual value.

        :param bson_doc: MongoDB document encoded as BSON
        :return: Document after the replacement
        """

        def user_id_updater_str(match: re.Match) -> str:
            # Replace the placeholder '$user_id_str' with the actual user id
            matched_key = match.group(1)
            return f'"{matched_key}": "{str(self.user_replacement_new_id)}"'

        def user_id_updater_uuid4(match: re.Match) -> str:
            # Replace the placeholder '$user_id_uuid4' with the actual user id, encoded as base64
            matched_key = match.group(1)
            return f'"{matched_key}": {self.user_replacement_new_id_encoded}'

        if self.user_replacement_new_id is None:
            logger.error("Cannot update user-relative info in imported docs because the new user id is not provided")
            raise ImportDataRedactionFailedException
        keys_to_match = "|".join(re.escape(k) for k in self.USER_RELATED_KEYS)
        out_doc = re.sub(
            r"\"((?:" + keys_to_match + r")(?:_id|_name)?)\": \"\$user_id_str\"",
            user_id_updater_str,
            bson_doc,
        )
        return re.sub(
            r"\"((?:" + keys_to_match + r")(?:_id|_name)?)\": \"\$user_id_uuid4\"",
            user_id_updater_uuid4,
            out_doc,
        )

    def update_creation_time_in_mongodb_doc(self, doc: dict) -> dict:
        """
        Updates the creation_date in a document to the import date of the project

        :param doc: Document to transform
        :return: Same document with updated creation date
        """
        if "creation_date" in doc:
            doc["creation_date"] = self.import_date
        if "upload_date" in doc:
            doc["upload_date"] = self.import_date
        return doc

    @staticmethod
    def sanitize_extension(filename: str) -> str:
        """
        Sanitize the extension of a filename to be lowercase.
        """
        name, extension = os.path.splitext(filename)
        return name + extension.lower()

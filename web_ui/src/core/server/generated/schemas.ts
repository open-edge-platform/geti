/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */


/** OneOf type helpers */
type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };
type XOR<T, U> = (T | U) extends object ? (Without<T, U> & U) | (Without<U, T> & T) : T | U;
type OneOf<T extends any[]> = T extends [infer Only] ? Only : T extends [infer A, infer B, ...infer Rest] ? OneOf<[XOR<A, B>, ...Rest]> : never;

export interface paths {
  "/organizations/users/external": {
    /** GET /organizations/users/{external_id} */
    get: operations["User_get_by_external_id"];
  };
  "/organizations/{organizationId}/activeUser": {
    /** GET /organizations/{organization_id}/users/active */
    get: operations["User_get_active_user"];
  };
  "/organizations/{organizationId}/users": {
    /** GET /organizations/{organization_id}/users  - conditions passed in the query string */
    get: operations["User_find"];
    /** POST /organizations/{organization_id}/users */
    post: operations["User_create"];
  };
  "/organizations/{organizationId}/users/{id}": {
    /** PUT /organizations/{organization_id}/users/{id} */
    put: operations["User_modify"];
  };
  "/organizations/{organizationId}/users/{userId}": {
    /** GET /organizations/{organization_id}/users/{id} */
    get: operations["User_get_by_id"];
    /** DELETE /organizations/{organization_id}/users/{id} */
    delete: operations["User_delete"];
  };
  "/organizations/{organizationId}/users/{userId}/photos": {
    /** GET /organizations/{organization_id}/users/{id}/photos */
    get: operations["User_get_photo"];
    /** DELETE /organization/{organization_id}/users/{id}/photos */
    delete: operations["User_delete_photo"];
  };
  "/organizations/{organizationId}/users/{userId}/roles": {
    /** PUT /organizations/{organization_id}/users/{id}/roles */
    put: operations["User_set_roles"];
  };
  "/organizations/{organizationId}/users/{userId}/roles/{resourceType}": {
    /** GET /organizations/{organization_id}/users/{id}/roles/{resource_type} */
    get: operations["User_get_roles"];
  };
  "/organizations/{user.organizationId}/users/invitations": {
    /** POST /organizations/{organization_id}/users/invitations */
    post: operations["User_send_invitation"];
  };
  "/profile": {
    /** GET /api/v1/profile */
    get: operations["User_get_user_profile"];
  };
  "/organizations": {
    /** GET /organizations  - conditions passed in the query string */
    get: operations["Organization_find"];
    /** POST /organizations */
    post: operations["Organization_create"];
  };
  "/organizations/invitations": {
    /** POST /organizations/invitations */
    post: operations["Organization_send_invitation"];
  };
  "/organizations/{id}": {
    /** GET /organizations/{id} */
    get: operations["Organization_get_by_id"];
    /** PUT /organizations/{id} */
    put: operations["Organization_modify"];
    /** DELETE /organizations/{id} */
    delete: operations["Organization_delete"];
  };
  "/organizations/{id}/photos": {
    /** GET /organizations/{organization_id}/photos */
    get: operations["Organization_get_photo"];
    /** DELETE /organizations/{organization_id}/photos */
    delete: operations["Organization_delete_photo"];
  };
  "/organizations/{organizationId}/workspaces": {
    /** GET /organizations/{organization_id}/workspaces  - conditions passed in the query string */
    get: operations["Workspace_find"];
    /** POST /organizations/{organization_id}/workspaces */
    post: operations["Workspace_create"];
  };
  "/organizations/{organizationId}/workspaces/{id}": {
    /** GET /organizations/{organization_id}/workspaces/{id} */
    get: operations["Workspace_get_by_id"];
    /** PUT /organizations/{organization_id}/workspaces */
    put: operations["Workspace_modify"];
    /** DELETE /organizations/{organization_id}/workspaces/{id} */
    delete: operations["Workspace_delete"];
  };
  "/organizations/{organizationId}/users/{userId}/statuses": {
    /** PUT /organizations/{organization_id}/users/{user_id}/statuses */
    put: operations["UserStatus_change"];
  };
  "/users/active": {
    /** Active User */
    get: operations["active_user_users_active_get"];
  };
  "/users": {
    /**
     * List Users
     * @description Get the list of users
     *
     * :param access_resource_type: Access resource type to filter the users by.
     * :param access_resource_id: Access resource id to filter the users by.
     */
    get: operations["list_users_users__get"];
    /** Create User */
    post: operations["create_user_users__post"];
  };
  "/users/{user_id}": {
    /**
     * Get User By Id
     * @description Endpoint for getting user's data.
     */
    get: operations["get_user_by_id_users__user_id__get"];
    /**
     * Edit User
     * @description Endpoint for updating user's data.
     */
    put: operations["edit_user_users__user_id__put"];
    /**
     * Delete User
     * @description /delete/{user_id} handler
     */
    delete: operations["delete_user_users__user_id__delete"];
  };
  "/users/{user_id}/photo": {
    /** Get User Photo */
    get: operations["get_user_photo_users__user_id__photo_get"];
    /** Upload User Photo */
    post: operations["upload_user_photo_users__user_id__photo_post"];
    /**
     * Delete User Photo
     * @description DELETE /users/{user_id}/photo handler
     */
    delete: operations["delete_user_photo_users__user_id__photo_delete"];
  };
  "/users/{user_id}/sessions": {
    /**
     * Delete User Sessions
     * @description DELETE /{user_id}/sessions handler
     */
    delete: operations["delete_user_sessions_users__user_id__sessions_delete"];
  };
  "/users/invite": {
    /** Invite */
    post: operations["invite_users_invite_post"];
  };
  "/users/login": {
    /**
     * Login User
     * @description /users/login handler
     */
    post: operations["login_user_users_login_post"];
  };
  "/users/request_password_reset": {
    /**
     * Request Password Reset
     * @description Request password endpoint on /users/request_password_reset"
     * :param user_data: data payload containing user's email address.
     * :param background_tasks: background tasks to be run after returning a response.
     */
    post: operations["request_password_reset_users_request_password_reset_post"];
  };
  "/users/reset_password": {
    /**
     * Reset Password
     * @description /users/reset_password handler
     */
    post: operations["reset_password_users_reset_password_post"];
  };
  "/users/confirm_registration": {
    /**
     * Confirm Registration
     * @description /users/confirm_registration handler
     */
    post: operations["confirm_registration_users_confirm_registration_post"];
  };
  "/users/registration/reset-password": {
    /** Check Token Validity For Registration */
    get: operations["check_token_validity_for_registration_users_registration_reset_password_get"];
  };
  "/users/registration/sign-up": {
    /** Check Token Validity For Registration */
    get: operations["check_token_validity_for_registration_users_registration_sign_up_get"];
  };
  "/users/{user_id}/roles": {
    /**
     * Get User Roles By Id
     * @description Returns user's roles for given specific resource, or all resources of given type.
     * If both resource_type and resource_id parameters are passed, roles for that specific resource will be returned.
     * If only resource_type is passed, roles for all resources of given type will be returned.
     */
    get: operations["get_user_roles_by_id_users__user_id__roles_get"];
    /**
     * Patch User Roles By Id
     * @description Endpoint for getting user's data.
     */
    patch: operations["patch_user_roles_by_id_users__user_id__roles_patch"];
  };
  "/users/{user_id}/update_password": {
    /**
     * Update User Password
     * @description /users/[user_id]/update_password handler
     */
    post: operations["update_user_password_users__user_id__update_password_post"];
  };
  "/users/get_user_id": {
    /**
     * Get User Id From Protobuf
     * @description Returns user id calculated based on the protobuf content from the HTTP request.
     */
    get: operations["get_user_id_from_protobuf_users_get_user_id_get"];
  };
  "/service_accounts/access_token": {
    /** Get Access Token */
    post: operations["get_access_token_service_accounts_access_token_post"];
  };
  "/service_accounts": {
    /** Get Service Account */
    get: operations["get_service_account_service_accounts__get"];
    /** Refresh Service Account */
    put: operations["refresh_service_account_service_accounts__put"];
    /** Create Service Account */
    post: operations["create_service_account_service_accounts__post"];
    /** Delete Service Account */
    delete: operations["delete_service_account_service_accounts__delete"];
  };
  "/feature_flags": {
    /**
     * List Feature Flags
     * @description Get map of feature flags to their corresponding enablement status.
     */
    get: operations["list_feature_flags_feature_flags__get"];
  };
  "/logs": {
    /**
     * Logs Endpoint
     * @description Request logs endpoint on /logs"
     */
    get: operations["logs_endpoint_logs__get"];
  };
  "/products": {
    /**
     * Get All Products
     * @description Returns all available Geti SaaS subscription products
     */
    get: operations["get_all_products_api_v1_products_get"];
  };
  "/products/{product_id}": {
    /**
     * Get Product By Id
     * @description Returns Geti SaaS subscription product with the specified id
     */
    get: operations["get_product_by_id_api_v1_products__product_id__get"];
  };
  "/organizations/{org_id}/balance": {
    /**
     * Get Balance
     * @description The running credit balance of an organization is calculated during the current subscription cycle
     */
    get: operations["get_balance_api_v1_organizations__org_id__balance_get"];
  };
  "/organizations/{org_id}/credit_accounts/{account_id}/balance": {
    /**
     * Edit Account Balance
     * @description Edits balance of a certain credit account by comparing current available balance
     * with a balance in the provided payload, and creating a credits transaction covering the difference.
     */
    put: operations["edit_account_balance_api_v1_organizations__org_id__credit_accounts__account_id__balance_put"];
  };
  "/organizations/{org_id}/credit_accounts": {
    /**
     * Get Credit Accounts
     * @description Returns billable credit accounts of the organization ('asset' account type, not expired).
     * Lease and SaaS provider accounts not included.
     */
    get: operations["get_credit_accounts_api_v1_organizations__org_id__credit_accounts_get"];
    /**
     * Create Credit Account
     * @description Creates a new asset account for the organization.
     */
    post: operations["create_credit_account_api_v1_organizations__org_id__credit_accounts_post"];
  };
  "/organizations/{org_id}/credit_accounts/{acc_id}": {
    /**
     * Update Credit Account
     * @description Updates the credit account of the organization.
     */
    put: operations["update_credit_account_api_v1_organizations__org_id__credit_accounts__acc_id__put"];
  };
  "/organizations/{organization_id}/subscriptions": {
    /**
     * [SaaS] Get all organization's subscriptions
     * @description <i>Not available on on-premises environments.</i><br><br> Returns all organization's subscriptions.
     */
    get: operations["get_organization_subscriptions_api_v1_organizations__organization_id__subscriptions_get"];
    /**
     * Create Subscription
     * @description Creates new subscription within organization for specified product
     */
    post: operations["create_subscription_api_v1_organizations__organization_id__subscriptions_post"];
  };
  "/organizations/{organization_id}/subscriptions/{subscription_id}": {
    /**
     * Get Subscription By Id
     * @description Returns organization's subscription with the requested id
     */
    get: operations["get_subscription_by_id_api_v1_organizations__organization_id__subscriptions__subscription_id__get"];
  };
  "/organizations/{org_id}/transactions/aggregates": {
    /**
     * Get Credit Consumption Aggregates
     * @description The Aggregating endpoint allows to retrieve credit consumption grouped by various
     * dimensions such as project and workspace, date, etc.
     */
    get: operations["get_credit_consumption_aggregates_api_v1_organizations__org_id__transactions_aggregates_get"];
  };
  "/organizations/{org_id}/transactions": {
    /**
     * Get Transactions
     * @description The Aggregating endpoint allows to retrieve credit consumption grouped by various
     * dimensions such as project and workspace, date, etc.
     */
    get: operations["get_transactions_api_v1_organizations__org_id__transactions_get"];
  };
  "/internal/tasks/credit_accounts/rollover": {
    /**
     * Rollover Credit Accounts
     * @description Performs credit accounts renewal.
     */
    post: operations["rollover_credit_accounts_api_v1_internal_tasks_credit_accounts_rollover_post"];
  };
  "/internal/tasks/credit_accounts/snapshot": {
    /**
     * Calculate Snapshot
     * @description Get all non-renewable, active (not expired) asset credit accounts,
     * and for each of them calculate and write to the database a balance snapshot, with available and incoming balances.
     *
     * Calculation takes the latest account's snapshot value (if available) and incorporates
     * transactions created thereafter until the present moment
     */
    post: operations["calculate_snapshot_api_v1_internal_tasks_credit_accounts_snapshot_post"];
  };
  "/personal_access_tokens/organization": {
    /**
     * Get Organization ID for Personal Access Token.
     * @description Return ID for Organization that Personal Account Token is created for. Use returned value in all subsequent calls as `organization_id` parameter.
     */
    get: operations["PersonalAccessTokenOrganization"];
  };
  "/organizations/{organization_id}/workspaces": {
    /**
     * Get information about all workspaces
     * @description List all workspaces in an organization.
     */
    get: operations["GetAllWorkspaces"];
  };
  "/organizations/{organization_id}/workspaces/{workspace_id}/projects": {
    /**
     * Get info about all projects in a workspace
     * @description Get all projects in the workspace.
     */
    get: operations["GetAllProjectsInAWorkspace"];
    /**
     * Create a project
     * @description Create a project in a workspace. Please refer to the schema to see all the supported tasks and please refer to the examples to see how
     * the project is constructed. At the moment, Geti supports projects with a single deep learning task, or with two in a
     * chain (Detection -> Classification and Detection -> Segmentation).
     * A few label constraints:
     * - Detection projects must have at least 1 label provided.
     * - A default 'No object' label is automatically created for detection and segmentation tasks.
     * - Classification projects require at least two labels (top-level, if hierarchical). For binary classification, please declare the negative label explicitly.
     * - A default 'No class' label is automatically created for classification tasks if there are no exclusive groups with 2+ labels. In practice, multilabel classification has the empty label, multiclass classification does not.
     * - Anomaly project must either have 2 labels provided (one being is_anomalous), or no labels provided.
     */
    post: operations["CreateProject"];
  };
  "/organizations/{organization_id}/workspaces/{workspace_id}/projects_names": {
    /**
     * Get the names of all projects in a workspace.
     * @description Get names of all projects in a workspace
     */
    get: operations["GetAllProjectsNamesInAWorkspace"];
  };
  "/organizations/{organization_id}/workspaces/{workspace_id}/projects/{project_id}": {
    /**
     * Get info about a project
     * @description Get information about a project.
     */
    get: operations["GetProjectInfo"];
    /**
     * Edit a project
     * @description Edit project properties. This is limited to:
     * - Editing project name
     * - Adding or removing labels
     * - Editing label name, color, and hotkey.
     */
    put: operations["EditProject"];
    /**
     * Delete a project
     * @description Delete a project. Note that a deleted project cannot be recovered.
     */
    delete: operations["DeleteProject"];
  };
  "/organizations/{organization_id}/workspaces/{workspace_id}/projects/{project_id}/thumbnail": {
    /**
     * Download the thumbnail of a project
     * @description Download a project thumbnail with height and width as specified in the request parameters.
     */
    get: operations["DownloadProjectThumbnail"];
  };
  "/organizations/{organization_id}/workspaces/{workspace_id}/projects/{project_id}/datasets": {
    /**
     * Get datasets
     * @description List all the datasets in a project.
     */
    get: operations["GetDatasetsInfo"];
    /**
     * Create dataset
     * @description Create a new dataset in a project.
     * At the moment, the new dataset can be used as a held-out testing dataset via model testing job.
     */
    post: operations["CreateDataset"];
  };
  "/organizations/{organization_id}/workspaces/{workspace_id}/projects/{project_id}/datasets/{dataset_id}": {
    /**
     * Get info about dataset
     * @description Get information about a dataset in a project.
     */
    get: operations["GetDatasetInfo"];
    /**
     * Update dataset
     * @description Edit a dataset, currently limited to dataset renaming.
     */
    put: operations["UpdateDatasetInfo"];
    /**
     * Delete dataset
     * @description Delete dataset along with its media and annotations. Note that this operation is not reversible.
     */
    delete: operations["DeleteDataset"];
  };
  "/organizations/{organization_id}/workspaces/{workspace_id}/projects/{project_id}/datasets/{dataset_id}/statistics": {
    /**
     * Get statistics for a dataset
     * @description Retrieve the dataset statistics overview, this includes the number of images/videos, number of annotations, and number of objects per label.
     */
    get: operations["GetDatasetStatistics"];
  };
  "/organizations/{organization_id}/workspaces/{workspace_id}/projects/{project_id}/datasets/{dataset_id}/media:query": {
    /**
     * Retrieve media items with query
     * @description Retrieves media in the dataset that fulfill the filter condition.
     * The list of filter fields and their possible operators are shown below.
     * If a field-operation combination is not supported then the endpoint will respond with the possible operators that are allowed for the filter.
     * Note that this endpoint returns images and videos. To retrieve the video frames, use the video id returned by this endpoint and pass it to the
     * [video filtering](#Media/FilterVideoFrames) endpoint.
     *
     * | Filter fields | Supported operations | Value |
     * |--------------|----------------------|-------|
     * |`media_upload_date`, `annotation_creation_date` | `greater`, `less` | Isodate. Example: `2024-09-26T00:00:00+02:00` |
     * |`media_height`, `media_width`, `shape_area_percentage`, `shape_area_pixel`, `media_size`, `video_duration`, `video_frame_rate`, `video_frame_count` | `greater`, `greater_or_equal`, `less`, `less_or_equal`, `equal`, `not_equal` | integer |
     * |`media_name` | `equal`, `not_equal`, `contains` | string |
     * |`label_id`, `shape_type`, `user_name` | `equal`, `not_equal`, `in`, `not_in` | string (id format) |
     * |`annotation_scene_state` | `equal`, `not_equal`, `in` | string (enum: `annotated`, `partially_annotated`, `unannotated`) |
     * |`media_type` | `equal`, `not_equal` | string |
     */
    post: operations["FilterMedia"];
  };
  "/organizations/{organization_id}/workspaces/{workspace_id}/projects/{project_id}/datasets/{dataset_id}/media/images": {
    /**
     * Upload an image
     * @description Upload an image to a dataset. Allowed formats are `.jpg`, `.jpeg`, `.bmp`, `.png`, `.tif`, `.tiff`, `.jfif`, and `.webp`. Height and
     * width of the images must be between 32 and 20000 pixels.
     * For a classification project, the uploaded image can be annotated directly by specifying the labels in the field `upload_info`.
     */
    post: operations["UploadImage"];
  };
  "/organizations/{organization_id}/workspaces/{workspace_id}/projects/{project_id}/datasets/{dataset_id}/media/images/{image_id}": {
    /**
     * Get image detail
     * @description Retrieves detailed information of an image.
     */
    get: operations["GetImageDetail"];
    /**
     * Delete an image
     * @description Delete an image from a dataset. This operation is not reversible.
     */
    delete: operations["DeleteAnImage"];
  };
  "/organizations/{organization_id}/workspaces/{workspace_id}/projects/{project_id}/datasets/{dataset_id}/media/images/{image_id}/display/full": {
    /**
     * Download full image
     * @description Download the image in the original resolution.
     */
    get: operations["DownloadFullImage"];
  };
  "/organizations/{organization_id}/workspaces/{workspace_id}/projects/{project_id}/datasets/{dataset_id}/media/images/{image_id}/display/thumb": {
    /**
     * Download the thumbnail of an image
     * @description Download the thumbnail version of an image.
     */
    get: operations["DownloadImageThumbnail"];
  };
  "/organizations/{organization_id}/workspaces/{workspace_id}/projects/{project_id}/datasets/{dataset_id}/media/videos": {
    /**
     * Upload a video
     * @description Upload a video to a dataset. Allowed formats are `.mp4`, `.avi`, `.mkv` `.mov`, `.webm` and `.m4v`. The maximum resolution for
     * videos is 8K and the file may not be larger than 4.7 GB. For a classification project, all frames of the uploaded
     * video can be annotated directly by specifying the labels in the field upload_info.
     */
    post: operations["UploadVideo"];
  };
  "/organizations/{organization_id}/workspaces/{workspace_id}/projects/{project_id}/datasets/{dataset_id}/media/videos/{video_id}": {
    /**
     * Get video detail
     * @description Retrieves the detail of a video.
     */
    get: operations["GetVideoDetail"];
    /**
     * Delete a video
     * @description Delete a video from a dataset. This operation is not reversible.
     */
    delete: operations["DeleteAVideo"];
  };
  "/organizations/{organization_id}/workspaces/{workspace_id}/projects/{project_id}/datasets/{dataset_id}/media/videos/{video_id}:query": {
    /**
     * Retrieve specific frames from a video by applying a query on the dataset
     * @description Retrieves video frames from a video which fulfill the filter condition.
     * The list of filter fields and their possible operators are shown below.
     * If a field-operation combination is not supported then the endpoint will respond with the possible operators that are allowed for the filter.
     *
     * | Filter fields | Supported operations | Value |
     * |--------------|----------------------|-------|
     * |`annotation_creation_date` | `greater`, `less` | Isodate. Example: `2024-09-26T00:00:00+02:00` |
     * |`shape_area_percentage`, `shape_area_pixel` | `greater`, `greater_or_equal`, `less`, `less_or_equal`, `equal`, `not_equal` | integer |
     * |`label_id`, `shape_type`, `user_name` | `equal`, `not_equal`, `in`, `not_in` | string (id format) |
     * |`annotation_scene_state` | `equal`, `not_equal`, `in` | string (enum: `annotated`, `partially_annotated`, `unannotated`) |
     */
    post: operations["FilterVideoFrames"];
  };
  "/organizations/{organization_id}/workspaces/{workspace_id}/projects/{project_id}/datasets/{dataset_id}/media/videos/{video_id}/display/stream": {
    /**
     * Download video stream
     * @description Download the video stream in original resolution.
     */
    get: operations["DownloadVideoStream"];
  };
  "/organizations/{organization_id}/workspaces/{workspace_id}/projects/{project_id}/datasets/{dataset_id}/media/videos/{video_id}/display/thumb": {
    /**
     * Download the thumbnail for a video
     * @description Download the thumbnail of a video.
     * The video thumbnail is the downscaled version of a frame from the middle of the video.
     */
    get: operations["DownloadVideoThumbnail"];
  };
  "/organizations/{organization_id}/workspaces/{workspace_id}/projects/{project_id}/datasets/{dataset_id}/media/videos/{video_id}/frames/{frame_index}/display/full": {
    /**
     * Download a video frame
     * @description Download a video frame in original resolution.
     */
    get: operations["DownloadVideoFrameFull"];
  };
  "/organizations/{organization_id}/workspaces/{workspace_id}/projects/{project_id}/datasets/{dataset_id}/media/videos/{video_id}/frames/{frame_index}/display/thumb": {
    /**
     * Download a thumbnail for a video frame
     * @description Download a video frame thumbnail.
     */
    get: operations["DownloadVideoFrameThumbnail"];
  };
  "/organizations/{organization_id}/workspaces/{workspace_id}/projects/{project_id}/datasets/{dataset_id}/media/images/{image_id}/annotations": {
    /**
     * Create an annotation for an image
     * @description Create a user annotation for an image. The user annotation scene contains multiple annotations, each of which is defined by a geometric shape and a
     * list of labels for that shape. The shape is defined in pixels.
     */
    post: operations["CreateImageAnnotation"];
  };
  "/organizations/{organization_id}/workspaces/{workspace_id}/projects/{project_id}/datasets/{dataset_id}/media/images/{image_id}/annotations/{annotation_id}": {
    /**
     * Get annotations from an image
     * @description Get the user annotation of an image.
     */
    get: operations["GetImageAnnotation"];
  };
  "/organizations/{organization_id}/workspaces/{workspace_id}/projects/{project_id}/datasets/{dataset_id}/media/videos/{video_id}/frames/{frame_index}/annotations": {
    /**
     * Create an annotation for a video frame
     * @description Create a user annotation for a video frame. The user annotation scene contains multiple annotations, each of which is defined by a geometric shape and a
     * list of labels for that shape. The shape is defined in pixels.
     */
    post: operations["CreateVideoFrameAnnotation"];
  };
  "/organizations/{organization_id}/workspaces/{workspace_id}/projects/{project_id}/datasets/{dataset_id}/media/videos/{video_id}/frames/{frame_index}/annotations/{annotation_id}": {
    /**
     * Get annotations from a video frame
     * @description Get the user annotation of a video frame.
     */
    get: operations["GetVideoFrameAnnotation"];
  };
  "/organizations/{organization_id}/workspaces/{workspace_id}/projects/{project_id}/datasets/{dataset_id}/media/videos/{video_id}/range_annotation": {
    /**
     * Get the video annotation range
     * @description Get the labels per frame range for a video. A frame range is a range from a start to end frame combined
     * with labels. The start and end frame are inclusive.
     */
    get: operations["GetVideoAnnotationRange"];
    /**
     * Create a video annotation range
     * @description Create a video annotation range for a video. The request body should contain the full list of
     * frame ranges along with the ids of the labels associated with those ranges. Any previously submitted annotation range
     * for the same video is overridden by the new request; moreover, any interval of frames that is not explicitly specified
     * in the request is marked as unannotated.
     */
    post: operations["CreateVideoAnnotationRange"];
  };
  "/organizations/{organization_id}/workspaces/{workspace_id}/projects/{project_id}/datasets/{dataset_id}/media/videos/{video_id}/annotations/latest": {
    /**
     * Get the annotations from a video
     * @description Get the user annotations for the video frames in a video.
     */
    get: operations["GetVideoAnnotation"];
  };
  "/organizations/{organization_id}/workspaces/{workspace_id}/projects/{project_id}/supported_algorithms": {
    /**
     * Get supported algorithms
     * @description List the algorithms (model architectures) supported for the tasks within a project.
     */
    get: operations["GetSupportedAlgorithms"];
  };
  "/organizations/{organization_id}/workspaces/{workspace_id}/projects/{project_id}:train": {
    /**
     * Train a model
     * @description Submit a training job.
     */
    post: operations["TrainModel"];
  };
  "/organizations/{organization_id}/workspaces/{workspace_id}/projects/{project_id}/train": {
    /**
     * Train a model
     * @deprecated
     * @description Submit a training job. Note - This endpoint is deprecated and will be removed after 2025-03-31. Please use the new endpoint `:train` instead.
     */
    post: operations["LegacyTrainModel"];
  };
  "/organizations/{organization_id}/workspaces/{workspace_id}/projects/{project_id}/model_groups": {
    /**
     * Get information on all models and their groups belonging to a project
     * @description Get information on all model groups in a project. Each model group represents one model architecture that has been trained in the project and
     * contains a list of successfully trained models of that architecture.
     * To obtain more detail on each of the model version, please use the [model detail](#Models/GetModelDetail) endpoint.
     */
    get: operations["GetModelGroups"];
  };
  "/organizations/{organization_id}/workspaces/{workspace_id}/projects/{project_id}/model_groups/{model_group_id}": {
    /**
     * Get information on all models in a model group
     * @description Get information about a specific model group, including the models in that group.
     * Each model group represents one model architecture that has been trained in the project and
     * contains a list of successfully trained models of that architecture.
     */
    get: operations["GetModelGroup"];
  };
  "/organizations/{organization_id}/workspaces/{workspace_id}/projects/{project_id}/model_groups/{model_group_id}:activate": {
    /**
     * Set the latest model in the model group as the active model
     * @description Set the latest model of the model group to be the active model.
     * Active model is used to generate predictions requested through the
     * [predict](#Predictions/GetSinglePrediction) or [explain](#Predictions/GetSingleExplanation) endpoints
     * (and their batch variants).
     */
    post: operations["ActivateModelGroup"];
  };
  "/organizations/{organization_id}/workspaces/{workspace_id}/projects/{project_id}/model_groups/{model_group_id}/models/{model_id}": {
    /**
     * Get detailed information on a model
     * @description Get detailed information on a model. The response contains the base model version as well as the list of
     * optimized models (OpenVINO and ONNX) that are generated from the base model.
     */
    get: operations["GetModelDetail"];
  };
  "/organizations/{organization_id}/workspaces/{workspace_id}/projects/{project_id}/model_groups/{model_group_id}/models/{model_id}/statistics": {
    /**
     * Get statistics for a model
     * @description Get statistics for a model. The statistics includes training and evaluation statistics.
     * The response will be a list of charts; each chart will be one of the following types: `text`, `bar`, `radial_bar`, `line` or `matrix`. For each type of chart, the response body has a different
     * format. See the schemas for information on the format of the response.
     */
    get: operations["GetModelStatistics"];
  };
  "/organizations/{organization_id}/workspaces/{workspace_id}/projects/{project_id}/model_groups/{model_group_id}/models/{model_id}/export": {
    /**
     * Export a model.
     * @description Export a zip file with data from a base (non-optimized) model.
     * This endpoint only handles the export of base model weights, and does not include code.
     */
    get: operations["ExportModel"];
  };
  "/organizations/{organization_id}/workspaces/{workspace_id}/projects/{project_id}/model_groups/{model_group_id}/models/{model_id}/optimized_models/{optimized_model_id}/export": {
    /**
     * Export an optimized model
     * @description Export a zip file with data from an optimized model (OpenVINO or ONNX).
     */
    get: operations["ExportOptimizedModel"];
  };
  "/organizations/{organization_id}/workspaces/{workspace_id}/projects/{project_id}/model_groups/{model_group_id}/models/{model_id}:optimize": {
    /**
     * Optimize a model
     * @description Submit an optimization job for a model.
     * The optimization is done through [post-training quantization](https://github.com/openvinotoolkit/nncf/blob/develop/docs/usage/post_training_compression/post_training_quantization/Usage.md).
     */
    post: operations["OptimizeModel"];
  };
  "/organizations/{organization_id}/workspaces/{workspace_id}/projects/{project_id}/model_groups/{model_group_id}/models/{model_id}/optimize": {
    /**
     * Optimize a model. Note - This endpoint is deprecated. Please use the new endpoint `:optimize` instead.
     * @deprecated
     * @description Submit an optimization job for a model.
     * The optimization is done through [post-training quantization](https://github.com/openvinotoolkit/nncf/blob/develop/docs/usage/post_training_compression/post_training_quantization/Usage.md).
     */
    post: operations["LegacyOptimizeModel"];
  };
  "/organizations/{organization_id}/workspaces/{workspace_id}/projects/{project_id}/model_groups/{model_group_id}/models/{model_id}:purge": {
    /**
     * Archive a model
     * @description Archive a model. This will permanently delete all the binary files related to the model including base model
     * weights, optimized model weights and exportable code. This endpoint can only be called on base models, not optimized
     * models. Additionally, the model must not be the latest in a model group or be the active model.
     */
    post: operations["ArchiveModel"];
  };
  "/organizations/{organization_id}/workspaces/{workspace_id}/projects/{project_id}/datasets/{dataset_id}/media/images/{image_id}/predictions/{prediction_type_or_id}": {
    /**
     * Get a prediction for an image
     * @description Get a prediction for an image. This endpoint currently only supports 'latest' prediction type, where the server returns the latest prediction from cache. Other types have been deprecated: if you want to generate a fresh prediction with the active model ('online') then use the pipelines/<pipeline_id>:predict endpoint.
     */
    get: operations["GetImagePrediction"];
  };
  "/organizations/{organization_id}/workspaces/{workspace_id}/projects/{project_id}/datasets/{dataset_id}/media/videos/{video_id}/predictions/latest": {
    /**
     * Get cached predictions for a video
     * @description Get predictions for a video from the database cache. Note that this endpoint **does not** generate predictions on the fly. For predictions on the fly,
     * use the [single prediction](#Predictions/GetSinglePrediction) or the [batch prediction](#Predictions/GetBatchPrediction) endpoints.
     *
     * Parameters `start_frame`, `end_frame` and `frameskip` can be used
     * to only get predictions in a certain range. There is a maximum amount of 20 predictions that can be
     * returned by the endpoint. If the combination of `start_frame`, `end_frame` and `frameskip` results in more than 20 predictions,
     * only the first 20 frames will be returned and there is a `next_page` object in the response pointing to the URL that will return
     * the next predictions.
     */
    get: operations["GetCachedVideoPrediction"];
  };
  "/organizations/{organization_id}/workspaces/{workspace_id}/projects/{project_id}/datasets/{dataset_id}/media/videos/{video_id}/frames/{frame_index}/predictions/{prediction_type_or_id}": {
    /**
     * Get a prediction for a video frame
     * @description Get a prediction for a video frame. This endpoint currently only supports 'latest' prediction type, where the server returns the latest prediction from cache. Other types have been deprecated: if you want to generate a fresh prediction with the active model ('online') then use the pipelines/<pipeline_id>:predict endpoint.
     */
    get: operations["GetVideoFramePrediction"];
  };
  "/organizations/{organization_id}/workspaces/{workspace_id}/projects/{project_id}/datasets/active": {
    /**
     * Get the active dataset
     * @description Retrieve active dataset for a project. The active dataset is the set of images and video frames that are suggested for annotation by the active learning algorithm.
     */
    get: operations["GetActiveDataset"];
  };
  "/organizations/{organization_id}/workspaces/{workspace_id}/projects/{project_id}/tests": {
    /**
     * Get info about all tests in project
     * @description Get all tests in the project. Includes info of the model, datasets and the job id.
     */
    get: operations["GetAllTestsInAProject"];
    /**
     * Start new model test job
     * @description Starts a new model test job which creates and populates a test resource
     */
    post: operations["TriggerModelTestJob"];
  };
  "/organizations/{organization_id}/workspaces/{workspace_id}/projects/{project_id}/tests/{test_id}": {
    /**
     * Get info about a test in project
     * @description Get info of test in the project. Includes info of the model, datasets and the job id.
     */
    get: operations["GetTestInAProject"];
    /**
     * Delete all info about a test
     * @description Delete all the information relative to a test in the project.
     */
    delete: operations["DeleteTestInAProject"];
  };
  "/organizations/{organization_id}/workspaces/{workspace_id}/projects/{project_id}/tests/{test_id}/results:query": {
    /**
     * Retrieve specific media test results by applying a query on the test
     * @description Allows the user to quickly filter through their test results by supplying one or more filters to match results against. Currently you can filter on 'score' and 'label_id' fields. The following operators can be used for score 'greater', 'less', 'greater_or_equal', 'less_or_equal'. The following operator can be used for label id 'equal'. If a non-allowed filter is used, then the endpoint will respond with the possible operators that are allowed.
     */
    post: operations["FilterDataset"];
  };
  "/organizations/{organization_id}/workspaces/{workspace_id}/projects/{project_id}/tests/{test_id}/predictions/{prediction_id}": {
    /**
     * Get a prediction from a test in project
     * @description Get a prediction from a test in the project.
     */
    get: operations["GetPredictionFromTestInAProject"];
  };
  "/organizations/{organization_id}/workspaces/{workspace_id}/projects/{project_id}/datasets/{dataset_id}/training_revisions/{dataset_revision_id}": {
    /**
     * Get statistics for a training revision
     * @description Retrieves the training revision statistics overview. A training revision is a specific dataset that has been split into the three Deep Learning subsets; Train, Test, and Validation. The "subset_info" retrieves the split of images and frames (aggregated together from the dataset) among the Train, Test, and Validation subsets. The "dataset_info" retrieves the distribution of images, videos, and frames within the whole dataset.
     */
    get: operations["GetTrainingRevisionStatistics"];
  };
  "/organizations/{organization_id}/workspaces/{workspace_id}/projects/{project_id}/datasets/{dataset_id}/training_revisions/{dataset_revision_id}/media": {
    /**
     * Retrieve all media in a training revision
     * @description Allows the user to get all the media items in a training revision. A training revision is a dataset which contains the Training, Testing, and Validation subsets. A training revision ID can be obtained after starting at least one training inference.
     */
    get: operations["GetMediaForDataset"];
  };
  "/organizations/{organization_id}/workspaces/{workspace_id}/projects/{project_id}/datasets/{dataset_id}/training_revisions/{dataset_revision_id}/media:query": {
    /**
     * Retrieve specific media items by applying a query on the training revision
     * @description Allows the user to quickly filter through their training revision by supplying one or more filters to match media items against. Currently you can filter on 'media_upload_date', 'media_height', 'media_width' , 'media_name', 'label_id',  'annotation_scene_state', 'annotation_creation_date', 'shape_type', 'shape_area_percentage', 'shape_area_pixel', 'subset' and 'user_name'. The following operators can be used 'greater', 'less', 'greater_or_equal', 'less_or_equal', 'equal',  'not_equal', 'in' and 'not_in'. Not all combinations of filter and operator can be used. If a combination is not  supported then the endpoint will respond with the possible operators that are allowed for the filter.
     */
    post: operations["FilterMediaInTrainingRevision"];
  };
  "/organizations/{organization_id}/workspaces/{workspace_id}/projects/{project_id}/datasets/{dataset_id}/training_revisions/{dataset_revision_id}/media/videos/{video_id}:query": {
    /**
     * Retrieve specific frames from a video in a training revision by applying a query
     * @description Allows the user to quickly filter through frames in a video in a specific training revision by supplying one or  more filters to match frames against. Currently you can filter on 'label_id',  'annotation_scene_state',  'annotation_creation_date', 'shape_type', 'shape_area_percentage', 'shape_area_pixel' and 'user_name'. The following  operators can be used 'greater', 'less', 'greater_or_equal', 'less_or_equal', 'equal', 'not_equal', 'in' and 'not_in'. Not all combinations of filter and operator can be used. If a combination is not supported, the endpoint will respond  with the possible operators that are allowed for the filter.
     */
    post: operations["FilterVideoFramesInTrainingRevision"];
  };
  "/organizations/{organization_id}/workspaces/{workspace_id}/projects/{project_id}/pipelines/{pipeline_id}:predict": {
    /**
     * Generate or retrieve a prediction for an image or video frame
     * @description Generate or retrieve a prediction for an image or a single video frame.
     */
    post: operations["GetSinglePrediction"];
  };
  "/organizations/{organization_id}/workspaces/{workspace_id}/projects/{project_id}/pipelines/{pipeline_id}:explain": {
    /**
     * Generate or retrieve explanations for an image or video frame
     * @description Generate or retrieve explanations of the inference output for an image or a single video frame. The explanation is typically the heatmap
     * highlighting the area which the model finds to be salient. For more info, please refer to [OpenVINO XAI](https://github.com/openvinotoolkit/openvino_xai).
     */
    post: operations["GetSingleExplanation"];
  };
  "/organizations/{organization_id}/workspaces/{workspace_id}/projects/{project_id}/pipelines/{pipeline_id}:batch_predict": {
    /**
     * Generate or retrieve predictions for a batch of video frames
     * @description Generate or retrieve the predictions for a sequence of video frames.
     */
    post: operations["GetBatchPrediction"];
  };
  "/organizations/{organization_id}/workspaces/{workspace_id}/projects/{project_id}/pipelines/{pipeline_id}:batch_explain": {
    /**
     * Generate or retrieve explanations for a batch of video frames
     * @description Generate or retrieve explanations of the inference output for a sequence of video frames. The explanation is typically the heatmap
     * highlighting the area which the model finds to be salient. For more info, please refer to [OpenVINO XAI](https://github.com/openvinotoolkit/openvino_xai).
     */
    post: operations["GetBatchExplanation"];
  };
  "/organizations/{organization_id}/workspaces/{workspace_id}/projects/{project_id}/pipelines/{task_id}:prompt": {
    /**
     * Generate prediction using the prompt model
     * @description Generate a prediction for an image or a single video frame using the one-shot learned prompt model.
     */
    post: operations["GetPromptPrediction"];
  };
  "/organizations/{organization_id}/workspaces/{workspace_id}/jobs": {
    /**
     * Get info on all jobs
     * @description Get info on all jobs, running and completed.
     */
    get: operations["GetJobs"];
  };
  "/organizations/{organization_id}/workspaces/{workspace_id}/jobs/{job_id}": {
    /**
     * Get info on a job
     * @description Get information on a running or completed job.
     */
    get: operations["GetJob"];
    /**
     * Delete a job
     * @description Mark a job as cancelled with a deletion flag
     */
    delete: operations["DeleteJob"];
  };
  "/organizations/{organization_id}/workspaces/{workspace_id}/jobs/{job_id}:cancel": {
    /** Cancel a job */
    post: operations["CancelJob"];
  };
  "/status": {
    /**
     * Get server status
     * @description Get the server status. Contains running jobs count, free disk space and used disk space in bytes.
     */
    get: operations["GetServerStatus"];
  };
  "/organizations/{organization_id}/workspaces/{workspace_id}/projects/{project_id}/status": {
    /**
     * Get project status
     * @description Get the status of a project. Includes project score, number of required annotations and current state, for the project and on a per-task basis.
     */
    get: operations["GetProjectStatus"];
  };
  "/organizations/{organization_id}/workspaces/{workspace_id}/projects/{project_id}/incremental_learning_status": {
    /**
     * Get incremental learning status
     * @description Get the incremental learning status of a project. This contains information on the number of annotations that need to be added before training will be started, on a per-label and per-task basis.
     */
    get: operations["GetIncrementalLearningStatus"];
  };
  "/organizations/{organization_id}/status": {
    /**
     * Get server status for organization
     * @description Get the server status for a given organization. Contains running jobs count, free disk space and used disk space in bytes.
     */
    get: operations["GetOrganizationStatus"];
  };
  "/organizations/{organization_id}/workspaces/{workspace_id}/projects/{project_id}/configuration": {
    /**
     * Get the current configuration for all components in the project.
     * @description This endpoint gets the configuration for all components in the project, as well as the current algorithms used in the task chain. The configuration is subdivided into components. Examples of configuration components are the deep learning parameters, postprocessing parameters or subset-related parameters. Some components are further divided into parameter groups.
     */
    get: operations["GetFullConfiguration"];
    /**
     * Set the full configuration for the project.
     * @description This endpoint sets the configuration for all components in the project, as well as the current algorithms used in the task chain. The configuration is subdivided into components, and every component is divided into parameter groups.
     */
    post: operations["SetFullConfiguration"];
  };
  "/organizations/{organization_id}/workspaces/{workspace_id}/projects/{project_id}/configuration/global": {
    /**
     * Get the current configuration for all components in the project.
     * @description This endpoint gets the configuration for all components in the project that are acting project-wide. The configuration is subdivided into components. Examples of configuration components are the active learning parameters or dataset management related parameters. Some components are further divided into parameter groups.
     */
    get: operations["GetGlobalConfiguration"];
    /**
     * Set the configuration for all components in the project.
     * @description This endpoint sets the configuration for all components in the project that are acting globally, i.e. project-wide. The configuration is subdivided into components, and every component is divided into parameter groups.
     */
    post: operations["SetGlobalConfiguration"];
  };
  "/organizations/{organization_id}/workspaces/{workspace_id}/projects/{project_id}/configuration/task_chain": {
    /**
     * Get the current configuration for all tasks in the project's task chain.
     * @description This endpoint pulls the configuration for all tasks in the project. For every task in the project, the configuration is subdivided into components. Examples of configuration components are the deep learning parameters, postprocessing parameters or subset-related parameters. Some components are further divided into parameter groups.
     */
    get: operations["GetTaskChainConfiguration"];
    /**
     * Set the configuration for all tasks in the projects' task chain.
     * @description This endpoint sets the configuration for the entire task chain. For every task in the chain, the configuration is subdivided into components, and every component is divided into parameter groups.
     */
    post: operations["SetTaskChainConfiguration"];
  };
  "/organizations/{organization_id}/workspaces/{workspace_id}/projects/{project_id}/configuration/task_chain/{task_id}": {
    /**
     * Get the current configuration for a specific task
     * @description This endpoint pulls the configuration for a specific task. The configuration is subdivided into components, and every component is divided into parameter groups. This endpoint can also be used to pull the configurable parameters related to a single model or an algorithm, from a trainable task.
     */
    get: operations["GetTaskConfiguration"];
    /**
     * Set the configuration for a specific task.
     * @description This endpoint sets the configuration for a specific task. The configuration is subdivided into components, and every component is divided into parameter groups.
     */
    post: operations["SetTaskConfiguration"];
  };
  "/user_settings": {
    /**
     * Get the users' settings for a project or for the entire system
     * @description Get the users' settings for a project or the entire system. If project_id query parameter is not specified, the settings for the entire system are returned.
     */
    get: operations["GetSettings"];
    /**
     * Set the users' settings for a project or for the entire system.
     * @description Set the users' settings for a project or for the entire system. If project_id query parameter is not specified, the settings for the entire system are set.
     */
    post: operations["SetSettings"];
  };
  "/organizations/{organization_id}/workspaces/{workspace_id}/projects/{project_id}/settings/annotation_templates": {
    /**
     * Get all annotation templates of a project
     * @description Get a complete list of annotation templates which belong to the project.
     */
    get: operations["GetAnnotationTemplates"];
    /**
     * Create an Annotation Template
     * @description Create an annotation template.
     */
    post: operations["CreateAnnotationTemplate"];
  };
  "/product_info": {
    /**
     * Get information about the product
     * @description Get information regarding product version.
     */
    get: operations["GetProductInfo"];
  };
  "/organizations/{organization_id}/workspaces/{workspace_id}/datasets/uploads": {
    /**
     * Upload a dataset archive
     * @description Upload a dataset archive to the server.
     *
     * This endpoint allows clients to upload a dataset archive directly to the server without using the TUS protocol.
     */
    post: operations["DatasetImportUploadFile"];
  };
  "/organizations/{organization_id}/workspaces/{workspace_id}/datasets/uploads/resumable": {
    /**
     * Start uploading a dataset archive using TUS
     * @description Initiate a new TUS session to upload a dataset archive.
     *
     * This endpoint creates a new upload resource on the server according to the TUS protocol (https://tus.io/protocols/resumable-upload.html).
     * The client provides metadata such as file size and name in the request headers, and the server responds with a location URL for the newly created resource.
     * This URL is used for subsequent upload operations (e.g., PATCH, HEAD).
     */
    post: operations["CreateTusDatasetUpload"];
    /**
     * Retrieve server capabilities for TUS uploads
     * @description Get information about the TUS protocol versions and extensions supported by the server.
     * This endpoint allows clients to dynamically adapt their behavior based on server capabilities.
     */
    options: operations["TusDatasetUploadOptions"];
  };
  "/organizations/{organization_id}/workspaces/{workspace_id}/datasets/uploads/resumable/{file_id}": {
    /**
     * Cancel a TUS upload of a dataset archive
     * @description Cancel the TUS upload of a dataset archive, removing the uploaded data from the server.
     *
     * This endpoint allows the client to cancel the upload operation and remove the uploaded data from the server.
     * It is useful for cleaning up incomplete uploads.
     */
    delete: operations["TusDatasetUploadDelete"];
    /**
     * Get the status of a dataset archive TUS upload
     * @description Retrieve the current status of the TUS upload of a dataset archive.
     *
     * This endpoint provides information such as the current offset of uploaded data through the `Upload-Offset` header,
     * allowing the client to resume uploads from the correct position.
     * It is useful for verifying progress or ensuring consistency before appending further data.
     */
    head: operations["TusDatasetUploadHead"];
    /**
     * Append data to a running TUS upload of a dataset archive
     * @description Upload a chunk of the dataset archive data to the server, appending it to the TUS upload at the specified offset.
     *
     * This endpoint allows the client to resume uploading data with TUS by sending the remaining data from the last known offset.
     * It is recommended to choose a large chunk size (based on server limitations) to speed up the overall upload operation.
     */
    patch: operations["TusDatasetUploadPatch"];
  };
  "/organizations/{organization_id}/workspaces/{workspace_id}/datasets:prepare-for-import": {
    /**
     * Prepare a dataset to be imported as a new project
     * @description Analyze an uploaded dataset archive file and prepare it to be imported as a new project.
     *
     * This endpoint submits a job to prepare the dataset for import. Specifically, the job scans the dataset
     * to determine the compatible task types and to identify potential issues in the data.
     * The status of this operation can be monitored in real-time through the [job status endpoint](#Jobs/GetJob);
     * once the job is finished, the list of compatible task types, labels and warnings can be found in the job metadata.
     */
    post: operations["PrepareDatasetForImport"];
  };
  "/organizations/{organization_id}/workspaces/{workspace_id}/projects:import-from-dataset": {
    /**
     * Create a new project from a prepared dataset
     * @description Finalize the creation of a new project from an imported dataset, that has been previously uploaded and prepared.
     *
     * This endpoint submits a job to create a new project with a given project name, task type and labels, that will also
     * contain all the media and annotations from the imported dataset.
     * The status of this operation can be monitored in real-time through the [job status endpoint](#Jobs/GetJob);
     * once the job is finished, the id of the created project can be found in the job metadata.
     */
    post: operations["ImportProjectFromDataset"];
  };
  "/organizations/{organization_id}/workspaces/{workspace_id}/projects/{project_id}/datasets:prepare-for-import": {
    /**
     * Prepare a dataset to be imported into an already existing project
     * @description Analyze an uploaded dataset archive file and prepare it to be imported into an existing project.
     *
     * This endpoint submits a job to prepare the dataset for import. Specifically, the job scans the dataset
     * to assess the compatibility with the target project and to identify potential issues in the data.
     * The status of this operation can be monitored in real-time through the [job status endpoint](#Jobs/GetJob);
     * once the job is finished, the list of parsed labels and warnings can be found in the job metadata.
     */
    post: operations["PrepareDatasetForImportToProject"];
  };
  "/organizations/{organization_id}/workspaces/{workspace_id}/projects/{project_id}:import-from-dataset": {
    /**
     * Import a prepared dataset into an existing project
     * @description Finalize the import of an already prepared dataset into an existing project.
     *
     * This endpoint submits a job to import the dataset, including all its media and annotations from the imported dataset.
     * The status of this operation can be monitored in real-time through the [job status endpoint](#Jobs/GetJob);
     * once the job is finished, the id of the created project can be found in the job metadata.
     *
     * Within the project, the data may be imported into an existing dataset or a new dataset, depending on the request body:
     * - If one specifies a `dataset_id`, then the target will be that dataset
     * - If one specifies a `dataset_name`, then a new dataset will be created with that name
     *
     * The `labels_map` allows the user to map the labels found in the prepared dataset to the labels of the target project.
     */
    post: operations["ImportDatasetToProject"];
  };
  "/organizations/{organization_id}/workspaces/{workspace_id}/projects/{project_id}/datasets/{dataset_id}:prepare-for-export": {
    /**
     * Export a dataset as an archive
     * @description Export a dataset as a zip archive file, including all the media and the respective annotations.
     *
     * This endpoint submits a job to export the dataset.
     * The status of the export operation can be monitored in real-time through the [job status endpoint](#Jobs/GetJob);
     * after it completes, the URL to download the exported zip archive can be found in the job metadata.
     *
     * The downloaded dataset archive can be later imported as a new project, or merged into an existing dataset of compatible type.
     */
    post: operations["TriggerDatasetExport"];
  };
  "/organizations/{organization_id}/workspaces/{workspace_id}/projects/{project_id}/datasets/{dataset_id}/exports/{export_dataset_id}/download": {
    /**
     * Download an exported dataset archive
     * @description Download a dataset exported as a zip file.
     */
    get: operations["DownloadExportedDataset"];
  };
  "/organizations/{organization_id}/workspaces/{workspace_id}/projects/uploads/resumable": {
    /**
     * Start uploading a project archive using TUS
     * @description Initiate a new TUS session to upload a project archive.
     *
     * This endpoint creates a new upload resource on the server according to the TUS protocol (https://tus.io/protocols/resumable-upload.html).
     * The client provides metadata such as file size and name in the request headers, and the server responds with a location URL for the newly created resource.
     * This URL is used for subsequent upload operations (e.g., PATCH, HEAD).
     */
    post: operations["CreateTusProjectUpload"];
    /**
     * Retrieve server capabilities for TUS uploads
     * @description Get information about the TUS protocol versions and extensions supported by the server.
     * This endpoint allows clients to dynamically adapt their behavior based on server capabilities.
     */
    options: operations["TusProjectUploadOptions"];
  };
  "/organizations/{organization_id}/workspaces/{workspace_id}/projects/uploads/resumable/{file_id}": {
    /**
     * Get the status of a project archive TUS upload
     * @description Retrieve the current status of the TUS upload of a project archive.
     *
     * This endpoint provides information such as the current offset of uploaded data through the `Upload-Offset` header,
     * allowing the client to resume uploads from the correct position.
     * It is useful for verifying progress or ensuring consistency before appending further data.
     */
    head: operations["TusProjectUploadHead"];
    /**
     * Append data to a running TUS upload of a project archive
     * @description Upload a chunk of the project archive data to the server, appending it to the TUS upload at the specified offset.
     *
     * This endpoint allows the client to resume uploading data with TUS by sending the remaining data from the last known offset.
     * It is recommended to choose a large chunk size (based on server limitations) to speed up the overall upload operation.
     */
    patch: operations["TusProjectUploadPatch"];
  };
  "/organizations/{organization_id}/workspaces/{workspace_id}/projects/{project_id}:export": {
    /**
     * Export a project as an archive
     * @description Export a project as a zip archive file, containing all the project data (including datasets and models).
     *
     * This endpoint submits a job to export a project.
     * The status of the export operation can be monitored in real-time through the [job status endpoint](#Jobs/GetJob);
     * after it completes, the URL to download the exported zip archive can be found in the job metadata.
     *
     * The downloaded project archive can be later imported using the [import project endpoint](#Project%20Import%2FExport/ImportProject).
     */
    post: operations["TriggerProjectExport"];
  };
  "/organizations/{organization_id}/workspaces/{workspace_id}/projects/{project_id}/exports/{export_operation_id}/download": {
    /**
     * Download an exported project archive
     * @description Download a project archive exported as a zip file.
     */
    get: operations["DownloadExportedProject"];
  };
  "/organizations/{organization_id}/workspaces/{workspace_id}/projects:import": {
    /**
     * Import a project from an uploaded archive
     * @description Create a project by importing a project archive file.
     *
     * The project archive file must be first uploaded using the TUS protocol,
     * by means of the [TUS upload endpoints](#Project%20Import%2FExport/CreateTusProjectUpload).
     *
     * This endpoint submits a job to import a project from the uploaded archive.
     * The status of the import operation can be monitored in real-time through the [job status endpoint](#Jobs/GetJob);
     * after it completes, the id of the imported project can be found in the job metadata.
     */
    post: operations["ImportProject"];
  };
  "/organizations/{organization_id}/workspaces/{workspace_id}/projects/{project_id}/code_deployments:prepare": {
    /**
     * Prepare code deployment for project
     * @deprecated
     * @description This endpoint triggers preparation for code deployment for a specific project. For single-task projects (Detection, Segmentation, etc), it will export the only model used. For task-chain projects, it will export all the models. Only models in OpenVINO IR format are supported.
     * This endpoint is deprecated. Use the [deployment package endpoint](../deployment_package/download_deployment_package_endpoint.yaml) to prepare and download code deployment.
     */
    post: operations["PrepareCodeDeployment"];
  };
  "/organizations/{organization_id}/workspaces/{workspace_id}/projects/{project_id}/code_deployments/{deployment_id}": {
    /**
     * Get details of a code deployment process
     * @description Get details for the code deployment process, which includes the state, the progress, models, the creator id and creation time.
     */
    get: operations["GetCodeDeployment"];
  };
  "/organizations/{organization_id}/workspaces/{workspace_id}/projects/{project_id}/code_deployments/{deployment_id}/download": {
    /**
     * Download the deployed code as a zip file
     * @deprecated
     * @description Download the deployed code as a zip file. This endpoint is deprecated. Use the [deployment package endpoint](../deployment_package/download_deployment_package_endpoint.yaml) to prepare and download code deployment.
     */
    get: operations["DownloadCodeDeployment"];
  };
  "/organizations/{organization_id}/workspaces/{workspace_id}/projects/{project_id}/deployment_package:download": {
    /**
     * Download the deployment package as a zip file
     * @description Download the deployment package as a zip file, e.g. an archive containing trained model files and graphs for deploying model on OpenVino Model Server or locally using the Geti SDK.
     */
    post: operations["DownloadDeploymentPackage"];
  };
  "/organizations/{organization_id}/balance": {
    /**
     * [SaaS] Get running credits balance
     * @description <i>Not available on on-premises environments.</i><br><br> The running credit balance of an organization is calculated during the current subscription cycle, and consists of 3 values:<br>
     *   1) incoming - credits, allocated to the organization at the start of the subscription cycle;<br>
     *   2) blocked - credits, temporary reserved for the training or optimization jobs in progress;<br>
     *   3) available - credits, which are available for usage.
     */
    get: operations["get_balance_api_v1_organizations__organization_id__balance_get"];
  };
  "/organizations/{organization_id}/credit_accounts": {
    /**
     * [SaaS] Get credit accounts
     * @description <i>Not available on on-premises environments.</i><br><br> Returns active (not expired) credit accounts of the organization.
     */
    get: operations["get_credit_accounts_api_v1_organizations__organization_id__credit_accounts_get"];
  };
  "/organizations/{organization_id}/subscriptions/active": {
    /**
     * [SaaS] Get the active subscription
     * @description <i>Not available on on-premises environments.</i><br><br> Information about the organization's active subscription.
     */
    get: operations["get_active_subscription_api_v1_organizations__organization_id__subscriptions_active_get"];
  };
  "/organizations/{organization_id}/transactions": {
    /**
     * [SaaS] Get transactions information
     * @description <i>Not available on on-premises environments.</i><br><br> Returns information about finished transactions within specified time range [from_date, to_date].<br> Supports sorting and filtering by project name and usage type.
     */
    get: operations["get_transactions_api_v1_organizations__organization_id__transactions_get"];
  };
  "/organizations/{organization_id}/transactions/aggregates": {
    /**
     * [SaaS] Get credit consumption aggregates
     * @description <i>Not available on on-premises environments.</i><br><br> The aggregating endpoint allows to retrieve credit consumption grouped by various dimensions - such as project, date, usage type, etc.
     */
    get: operations["get_credit_consumption_aggregates_api_v1_organizations__organization_id__transactions_aggregates_get"];
  };
}

export type webhooks = Record<string, never>;

export interface components {
  schemas: {
    ListUsersResponseNextPage: {
      /** Format: int32 */
      skip?: number;
      /** Format: int32 */
      limit?: number;
    };
    commonPreUrlResponse: {
      presignedUrl?: string;
    };
    rpcStatus: {
      /** Format: int32 */
      code?: number;
      message?: string;
      details?: unknown[];
    };
    userListUsersResponse: {
      users?: components["schemas"]["user_commonUserData"][];
      /** Format: int32 */
      totalCount?: number;
      /** Format: int32 */
      totalMatchedCount?: number;
      nextPage?: components["schemas"]["ListUsersResponseNextPage"];
    };
    userUserIdRequest: {
      userId?: string;
      organizationId?: string;
    };
    userUserInvitationResponse: {
      userId?: string;
    };
    userUserProfileData: {
      status?: string;
      organizationId?: string;
      telemetryConsent?: string;
      /** Format: date-time */
      telemetryConsentAt?: string;
      userConsent?: string;
      /** Format: date-time */
      userConsentAt?: string;
    };
    userUserRolesResponse: {
      roles?: components["schemas"]["user_commonUserRole"][];
    };
    user_commonUserData: {
      id?: string;
      firstName?: string;
      secondName?: string;
      email?: string;
      externalId?: string;
      country?: string;
      status?: string;
      organizationId?: string;
      organizationStatus?: string;
      roles?: components["schemas"]["user_commonUserRole"][];
      /** Format: date-time */
      lastSuccessfulLogin?: string;
      /** Format: date-time */
      createdAt?: string;
      createdBy?: string;
      /** Format: date-time */
      modifiedAt?: string;
      modifiedBy?: string;
      telemetryConsent?: string;
      /** Format: date-time */
      telemetryConsentAt?: string;
      userConsent?: string;
      /** Format: date-time */
      userConsentAt?: string;
      presignedUrl?: string;
    };
    user_commonUserRole: {
      role?: string;
      resourceType?: string;
      resourceId?: string;
    };
    user_commonUserRoleOperation: {
      role?: components["schemas"]["user_commonUserRole"];
      /** CREATE, DELETE, TOUCH */
      operation?: string;
    };
    ListOrganizationsResponseNextPage: {
      /** Format: int32 */
      skip?: number;
      /** Format: int32 */
      limit?: number;
    };
    organizationListOrganizationsResponse: {
      organizations?: components["schemas"]["organizationOrganizationData"][];
      /** Format: int32 */
      totalCount?: number;
      /** Format: int32 */
      totalMatchedCount?: number;
      nextPage?: components["schemas"]["ListOrganizationsResponseNextPage"];
    };
    organizationOrganizationData: {
      id?: string;
      name?: string;
      country?: string;
      location?: string;
      type?: string;
      cellId?: string;
      status?: string;
      /** Format: date-time */
      createdAt?: string;
      createdBy?: string;
      /** Format: date-time */
      modifiedAt?: string;
      modifiedBy?: string;
    };
    organizationOrganizationIdRequest: {
      id?: string;
    };
    organizationOrganizationInvitiationRequest: {
      organizationData?: components["schemas"]["organizationOrganizationData"];
      adminData?: components["schemas"]["user_commonUserData"];
    };
    ListWorkspacesResponseNextPage: {
      /** Format: int32 */
      skip?: number;
      /** Format: int32 */
      limit?: number;
    };
    workspaceListWorkspacesResponse: {
      workspaces?: components["schemas"]["workspaceWorkspaceData"][];
      /** Format: int32 */
      totalCount?: number;
      /** Format: int32 */
      totalMatchedCount?: number;
      nextPage?: components["schemas"]["ListWorkspacesResponseNextPage"];
    };
    workspaceWorkspaceData: {
      id?: string;
      name?: string;
      organizationId?: string;
      /** Format: date-time */
      createdAt?: string;
      createdBy?: string;
      /** Format: date-time */
      modifiedAt?: string;
      modifiedBy?: string;
    };
    user_statusUserStatusResponse: {
      id?: string;
      status?: string;
      organizationId?: string;
      userId?: string;
      createdBy?: string;
      /** Format: date-time */
      createdAt?: string;
    };
    /**
     * AccessResourceType
     * @description Available resources for SpiceDB relations
     * @enum {string}
     */
    AccessResourceType: "project" | "workspace" | "user_directory";
    /**
     * AccessTokenOutputModel
     * @example {
     *   "access_token": "JSON Web Token value",
     *   "token_type": "bearer",
     *   "expires_in": 899
     * }
     */
    AccessTokenOutputModel: {
      /** Access Token */
      access_token: string;
      /** Expires At */
      expires_at: number;
      /** Token Type */
      token_type: string;
    };
    /** Body_upload_user_photo_users__user_id__photo_post */
    Body_upload_user_photo_users__user_id__photo_post: {
      /**
       * Photo File
       * Format: binary
       */
      photo_file: string;
    };
    /**
     * ConfirmRegistrationData
     * @description Stores data for confirmation of the user registration
     */
    ConfirmRegistrationData: {
      /** Token */
      token: string;
      /** Password */
      password: string;
    };
    /**
     * CreateServiceUserData
     * @example {
     *   "expiration_date": "2044-12-31T21:22:23"
     * }
     */
    CreateServiceUserData: {
      /** Expiration Date */
      expiration_date: string;
    };
    /** CreateUserData */
    CreateUserData: {
      /** Uid */
      uid: string;
      /** Name */
      name: string;
      /** Mail */
      mail: string;
      /** Password */
      password: string;
      /** Roles */
      roles: components["schemas"]["RoleModel"][];
    };
    /** HTTPValidationError */
    HTTPValidationError: {
      /** Error message */
      msg?: string;
      /**
       * Error code
       * @default 422
       */
      code?: number;
      /** Detail */
      detail?: components["schemas"]["ValidationError"][];
    };
    /** InviteData */
    InviteData: {
      /** Mail */
      mail: string;
      /** Roles */
      roles: components["schemas"]["RoleModel"][];
    };
    /**
     * LoginData
     * @description Stores data about user login credentials
     */
    LoginData: {
      /** Login */
      login: string;
      /** Password */
      password: string;
    };
    /**
     * PasswordRequestResetData
     * @description Stores email on which new password will be sent
     */
    PasswordRequestResetData: {
      /** Email */
      email: string;
    };
    /**
     * PasswordResetData
     * @description Stores user's new password and token
     */
    PasswordResetData: {
      /** New Password */
      new_password: string;
      /** Token */
      token: string;
    };
    /** PasswordUpdateData */
    PasswordUpdateData: {
      /** New Password */
      new_password: string;
      /** Old Password */
      old_password: string;
    };
    /**
     * RefreshServiceUserData
     * @example {
     *   "expiration_date": "2044-12-31T21:22:23"
     * }
     */
    RefreshServiceUserData: {
      /** Expiration Date */
      expiration_date: string;
    };
    /**
     * RoleMapping
     * @example {
     *   "role": "admin",
     *   "resource_type": "workspace",
     *   "resource_id": "fooBarBaz"
     * }
     */
    RoleMapping: {
      /** Role */
      role: string;
      resource_type: components["schemas"]["AccessResourceType"];
      /** Resource Id */
      resource_id: string;
    };
    /**
     * RoleModel
     * @description Represents user role model.
     */
    RoleModel: {
      /** Resource Id */
      resource_id: string;
      resource_type: components["schemas"]["AccessResourceType"];
      role: components["schemas"]["UserRoles"];
    };
    /** RolePatch */
    RolePatch: {
      role: components["schemas"]["SpiceDBResourceUserRoles"];
      resource_type: components["schemas"]["AccessResourceType"];
      /** Resource Id */
      resource_id: string;
      /**
       * Operation
       * @enum {string}
       */
      operation: "TOUCH" | "DELETE";
    };
    /** RolesOutputModel */
    RolesOutputModel: {
      /** Roles */
      roles: components["schemas"]["RoleMapping"][];
    };
    /** RolesPatchModel */
    RolesPatchModel: {
      /** Roles */
      roles: components["schemas"]["RolePatch"][];
    };
    /**
     * ServiceAccountOutputModel
     * @example {
     *   "expiration_date": "2044-12-31T21:22:23"
     * }
     */
    ServiceAccountOutputModel: {
      /** Expiration Date */
      expiration_date: string;
    };
    /**
     * ServiceAccountWithPasswordOutputModel
     * @example {
     *   "expiration_date": "2044-12-31T21:22:23",
     *   "service_id": "32-alpha-numeric-characters:32-alpha-numeric-characters"
     * }
     */
    ServiceAccountWithPasswordOutputModel: {
      /** Service Id */
      service_id: string;
      /** Expiration Date */
      expiration_date: string;
    };
    /**
     * ServiceIdData
     * @example {
     *   "service_id": "32-alpha-numeric-characters:32-alpha-numeric-characters"
     * }
     */
    ServiceIdData: {
      /** Service Id */
      service_id: string;
    };
    /**
     * SpiceDBResourceUserRoles
     * @description Available resources user roles for use in SpiceDB
     * @enum {string}
     */
    SpiceDBResourceUserRoles: "admin" | "contributor";
    /** UserModel */
    UserModel: {
      /** Uid */
      uid: string;
      /** Name */
      name: string;
      /** Mail */
      mail: string;
      /** Registered */
      registered: boolean;
      /** Roles */
      roles?: components["schemas"]["UserRole"][];
      /** User Photo */
      user_photo?: string;
    };
    /** UserRole */
    UserRole: {
      /** Role */
      role: string;
      resource_type: components["schemas"]["AccessResourceType"];
      /** Resource Id */
      resource_id: string;
    };
    /**
     * UserRoles
     * @description Enum with roles that can be assigned to a user.
     * @enum {string}
     */
    UserRoles: "ADMIN" | "CONTRIBUTOR";
    /** ValidationError */
    ValidationError: {
      /** Location */
      loc: (string | number)[];
      /** Message */
      msg: string;
      /** Error Type */
      type: string;
    };
    /** AggregateItem */
    AggregateItem: {
      /** Group */
      group: components["schemas"]["GroupItem"][];
      result: components["schemas"]["AggregatesResult"];
    };
    /**
     * AggregatesKey
     * @description Allowed keys for transaction aggregates
     * @enum {string}
     */
    AggregatesKey: "project" | "service_name" | "date";
    /** AggregatesResponse */
    AggregatesResponse: {
      /** Aggregates */
      aggregates: components["schemas"]["AggregateItem"][];
    };
    /** AggregatesResult */
    AggregatesResult: {
      /** Credits */
      credits: number;
      resources: components["schemas"]["ResourcesAmount"];
    };
    /** BalancePayload */
    BalancePayload: {
      /** Add */
      add?: number | null;
      /** Subtract */
      subtract?: number | null;
    };
    /** BalanceResponse */
    BalanceResponse: {
      /** Incoming */
      incoming: number;
      /** Available */
      available: number;
    };
    /** CreditAccount */
    CreditAccount: {
      /** Id */
      id: number;
      /** Organization Id */
      organization_id: string;
      /** Name */
      name: string;
      /** Renewable Amount */
      renewable_amount?: number | null;
      /** Renewal Day Of Month */
      renewal_day_of_month?: number | null;
      /** Created */
      created: number;
      /** Updated */
      updated: number;
      /** Expires */
      expires?: number | null;
      balance: components["schemas"]["BalanceResponse"];
    };
    /** CreditAccountPostPayload */
    CreditAccountPostPayload: {
      /** Name */
      name: string;
      /** Init Amount */
      init_amount: number;
      /** Renewable Amount */
      renewable_amount?: number | null;
      /** Renewal Day Of Month */
      renewal_day_of_month?: number | null;
      /** Expires */
      expires?: number | null;
    };
    /** CreditAccountPutPayload */
    CreditAccountPutPayload: {
      /** Name */
      name: string;
      /** Renewable Amount */
      renewable_amount?: number | null;
      /** Expires */
      expires?: number | null;
    };
    /** CreditAccountsResponse */
    CreditAccountsResponse: {
      /** Total Matched */
      total_matched: number;
      next_page: components["schemas"]["NextPage"] | null;
      /** Credit Accounts */
      credit_accounts: components["schemas"]["CreditAccount"][];
    };
    /** GroupItem */
    GroupItem: {
      /** Key */
      key: string;
      /** Value */
      value: string | number;
    };
    /** ListProductResponse */
    ListProductResponse: {
      /** Total Matched */
      total_matched: number;
      next_page: components["schemas"]["NextPage"] | null;
      /** Products */
      products: components["schemas"]["Product"][];
    };
    /** NextPage */
    NextPage: {
      /** Limit */
      limit: number;
      /** Skip */
      skip: number;
    };
    /** Product */
    Product: {
      /** Id */
      id: number;
      /** Name */
      name: string;
      /** Product Policies */
      product_policies: components["schemas"]["ProductPolicy"][];
      /** Created */
      created: number;
      /** Updated */
      updated: number;
    };
    /** ProductPolicy */
    ProductPolicy: {
      /** Account Name */
      account_name: string;
      /** Init Amount */
      init_amount: number;
      /** Renewable Amount */
      renewable_amount?: number | null;
      /** Expires In */
      expires_in?: number | null;
    };
    /** ResourcesAmount */
    ResourcesAmount: {
      /**
       * Images
       * @default 0
       */
      images?: number;
      /**
       * Frames
       * @default 0
       */
      frames?: number;
    };
    /** SubscriptionPayload */
    SubscriptionPayload: {
      /** Product Id */
      product_id: number;
      /** @default active */
      status?: components["schemas"]["SubscriptionStatus"];
    };
    /** SubscriptionResponse */
    SubscriptionResponse: {
      /** Id */
      id: number;
      /** Organization Id */
      organization_id: string;
      /** Product Id */
      product_id: number;
      /** Renewal Day Of Month */
      renewal_day_of_month: number;
      /** Status */
      status: string;
      /** Created */
      created: number;
      /** Updated */
      updated: number;
    };
    /**
     * SubscriptionStatus
     * @description Possible organization's subscription states
     * @enum {string}
     */
    SubscriptionStatus: "new" | "active" | "cancelled";
    /** TransactionInfo */
    TransactionInfo: {
      /** Credits */
      credits: number;
      /** Workspace Id */
      workspace_id: string;
      /** Project Id */
      project_id: string;
      /** Service Name */
      service_name: string;
      /** Milliseconds Timestamp */
      milliseconds_timestamp: number;
    };
    /** TransactionsResponse */
    TransactionsResponse: {
      /** Total Matched */
      total_matched: number;
      next_page: components["schemas"]["NextPage"] | null;
      /** Transactions */
      transactions: components["schemas"]["TransactionInfo"][];
    };
  };
  responses: never;
  parameters: never;
  requestBodies: never;
  headers: never;
  pathItems: never;
}

export type $defs = Record<string, never>;

export type external = Record<string, never>;

export interface operations {

  /** GET /organizations/users/{external_id} */
  User_get_by_external_id: {
    parameters: {
      query?: {
        id?: string;
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "application/json": components["schemas"]["user_commonUserData"];
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "application/json": components["schemas"]["rpcStatus"];
        };
      };
    };
  };
  /** GET /organizations/{organization_id}/users/active */
  User_get_active_user: {
    parameters: {
      query?: {
        userId?: string;
      };
      path: {
        organizationId: string;
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "application/json": components["schemas"]["user_commonUserData"];
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "application/json": components["schemas"]["rpcStatus"];
        };
      };
    };
  };
  /** GET /organizations/{organization_id}/users  - conditions passed in the query string */
  User_find: {
    parameters: {
      query?: {
        firstName?: string;
        secondName?: string;
        email?: string;
        externalId?: string;
        country?: string;
        status?: string;
        lastSuccessfulLoginFrom?: string;
        lastSuccessfulLoginTo?: string;
        role?: string;
        resourceType?: string;
        resourceId?: string;
        workspaceId?: string;
        createdAtFrom?: string;
        createdAtTo?: string;
        createdBy?: string;
        modifiedAtFrom?: string;
        modifiedAtTo?: string;
        modifiedBy?: string;
        skip?: number;
        limit?: number;
        /** @description attribute name */
        sortBy?: string;
        /** @description asc/desc */
        sortDirection?: string;
        /** @description user to search for first name OR second name OR email */
        name?: string;
      };
      path: {
        organizationId: string;
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "application/json": components["schemas"]["userListUsersResponse"];
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "application/json": components["schemas"]["rpcStatus"];
        };
      };
    };
  };
  /** POST /organizations/{organization_id}/users */
  User_create: {
    parameters: {
      path: {
        organizationId: string;
      };
    };
    requestBody: {
      content: {
        "application/json": {
          id?: string;
          firstName?: string;
          secondName?: string;
          email?: string;
          externalId?: string;
          country?: string;
          status?: string;
          organizationStatus?: string;
          roles?: components["schemas"]["user_commonUserRole"][];
          /** Format: date-time */
          lastSuccessfulLogin?: string;
          /** Format: date-time */
          createdAt?: string;
          createdBy?: string;
          /** Format: date-time */
          modifiedAt?: string;
          modifiedBy?: string;
          telemetryConsent?: string;
          /** Format: date-time */
          telemetryConsentAt?: string;
          userConsent?: string;
          /** Format: date-time */
          userConsentAt?: string;
          presignedUrl?: string;
        };
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "application/json": components["schemas"]["user_commonUserData"];
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "application/json": components["schemas"]["rpcStatus"];
        };
      };
    };
  };
  /** PUT /organizations/{organization_id}/users/{id} */
  User_modify: {
    parameters: {
      path: {
        organizationId: string;
        id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": {
          firstName?: string;
          secondName?: string;
          email?: string;
          externalId?: string;
          country?: string;
          status?: string;
          organizationStatus?: string;
          roles?: components["schemas"]["user_commonUserRole"][];
          /** Format: date-time */
          lastSuccessfulLogin?: string;
          /** Format: date-time */
          createdAt?: string;
          createdBy?: string;
          /** Format: date-time */
          modifiedAt?: string;
          modifiedBy?: string;
          telemetryConsent?: string;
          /** Format: date-time */
          telemetryConsentAt?: string;
          userConsent?: string;
          /** Format: date-time */
          userConsentAt?: string;
          presignedUrl?: string;
        };
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "application/json": components["schemas"]["user_commonUserData"];
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "application/json": components["schemas"]["rpcStatus"];
        };
      };
    };
  };
  /** GET /organizations/{organization_id}/users/{id} */
  User_get_by_id: {
    parameters: {
      path: {
        organizationId: string;
        userId: string;
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "application/json": components["schemas"]["user_commonUserData"];
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "application/json": components["schemas"]["rpcStatus"];
        };
      };
    };
  };
  /** DELETE /organizations/{organization_id}/users/{id} */
  User_delete: {
    parameters: {
      path: {
        organizationId: string;
        userId: string;
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "application/json": Record<string, never>;
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "application/json": components["schemas"]["rpcStatus"];
        };
      };
    };
  };
  /** GET /organizations/{organization_id}/users/{id}/photos */
  User_get_photo: {
    parameters: {
      path: {
        organizationId: string;
        userId: string;
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "application/json": components["schemas"]["commonPreUrlResponse"];
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "application/json": components["schemas"]["rpcStatus"];
        };
      };
    };
  };
  /** DELETE /organization/{organization_id}/users/{id}/photos */
  User_delete_photo: {
    parameters: {
      path: {
        organizationId: string;
        userId: string;
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "application/json": Record<string, never>;
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "application/json": components["schemas"]["rpcStatus"];
        };
      };
    };
  };
  /** PUT /organizations/{organization_id}/users/{id}/roles */
  User_set_roles: {
    parameters: {
      path: {
        organizationId: string;
        userId: string;
      };
    };
    requestBody: {
      content: {
        "application/json": {
          roles?: components["schemas"]["user_commonUserRoleOperation"][];
        };
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "application/json": Record<string, never>;
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "application/json": components["schemas"]["rpcStatus"];
        };
      };
    };
  };
  /** GET /organizations/{organization_id}/users/{id}/roles/{resource_type} */
  User_get_roles: {
    parameters: {
      path: {
        organizationId: string;
        userId: string;
        resourceType: string;
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "application/json": components["schemas"]["userUserRolesResponse"];
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "application/json": components["schemas"]["rpcStatus"];
        };
      };
    };
  };
  /** POST /organizations/{organization_id}/users/invitations */
  User_send_invitation: {
    parameters: {
      path: {
        "user.organizationId": string;
      };
    };
    requestBody: {
      content: {
        "application/json": {
          user?: {
            id?: string;
            firstName?: string;
            secondName?: string;
            email?: string;
            externalId?: string;
            country?: string;
            status?: string;
            organizationStatus?: string;
            roles?: components["schemas"]["user_commonUserRole"][];
            /** Format: date-time */
            lastSuccessfulLogin?: string;
            /** Format: date-time */
            createdAt?: string;
            createdBy?: string;
            /** Format: date-time */
            modifiedAt?: string;
            modifiedBy?: string;
            telemetryConsent?: string;
            /** Format: date-time */
            telemetryConsentAt?: string;
            userConsent?: string;
            /** Format: date-time */
            userConsentAt?: string;
            presignedUrl?: string;
          };
          roles?: components["schemas"]["user_commonUserRoleOperation"][];
        };
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "application/json": components["schemas"]["userUserInvitationResponse"];
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "application/json": components["schemas"]["rpcStatus"];
        };
      };
    };
  };
  /** GET /api/v1/profile */
  User_get_user_profile: {
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "application/json": components["schemas"]["userUserProfileData"];
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "application/json": components["schemas"]["rpcStatus"];
        };
      };
    };
  };
  /** GET /organizations  - conditions passed in the query string */
  Organization_find: {
    parameters: {
      query?: {
        name?: string;
        country?: string;
        location?: string;
        type?: string;
        cellId?: string;
        status?: string;
        createdAtFrom?: string;
        createdAtTo?: string;
        createdBy?: string;
        modifiedAtFrom?: string;
        modifiedAtTo?: string;
        modifiedBy?: string;
        skip?: number;
        limit?: number;
        /** @description attribute name */
        sortBy?: string;
        /** @description asc/desc */
        sortDirection?: string;
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "application/json": components["schemas"]["organizationListOrganizationsResponse"];
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "application/json": components["schemas"]["rpcStatus"];
        };
      };
    };
  };
  /** POST /organizations */
  Organization_create: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["organizationOrganizationData"];
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "application/json": components["schemas"]["organizationOrganizationData"];
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "application/json": components["schemas"]["rpcStatus"];
        };
      };
    };
  };
  /** POST /organizations/invitations */
  Organization_send_invitation: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["organizationOrganizationInvitiationRequest"];
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "application/json": Record<string, never>;
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "application/json": components["schemas"]["rpcStatus"];
        };
      };
    };
  };
  /** GET /organizations/{id} */
  Organization_get_by_id: {
    parameters: {
      path: {
        id: string;
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "application/json": components["schemas"]["organizationOrganizationData"];
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "application/json": components["schemas"]["rpcStatus"];
        };
      };
    };
  };
  /** PUT /organizations/{id} */
  Organization_modify: {
    parameters: {
      path: {
        id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": {
          name?: string;
          country?: string;
          location?: string;
          type?: string;
          cellId?: string;
          status?: string;
          /** Format: date-time */
          createdAt?: string;
          createdBy?: string;
          /** Format: date-time */
          modifiedAt?: string;
          modifiedBy?: string;
        };
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "application/json": components["schemas"]["organizationOrganizationData"];
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "application/json": components["schemas"]["rpcStatus"];
        };
      };
    };
  };
  /** DELETE /organizations/{id} */
  Organization_delete: {
    parameters: {
      path: {
        id: string;
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "application/json": Record<string, never>;
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "application/json": components["schemas"]["rpcStatus"];
        };
      };
    };
  };
  /** GET /organizations/{organization_id}/photos */
  Organization_get_photo: {
    parameters: {
      path: {
        id: string;
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "application/json": components["schemas"]["commonPreUrlResponse"];
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "application/json": components["schemas"]["rpcStatus"];
        };
      };
    };
  };
  /** DELETE /organizations/{organization_id}/photos */
  Organization_delete_photo: {
    parameters: {
      path: {
        id: string;
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "application/json": Record<string, never>;
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "application/json": components["schemas"]["rpcStatus"];
        };
      };
    };
  };
  /** GET /organizations/{organization_id}/workspaces  - conditions passed in the query string */
  Workspace_find: {
    parameters: {
      query?: {
        name?: string;
        billingChildAccountId?: string;
        createdAtFrom?: string;
        createdAtTo?: string;
        createdBy?: string;
        modifiedAtFrom?: string;
        modifiedAtTo?: string;
        modifiedBy?: string;
        skip?: number;
        limit?: number;
        /** @description attribute name */
        sortBy?: string;
        /** @description asc/desc */
        sortDirection?: string;
      };
      path: {
        organizationId: string;
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "application/json": components["schemas"]["workspaceListWorkspacesResponse"];
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "application/json": components["schemas"]["rpcStatus"];
        };
      };
    };
  };
  /** POST /organizations/{organization_id}/workspaces */
  Workspace_create: {
    parameters: {
      path: {
        organizationId: string;
      };
    };
    requestBody: {
      content: {
        "application/json": {
          id?: string;
          name?: string;
          /** Format: date-time */
          createdAt?: string;
          createdBy?: string;
          /** Format: date-time */
          modifiedAt?: string;
          modifiedBy?: string;
        };
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "application/json": components["schemas"]["workspaceWorkspaceData"];
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "application/json": components["schemas"]["rpcStatus"];
        };
      };
    };
  };
  /** GET /organizations/{organization_id}/workspaces/{id} */
  Workspace_get_by_id: {
    parameters: {
      path: {
        organizationId: string;
        id: string;
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "application/json": components["schemas"]["workspaceWorkspaceData"];
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "application/json": components["schemas"]["rpcStatus"];
        };
      };
    };
  };
  /** PUT /organizations/{organization_id}/workspaces */
  Workspace_modify: {
    parameters: {
      path: {
        organizationId: string;
        id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": {
          name?: string;
          /** Format: date-time */
          createdAt?: string;
          createdBy?: string;
          /** Format: date-time */
          modifiedAt?: string;
          modifiedBy?: string;
        };
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "application/json": components["schemas"]["workspaceWorkspaceData"];
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "application/json": components["schemas"]["rpcStatus"];
        };
      };
    };
  };
  /** DELETE /organizations/{organization_id}/workspaces/{id} */
  Workspace_delete: {
    parameters: {
      path: {
        organizationId: string;
        id: string;
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "application/json": Record<string, never>;
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "application/json": components["schemas"]["rpcStatus"];
        };
      };
    };
  };
  /** PUT /organizations/{organization_id}/users/{user_id}/statuses */
  UserStatus_change: {
    parameters: {
      path: {
        organizationId: string;
        userId: string;
      };
    };
    requestBody: {
      content: {
        "application/json": {
          status?: string;
          createdBy?: string;
        };
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "application/json": components["schemas"]["user_statusUserStatusResponse"];
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "application/json": components["schemas"]["rpcStatus"];
        };
      };
    };
  };
  /** Active User */
  active_user_users_active_get: {
    parameters: {
      header?: {
        "x-auth-request-user"?: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["UserModel"];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * List Users
   * @description Get the list of users
   *
   * :param access_resource_type: Access resource type to filter the users by.
   * :param access_resource_id: Access resource id to filter the users by.
   */
  list_users_users__get: {
    parameters: {
      query?: {
        access_resource_type?: components["schemas"]["AccessResourceType"];
        access_resource_id?: string;
      };
    };
    responses: {
      /** @description Request fulfilled, document follows */
      200: {
        content: {
          "application/json": {
            [key: string]: components["schemas"]["UserModel"][];
          };
        };
      };
      /** @description Bad request syntax or unsupported method */
      400: {
        content: never;
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Create User */
  create_user_users__post: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["CreateUserData"];
      };
    };
    responses: {
      /** @description User successfully created */
      201: {
        content: {
          "application/json": unknown;
        };
      };
      /** @description Bad request syntax or unsupported method */
      400: {
        content: never;
      };
      /** @description This email address is already being used. */
      409: {
        content: never;
      };
      /** @description Invalid email. */
      422: {
        content: never;
      };
    };
  };
  /**
   * Get User By Id
   * @description Endpoint for getting user's data.
   */
  get_user_by_id_users__user_id__get: {
    parameters: {
      path: {
        user_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["UserModel"];
        };
      };
      /** @description Nothing matches the given URI */
      404: {
        content: never;
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Edit User
   * @description Endpoint for updating user's data.
   */
  edit_user_users__user_id__put: {
    parameters: {
      path: {
        user_id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UserModel"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["UserModel"];
        };
      };
      /** @description Nothing matches the given URI */
      404: {
        content: never;
      };
      /** @description Request conflict */
      409: {
        content: never;
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Delete User
   * @description /delete/{user_id} handler
   */
  delete_user_users__user_id__delete: {
    parameters: {
      path: {
        user_id: string;
      };
    };
    responses: {
      /** @description User was successfully deleted. */
      200: {
        content: {
          "application/json": unknown;
        };
      };
      /** @description Nothing matches the given URI */
      404: {
        content: never;
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
      /** @description Server got itself in trouble */
      500: {
        content: never;
      };
      /** @description User is the last global admin so they cant be deleted */
      "HTTPSTATUS.UNPROCESSABLE_ENTITY": {
        content: never;
      };
    };
  };
  /** Get User Photo */
  get_user_photo_users__user_id__photo_get: {
    parameters: {
      path: {
        user_id: string;
      };
    };
    responses: {
      /** @description Photo of requested user. */
      200: {
        content: {
          "application/json": unknown;
        };
      };
      /** @description User not found or no photo uploaded. */
      404: {
        content: never;
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Upload User Photo */
  upload_user_photo_users__user_id__photo_post: {
    parameters: {
      path: {
        user_id: string;
      };
    };
    requestBody: {
      content: {
        "multipart/form-data": components["schemas"]["Body_upload_user_photo_users__user_id__photo_post"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": unknown;
        };
      };
      /** @description Bad request syntax or unsupported method */
      400: {
        content: never;
      };
      /** @description Entity is too large */
      413: {
        content: never;
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Delete User Photo
   * @description DELETE /users/{user_id}/photo handler
   */
  delete_user_photo_users__user_id__photo_delete: {
    parameters: {
      path: {
        user_id: string;
      };
    };
    responses: {
      /** @description User photo was successfully deleted. */
      200: {
        content: {
          "application/json": unknown;
        };
      };
      /** @description Nothing matches the given URI */
      404: {
        content: never;
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
      /** @description Server got itself in trouble */
      500: {
        content: never;
      };
    };
  };
  /**
   * Delete User Sessions
   * @description DELETE /{user_id}/sessions handler
   */
  delete_user_sessions_users__user_id__sessions_delete: {
    parameters: {
      path: {
        user_id: string;
      };
    };
    responses: {
      /** @description User sessions were successfully deleted. */
      200: {
        content: {
          "application/json": unknown;
        };
      };
      /** @description Nothing matches the given URI */
      404: {
        content: never;
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Invite */
  invite_users_invite_post: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["InviteData"];
      };
    };
    responses: {
      /** @description User has been successfully invited. */
      200: {
        content: {
          "application/json": unknown;
        };
      };
      /** @description Bad request syntax or unsupported method */
      400: {
        content: never;
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Login User
   * @description /users/login handler
   */
  login_user_users_login_post: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["LoginData"];
      };
    };
    responses: {
      /** @description Correct username and password provided, auth cookies set */
      200: {
        content: {
          "text/plain": string;
        };
      };
      /** @description Password not base64 encoded */
      400: {
        content: never;
      };
      /** @description Invalid username or password provided */
      401: {
        content: never;
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
      /** @description Internal call to login service has missing required data */
      500: {
        content: never;
      };
    };
  };
  /**
   * Request Password Reset
   * @description Request password endpoint on /users/request_password_reset"
   * :param user_data: data payload containing user's email address.
   * :param background_tasks: background tasks to be run after returning a response.
   */
  request_password_reset_users_request_password_reset_post: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["PasswordRequestResetData"];
      };
    };
    responses: {
      /** @description Password reset request sent. */
      202: {
        content: {
          "application/json": unknown;
        };
      };
      /** @description SMTP Server not configured. */
      400: {
        content: never;
      };
      /** @description User does not exist. */
      404: {
        content: never;
      };
      /** @description Invalid email. */
      422: {
        content: never;
      };
    };
  };
  /**
   * Reset Password
   * @description /users/reset_password handler
   */
  reset_password_users_reset_password_post: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["PasswordResetData"];
      };
    };
    responses: {
      /** @description Request fulfilled, document follows */
      200: {
        content: {
          "text/plain": string;
        };
      };
      /** @description Bad request syntax or unsupported method */
      400: {
        content: never;
      };
      /** @description No permission -- see authorization schemes */
      401: {
        content: never;
      };
      /** @description Nothing matches the given URI */
      404: {
        content: never;
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Confirm Registration
   * @description /users/confirm_registration handler
   */
  confirm_registration_users_confirm_registration_post: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["ConfirmRegistrationData"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": unknown;
        };
      };
      /** @description Bad request syntax or unsupported method */
      400: {
        content: never;
      };
      /** @description No permission -- see authorization schemes */
      401: {
        content: never;
      };
      /** @description Nothing matches the given URI */
      404: {
        content: never;
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Check Token Validity For Registration */
  check_token_validity_for_registration_users_registration_reset_password_get: {
    parameters: {
      query: {
        token: string;
      };
    };
    responses: {
      /** @description Successful Response */
      307: {
        content: {
          "application/json": unknown;
        };
      };
      /** @description Bad request syntax or unsupported method */
      400: {
        content: never;
      };
      /** @description Nothing matches the given URI */
      404: {
        content: never;
      };
      /** @description URI no longer exists and has been permanently removed */
      410: {
        content: never;
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Check Token Validity For Registration */
  check_token_validity_for_registration_users_registration_sign_up_get: {
    parameters: {
      query: {
        token: string;
      };
    };
    responses: {
      /** @description Successful Response */
      307: {
        content: {
          "application/json": unknown;
        };
      };
      /** @description Bad request syntax or unsupported method */
      400: {
        content: never;
      };
      /** @description Nothing matches the given URI */
      404: {
        content: never;
      };
      /** @description URI no longer exists and has been permanently removed */
      410: {
        content: never;
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Get User Roles By Id
   * @description Returns user's roles for given specific resource, or all resources of given type.
   * If both resource_type and resource_id parameters are passed, roles for that specific resource will be returned.
   * If only resource_type is passed, roles for all resources of given type will be returned.
   */
  get_user_roles_by_id_users__user_id__roles_get: {
    parameters: {
      query: {
        resource_type: components["schemas"]["AccessResourceType"];
        resource_id?: string;
      };
      path: {
        user_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["RolesOutputModel"];
        };
      };
      /** @description Bad request syntax or unsupported method */
      400: {
        content: never;
      };
      /** @description Nothing matches the given URI */
      404: {
        content: never;
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
      /** @description Roles of requested User. */
      "HTTPSTATUS.OK": {
        content: never;
      };
    };
  };
  /**
   * Patch User Roles By Id
   * @description Endpoint for getting user's data.
   */
  patch_user_roles_by_id_users__user_id__roles_patch: {
    parameters: {
      header?: {
        "x-auth-request-user"?: string;
      };
      path: {
        user_id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["RolesPatchModel"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": unknown;
        };
      };
      /** @description User roles were updated */
      204: {
        content: never;
      };
      /** @description Invalid resource id */
      400: {
        content: never;
      };
      /** @description Invalid authentication header */
      401: {
        content: never;
      };
      /** @description Lack of permissions for resources present in the request */
      403: {
        content: never;
      };
      /** @description Requested user not found */
      404: {
        content: never;
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
      /** @description User is the last global admin so he cant be deleted */
      "HTTPSTATUS.UNPROCESSABLE_ENTITY": {
        content: never;
      };
    };
  };
  /**
   * Update User Password
   * @description /users/[user_id]/update_password handler
   */
  update_user_password_users__user_id__update_password_post: {
    parameters: {
      path: {
        user_id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["PasswordUpdateData"];
      };
    };
    responses: {
      /** @description Request fulfilled, document follows */
      200: {
        content: {
          "text/plain": string;
        };
      };
      /** @description Bad request syntax or unsupported method */
      400: {
        content: never;
      };
      /** @description No permission -- see authorization schemes */
      401: {
        content: never;
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Get User Id From Protobuf
   * @description Returns user id calculated based on the protobuf content from the HTTP request.
   */
  get_user_id_from_protobuf_users_get_user_id_get: {
    parameters: {
      query: {
        id: string;
      };
    };
    responses: {
      /** @description Calculated user id. */
      200: {
        content: {
          "application/json": string;
        };
      };
      /** @description Bad request syntax or unsupported method */
      400: {
        content: never;
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Get Access Token */
  get_access_token_service_accounts_access_token_post: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["ServiceIdData"];
      };
    };
    responses: {
      /** @description Correct service id provided, access_token provided. */
      200: {
        content: {
          "application/json": components["schemas"]["AccessTokenOutputModel"];
        };
      };
      /** @description Invalid or expired service id. */
      401: {
        content: never;
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Get Service Account */
  get_service_account_service_accounts__get: {
    responses: {
      /** @description Returns Service Account connected to the current user with expiration date. */
      200: {
        content: {
          "application/json": components["schemas"]["ServiceAccountOutputModel"];
        };
      };
      /** @description Service account doesn't exist. */
      204: {
        content: never;
      };
      /** @description No permission -- see authorization schemes */
      401: {
        content: never;
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Refresh Service Account */
  refresh_service_account_service_accounts__put: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["RefreshServiceUserData"];
      };
    };
    responses: {
      /** @description Service account was refreshed. */
      200: {
        content: {
          "application/json": components["schemas"]["ServiceAccountWithPasswordOutputModel"];
        };
      };
      /** @description Expiration date is invalid. */
      400: {
        content: never;
      };
      /** @description User doesn't exist. */
      401: {
        content: never;
      };
      /** @description Service account doesn't exist. */
      404: {
        content: never;
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Create Service Account */
  create_service_account_service_accounts__post: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["CreateServiceUserData"];
      };
    };
    responses: {
      /** @description Service account was created. */
      201: {
        content: {
          "application/json": components["schemas"]["ServiceAccountWithPasswordOutputModel"];
        };
      };
      /** @description Expiration date is invalid. */
      400: {
        content: never;
      };
      /** @description User doesn't exist. */
      401: {
        content: never;
      };
      /** @description Service account already exists. */
      409: {
        content: never;
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Delete Service Account */
  delete_service_account_service_accounts__delete: {
    responses: {
      /** @description Service account removed. */
      200: {
        content: {
          "application/json": unknown;
        };
      };
      /** @description No permission -- see authorization schemes */
      401: {
        content: never;
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * List Feature Flags
   * @description Get map of feature flags to their corresponding enablement status.
   */
  list_feature_flags_feature_flags__get: {
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": unknown;
        };
      };
      /** @description Returns feature flags list */
      "HTTPSTATUS.OK": {
        content: never;
      };
    };
  };
  /**
   * Logs Endpoint
   * @description Request logs endpoint on /logs"
   */
  logs_endpoint_logs__get: {
    parameters: {
      query?: {
        type?: string;
        "operation-id"?: string;
        "start-date"?: string;
        "end-date"?: string;
        "log-level"?: string;
      };
    };
    responses: {
      /** @description Return the tar.gz file with logs */
      200: {
        content: {
          "application/json": unknown;
          "application/octet-stream": unknown;
        };
      };
      /** @description Unknown log type. Please make sure specified value parameter is either "cluster" or "logs". */
      400: {
        content: {
          "text/plain": unknown;
        };
      };
      /** @description Access denied - user is not an administrator. */
      403: {
        content: {
          "text/plain": unknown;
        };
      };
      /** @description Error when preparing a zipped folder with logs */
      404: {
        content: {
          "text/plain": unknown;
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Get All Products
   * @description Returns all available Geti SaaS subscription products
   */
  get_all_products_api_v1_products_get: {
    parameters: {
      query?: {
        limit?: number;
        skip?: number;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["ListProductResponse"];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Get Product By Id
   * @description Returns Geti SaaS subscription product with the specified id
   */
  get_product_by_id_api_v1_products__product_id__get: {
    parameters: {
      path: {
        product_id: number;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["Product"];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Get Balance
   * @description The running credit balance of an organization is calculated during the current subscription cycle
   */
  get_balance_api_v1_organizations__org_id__balance_get: {
    parameters: {
      query?: {
        date?: number | null;
      };
      path: {
        org_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["BalanceResponse"];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Edit Account Balance
   * @description Edits balance of a certain credit account by comparing current available balance
   * with a balance in the provided payload, and creating a credits transaction covering the difference.
   */
  edit_account_balance_api_v1_organizations__org_id__credit_accounts__account_id__balance_put: {
    parameters: {
      path: {
        org_id: string;
        account_id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["BalancePayload"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": unknown;
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Get Credit Accounts
   * @description Returns billable credit accounts of the organization ('asset' account type, not expired).
   * Lease and SaaS provider accounts not included.
   */
  get_credit_accounts_api_v1_organizations__org_id__credit_accounts_get: {
    parameters: {
      query?: {
        skip?: number;
        limit?: number;
      };
      path: {
        org_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["CreditAccountsResponse"];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Create Credit Account
   * @description Creates a new asset account for the organization.
   */
  create_credit_account_api_v1_organizations__org_id__credit_accounts_post: {
    parameters: {
      path: {
        org_id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["CreditAccountPostPayload"];
      };
    };
    responses: {
      /** @description Successful Response */
      201: {
        content: {
          "application/json": unknown;
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Update Credit Account
   * @description Updates the credit account of the organization.
   */
  update_credit_account_api_v1_organizations__org_id__credit_accounts__acc_id__put: {
    parameters: {
      path: {
        org_id: string;
        acc_id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["CreditAccountPutPayload"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["CreditAccount"];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * [SaaS] Get all organization's subscriptions
   * @description <i>Not available on on-premises environments.</i><br><br> Returns all organization's subscriptions.
   */
  get_organization_subscriptions_api_v1_organizations__organization_id__subscriptions_get: {
    parameters: {
      query?: {
        skip?: number;
        limit?: number;
      };
      path: {
        organization_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": {
            /** Total Matched */
            total_matched: number;
            next_page?: {
              /** Limit */
              limit: number;
              /** Skip */
              skip: number;
            } | null;
            /** Subscriptions */
            subscriptions: ({
                /**
                 * Id
                 * Format: uuid
                 */
                id: string;
                /** Organization Id */
                organization_id: string;
                /** Workspace Id */
                workspace_id: string;
                /**
                 * Product Id
                 * Format: uuid
                 */
                product_id: string;
                /** Status */
                status: string;
                /** Created */
                created: number;
                /** Updated */
                updated: number;
                /** Next Renewal Date */
                next_renewal_date?: number | null;
                /** Previous Renewal Date */
                previous_renewal_date?: number | null;
              })[];
          };
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": {
            /** Detail */
            detail?: unknown[];
          };
        };
      };
    };
  };
  /**
   * Create Subscription
   * @description Creates new subscription within organization for specified product
   */
  create_subscription_api_v1_organizations__organization_id__subscriptions_post: {
    parameters: {
      path: {
        organization_id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["SubscriptionPayload"];
      };
    };
    responses: {
      /** @description Successful Response */
      201: {
        content: {
          "application/json": unknown;
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Get Subscription By Id
   * @description Returns organization's subscription with the requested id
   */
  get_subscription_by_id_api_v1_organizations__organization_id__subscriptions__subscription_id__get: {
    parameters: {
      path: {
        organization_id: string;
        subscription_id: number;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["SubscriptionResponse"];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Get Credit Consumption Aggregates
   * @description The Aggregating endpoint allows to retrieve credit consumption grouped by various
   * dimensions such as project and workspace, date, etc.
   */
  get_credit_consumption_aggregates_api_v1_organizations__org_id__transactions_aggregates_get: {
    parameters: {
      query: {
        key: components["schemas"]["AggregatesKey"][];
        from_date?: number | null;
        to_date?: number | null;
        project_id?: string[] | null;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["AggregatesResponse"];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Get Transactions
   * @description The Aggregating endpoint allows to retrieve credit consumption grouped by various
   * dimensions such as project and workspace, date, etc.
   */
  get_transactions_api_v1_organizations__org_id__transactions_get: {
    parameters: {
      query?: {
        skip?: number | null;
        limit?: number;
      };
      path: {
        org_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["TransactionsResponse"];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Rollover Credit Accounts
   * @description Performs credit accounts renewal.
   */
  rollover_credit_accounts_api_v1_internal_tasks_credit_accounts_rollover_post: {
    parameters: {
      query?: {
        renewal_date?: number | null;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": unknown;
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Calculate Snapshot
   * @description Get all non-renewable, active (not expired) asset credit accounts,
   * and for each of them calculate and write to the database a balance snapshot, with available and incoming balances.
   *
   * Calculation takes the latest account's snapshot value (if available) and incorporates
   * transactions created thereafter until the present moment
   */
  calculate_snapshot_api_v1_internal_tasks_credit_accounts_snapshot_post: {
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": unknown;
        };
      };
    };
  };
  /**
   * Get Organization ID for Personal Access Token.
   * @description Return ID for Organization that Personal Account Token is created for. Use returned value in all subsequent calls as `organization_id` parameter.
   */
  PersonalAccessTokenOrganization: {
    responses: {
      /** @description Organization data */
      200: {
        content: {
          "application/json": {
            organizationId: string;
          };
        };
      };
    };
  };
  /**
   * Get information about all workspaces
   * @description List all workspaces in an organization.
   */
  GetAllWorkspaces: {
    parameters: {
      path: {
        /** @description The ID of the organization. */
        organization_id: string;
      };
    };
    responses: {
      /** @description The requested workspaces info */
      200: {
        content: {
          "application/json": {
            /** @description Array of workspaces */
            workspaces: {
                /**
                 * @description UUID of the object
                 * @example 2e1de607-b549-42bf-8031-fd16d87379e5
                 */
                id: string;
                /** @description Name of the workspace */
                name: string;
                /** @description Description of the workspace */
                description?: string;
                /** @description Name of the creator of the workspace */
                creator_name?: string;
                /** @description Creation date of the workspace */
                creation_date?: string;
              }[];
          };
        };
      };
      /** @description Object not found. See the examples for details. */
      404: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 400 | 404 | 405 | 409 | 412 | 413 | 415 | 422 | 423 | 500 | 501 | 503;
            /** @description Message from server */
            message: string;
            /** @description Error code from server */
            error_code: string;
          };
        };
      };
    };
  };
  /**
   * Get info about all projects in a workspace
   * @description Get all projects in the workspace.
   */
  GetAllProjectsInAWorkspace: {
    parameters: {
      query?: {
        /** @description Fill this field to filter the list based on project name. This is an `include` filter. */
        name?: string;
        /** @description Number of items returned in the response. Default is 10 and maximum is 100. */
        limit?: number;
        /**
         * @description Number indicating how many items to skip from the first item that matches the query.
         * This field is used in combination with the limit field for the pagination feature.
         */
        skip?: string;
        /** @description Sorting order, could be `asc` (ascending) or `dsc` (descending). */
        sort_direction?: "asc" | "dsc";
        /** @description Field to sort by, could be name or creation_date */
        sort_by?: "name" | "creation_date";
        /** @description Set to true to return the project size in the response. Default is False. */
        with_size?: boolean;
      };
      path: {
        /** @description The ID of the organization. */
        organization_id: string;
        /** @description The ID of the workspace. */
        workspace_id: string;
      };
    };
    responses: {
      /** @description The requested project info */
      200: {
        content: {
          "application/json": {
            /** @description Array of projects */
            projects?: ({
                /** @description Project name */
                name: string;
                /**
                 * @description Mongo ID of the object
                 * @example 60d31793d5f1fb7e6e3c1a4c
                 */
                id: string;
                pipeline: {
                  /** @description List of connections between pipeline tasks */
                  connections: {
                      /**
                       * @description Mongo ID of the object
                       * @example 60d31793d5f1fb7e6e3c1a4c
                       */
                      from?: string;
                      /**
                       * @description Mongo ID of the object
                       * @example 60d31793d5f1fb7e6e3c1a4c
                       */
                      to?: string;
                    }[];
                  /** @description List of tasks in the pipeline */
                  tasks: ({
                      /** @description Task title, must be unique */
                      title: string;
                      /** @description Task type; should be one of: [ classification, detection, segmentation, crop, dataset ] */
                      task_type: string;
                      /** @description List of labels */
                      labels?: ({
                          /** @description Label name, must be unique */
                          name: string;
                          /**
                           * @description Mongo ID of the object
                           * @example 60d31793d5f1fb7e6e3c1a4c
                           */
                          id: string;
                          /** @description Label color, picked at random if not specified */
                          color: string;
                          /** @description Name of label group */
                          group: string;
                          /** @description Name of parent label */
                          parent_id: string | null;
                          /** @description Indicates whether the label is an empty label */
                          is_empty: boolean;
                          /** @description Indicates whether the label is anomalous or not */
                          is_anomalous: boolean;
                          /** @description Indicates whether the label is deleted */
                          is_deleted?: boolean;
                          /** @description Key or combination of key to select this label. Can be empty (no key). */
                          hotkey: string;
                        })[];
                      /**
                       * @description Mongo ID of the object
                       * @example 60d31793d5f1fb7e6e3c1a4c
                       */
                      id: string;
                      /**
                       * @description Mongo ID of the object
                       * @example 60d31793d5f1fb7e6e3c1a4c
                       */
                      label_schema_id?: string;
                      /** @description The keypoint structure which holds the edges of the graph, and the position of the keypoints. Supported only for Keypoint Detection tasks. */
                      keypoint_structure?: Record<string, never>;
                    })[];
                };
                /** @description Creation time of the project */
                creation_time: string;
                /** @description Identifier of the user who created the project */
                creator_id?: string;
                performance?: {
                  /**
                   * Format: float
                   * @description Average score of task scores of a project, null if no model is trained.
                   */
                  score?: number | null;
                  task_performances?: ({
                      /**
                       * @description Mongo ID of the object
                       * @example 60d31793d5f1fb7e6e3c1a4c
                       */
                      task_id: string;
                      /** @description Model score for the task, null if no model is trained. */
                      score: null | {
                        /**
                         * Format: float
                         * @description Value of the score.
                         */
                        value: number;
                        /** @description Name of the algorithm that is used to calculate the metric value, eg dice average, f-measure, etc. */
                        metric_type: string;
                      };
                    })[];
                };
                /** @description Thumbnail URL */
                thumbnail: string;
                storage_info: {
                  /** Project size in bytes */
                  size?: number;
                };
              })[];
            /** @description URL to the next projects page */
            next_page?: string;
            /** @description Total number of projects in the workspace */
            project_counts?: number;
            /** @description Total number of projects in the response */
            project_page_count?: number;
          };
        };
      };
      /** @description Object not found. See the examples for details. */
      404: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 400 | 404 | 405 | 409 | 412 | 413 | 415 | 422 | 423 | 500 | 501 | 503;
            /** @description Message from server */
            message: string;
            /** @description Error code from server */
            error_code: string;
          };
        };
      };
    };
  };
  /**
   * Create a project
   * @description Create a project in a workspace. Please refer to the schema to see all the supported tasks and please refer to the examples to see how
   * the project is constructed. At the moment, Geti supports projects with a single deep learning task, or with two in a
   * chain (Detection -> Classification and Detection -> Segmentation).
   * A few label constraints:
   * - Detection projects must have at least 1 label provided.
   * - A default 'No object' label is automatically created for detection and segmentation tasks.
   * - Classification projects require at least two labels (top-level, if hierarchical). For binary classification, please declare the negative label explicitly.
   * - A default 'No class' label is automatically created for classification tasks if there are no exclusive groups with 2+ labels. In practice, multilabel classification has the empty label, multiclass classification does not.
   * - Anomaly project must either have 2 labels provided (one being is_anomalous), or no labels provided.
   */
  CreateProject: {
    parameters: {
      path: {
        /** @description The ID of the organization. */
        organization_id: string;
        /** @description The ID of the workspace. */
        workspace_id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": {
          /** @description Project name */
          name: string;
          pipeline: {
            /** @description List of connections between pipeline tasks */
            connections: {
                /** @description Title of source task */
                from: string;
                /** @description Title of destination task */
                to: string;
              }[];
            /** @description List of tasks in the pipeline */
            tasks: ({
                /** @description Task title, must be unique */
                title: string;
                /**
                 * @description Type of task, can only be one of the predefined task types
                 * @enum {string}
                 */
                task_type: "dataset" | "crop" | "classification" | "detection" | "segmentation" | "rotated_detection" | "instance_segmentation" | "anomaly" | "keypoint_detection";
                /** @description List of labels */
                labels?: {
                    /** @description Label name, must be unique */
                    name: string;
                    /** @description Label color, picked at random if not specified */
                    color?: string;
                    /** @description Key or combination of key to select this label. Can be empty (no key). */
                    hotkey?: string;
                    /** @description Name of label group */
                    group?: string;
                    /** @description Name of parent label */
                    parent_id?: unknown;
                  }[];
                /** @description The keypoint structure which holds the edges of the graph, and the position of the keypoints. Supported only for Keypoint Detection tasks. */
                keypoint_structure?: Record<string, never>;
              })[];
          };
        };
      };
    };
    responses: {
      /** @description Project successfully created */
      201: {
        content: {
          "application/json": {
            /** @description Project name */
            name?: string;
            /**
             * @description Mongo ID of the object
             * @example 60d31793d5f1fb7e6e3c1a4c
             */
            id?: string;
            pipeline: {
              /** @description List of connections between pipeline tasks */
              connections: {
                  /**
                   * @description Mongo ID of the object
                   * @example 60d31793d5f1fb7e6e3c1a4c
                   */
                  from?: string;
                  /**
                   * @description Mongo ID of the object
                   * @example 60d31793d5f1fb7e6e3c1a4c
                   */
                  to?: string;
                }[];
              /** @description List of tasks in the pipeline */
              tasks: ({
                  /** @description Task title, must be unique */
                  title: string;
                  /** @description Task type; should be one of: [ classification, detection, segmentation, crop, dataset ] */
                  task_type: string;
                  /** @description List of labels */
                  labels?: ({
                      /** @description Label name, must be unique */
                      name: string;
                      /**
                       * @description Mongo ID of the object
                       * @example 60d31793d5f1fb7e6e3c1a4c
                       */
                      id: string;
                      /** @description Label color, picked at random if not specified */
                      color: string;
                      /** @description Name of label group */
                      group: string;
                      /** @description Name of parent label */
                      parent_id: string | null;
                      /** @description Indicates whether the label is an empty label */
                      is_empty: boolean;
                      /** @description Indicates whether the label is anomalous or not */
                      is_anomalous: boolean;
                      /** @description Indicates whether the label is deleted */
                      is_deleted?: boolean;
                      /** @description Key or combination of key to select this label. Can be empty (no key). */
                      hotkey: string;
                    })[];
                  /**
                   * @description Mongo ID of the object
                   * @example 60d31793d5f1fb7e6e3c1a4c
                   */
                  id: string;
                  /**
                   * @description Mongo ID of the object
                   * @example 60d31793d5f1fb7e6e3c1a4c
                   */
                  label_schema_id?: string;
                  /** @description The keypoint structure which holds the edges of the graph, and the position of the keypoints. Supported only for Keypoint Detection tasks. */
                  keypoint_structure?: Record<string, never>;
                })[];
            };
            /** @description Creation time of the project */
            creation_time?: string;
            /** @description The ID of the user who created the project */
            creator_id?: string;
            performance?: {
              /**
               * Format: float
               * @description Average score of task scores of a project, null if no model is trained.
               */
              score?: number | null;
              task_performances?: ({
                  /**
                   * @description Mongo ID of the object
                   * @example 60d31793d5f1fb7e6e3c1a4c
                   */
                  task_id: string;
                  /** @description Model score for the task, null if no model is trained. */
                  score: null | {
                    /**
                     * Format: float
                     * @description Value of the score.
                     */
                    value: number;
                    /** @description Name of the algorithm that is used to calculate the metric value, eg dice average, f-measure, etc. */
                    metric_type: string;
                  };
                })[];
            };
            /** @description Thumbnail url */
            thumbnail?: string;
            /** @description List of datasets in the project */
            datasets: {
                /**
                 * @description Mongo ID of the object
                 * @example 60d31793d5f1fb7e6e3c1a4c
                 */
                id: string;
                /** @description Name of the dataset */
                name: string;
                /** @description Creation time of the dataset */
                creation_time: string;
                /** @description Indicates if the dataset is used to train the active model */
                use_for_training: boolean;
              }[];
            storage_info: {
              /** Project size in bytes */
              size?: number;
            };
          };
        };
      };
      /** @description Bad request. The provided information is insufficient to create a project. */
      400: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 400 | 404 | 405 | 409 | 412 | 413 | 415 | 422 | 423 | 500 | 501 | 503;
            /** @description Message from server */
            message: string;
            /** @description Error code from server */
            error_code: string;
          };
        };
      };
      /** @description Object not found. See the examples for details. */
      404: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 400 | 404 | 405 | 409 | 412 | 413 | 415 | 422 | 423 | 500 | 501 | 503;
            /** @description Message from server */
            message: string;
            /** @description Error code from server */
            error_code: string;
          };
        };
      };
    };
  };
  /**
   * Get the names of all projects in a workspace.
   * @description Get names of all projects in a workspace
   */
  GetAllProjectsNamesInAWorkspace: {
    parameters: {
      path: {
        /** @description The ID of the organization. */
        organization_id: string;
        /** @description The ID of the workspace. */
        workspace_id: string;
      };
    };
    responses: {
      /** @description The requested projects names */
      200: {
        content: {
          "application/json": {
            projects?: {
                /** @description Project name */
                name: string;
                /**
                 * @description Mongo ID of the object
                 * @example 60d31793d5f1fb7e6e3c1a4c
                 */
                id: string;
              }[];
          };
        };
      };
      /** @description Object not found. See the examples for details. */
      404: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 400 | 404 | 405 | 409 | 412 | 413 | 415 | 422 | 423 | 500 | 501 | 503;
            /** @description Message from server */
            message: string;
            /** @description Error code from server */
            error_code: string;
          };
        };
      };
    };
  };
  /**
   * Get info about a project
   * @description Get information about a project.
   */
  GetProjectInfo: {
    parameters: {
      query?: {
        /** @description Set to True to also include the deleted labels in the response.  If set to true, each label will have a field called is_deleted that will be set to true if the label has been deleted. Default value is False. */
        include_deleted_labels?: boolean;
        /** @description Set to true to return the project size in the response. Default is False. */
        with_size?: boolean;
      };
      path: {
        /** @description The ID of the organization. */
        organization_id: string;
        /** @description The ID of the workspace. */
        workspace_id: string;
        /** @description The ID of the project. */
        project_id: string;
      };
    };
    responses: {
      /** @description Info about the requested project */
      200: {
        content: {
          "application/json": {
            /** @description Project name */
            name?: string;
            /**
             * @description Mongo ID of the object
             * @example 60d31793d5f1fb7e6e3c1a4c
             */
            id?: string;
            pipeline: {
              /** @description List of connections between pipeline tasks */
              connections: {
                  /**
                   * @description Mongo ID of the object
                   * @example 60d31793d5f1fb7e6e3c1a4c
                   */
                  from?: string;
                  /**
                   * @description Mongo ID of the object
                   * @example 60d31793d5f1fb7e6e3c1a4c
                   */
                  to?: string;
                }[];
              /** @description List of tasks in the pipeline */
              tasks: ({
                  /** @description Task title, must be unique */
                  title: string;
                  /** @description Task type; should be one of: [ classification, detection, segmentation, crop, dataset ] */
                  task_type: string;
                  /** @description List of labels */
                  labels?: ({
                      /** @description Label name, must be unique */
                      name: string;
                      /**
                       * @description Mongo ID of the object
                       * @example 60d31793d5f1fb7e6e3c1a4c
                       */
                      id: string;
                      /** @description Label color, picked at random if not specified */
                      color: string;
                      /** @description Name of label group */
                      group: string;
                      /** @description Name of parent label */
                      parent_id: string | null;
                      /** @description Indicates whether the label is an empty label */
                      is_empty: boolean;
                      /** @description Indicates whether the label is anomalous or not */
                      is_anomalous: boolean;
                      /** @description Indicates whether the label is deleted */
                      is_deleted?: boolean;
                      /** @description Key or combination of key to select this label. Can be empty (no key). */
                      hotkey: string;
                    })[];
                  /**
                   * @description Mongo ID of the object
                   * @example 60d31793d5f1fb7e6e3c1a4c
                   */
                  id: string;
                  /**
                   * @description Mongo ID of the object
                   * @example 60d31793d5f1fb7e6e3c1a4c
                   */
                  label_schema_id?: string;
                  /** @description The keypoint structure which holds the edges of the graph, and the position of the keypoints. Supported only for Keypoint Detection tasks. */
                  keypoint_structure?: Record<string, never>;
                })[];
            };
            /** @description Creation time of the project */
            creation_time?: string;
            /** @description The ID of the user who created the project */
            creator_id?: string;
            performance?: {
              /**
               * Format: float
               * @description Average score of task scores of a project, null if no model is trained.
               */
              score?: number | null;
              task_performances?: ({
                  /**
                   * @description Mongo ID of the object
                   * @example 60d31793d5f1fb7e6e3c1a4c
                   */
                  task_id: string;
                  /** @description Model score for the task, null if no model is trained. */
                  score: null | {
                    /**
                     * Format: float
                     * @description Value of the score.
                     */
                    value: number;
                    /** @description Name of the algorithm that is used to calculate the metric value, eg dice average, f-measure, etc. */
                    metric_type: string;
                  };
                })[];
            };
            /** @description Thumbnail url */
            thumbnail?: string;
            /** @description List of datasets in the project */
            datasets: {
                /**
                 * @description Mongo ID of the object
                 * @example 60d31793d5f1fb7e6e3c1a4c
                 */
                id: string;
                /** @description Name of the dataset */
                name: string;
                /** @description Creation time of the dataset */
                creation_time: string;
                /** @description Indicates if the dataset is used to train the active model */
                use_for_training: boolean;
              }[];
            storage_info: {
              /** Project size in bytes */
              size?: number;
            };
          };
        };
      };
      /** @description Object not found. See the examples for details. */
      404: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 400 | 404 | 405 | 409 | 412 | 413 | 415 | 422 | 423 | 500 | 501 | 503;
            /** @description Message from server */
            message: string;
            /** @description Error code from server */
            error_code: string;
          };
        };
      };
    };
  };
  /**
   * Edit a project
   * @description Edit project properties. This is limited to:
   * - Editing project name
   * - Adding or removing labels
   * - Editing label name, color, and hotkey.
   */
  EditProject: {
    parameters: {
      path: {
        /** @description The ID of the organization. */
        organization_id: string;
        /** @description The ID of the workspace. */
        workspace_id: string;
        /** @description The ID of the project. */
        project_id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": {
          /** @description Project name */
          name: string;
          pipeline: {
            /** @description List of connections between pipeline tasks */
            connections: {
                /**
                 * @description Mongo ID of the object
                 * @example 60d31793d5f1fb7e6e3c1a4c
                 */
                from: string;
                /**
                 * @description Mongo ID of the object
                 * @example 60d31793d5f1fb7e6e3c1a4c
                 */
                to: string;
              }[];
            /** @description List of tasks in the pipeline */
            tasks: ({
                /** @description Task title, must be unique */
                title: string;
                /** @description Task type; should be one of: [ classification, detection, segmentation, anomaly, crop, dataset ] */
                task_type: string;
                /**
                 * @description Mongo ID of the object
                 * @example 60d31793d5f1fb7e6e3c1a4c
                 */
                id: string;
                /** @description List of labels */
                labels?: {
                    /** @description Label name, must be unique */
                    name: string;
                    /**
                     * @description Mongo ID of the object
                     * @example 60d31793d5f1fb7e6e3c1a4c
                     */
                    id?: string;
                    /** @description Label color, picked at random if not specified */
                    color: string;
                    /** @description Key or combination of key to select this label. Can be empty (no key). */
                    hotkey?: string;
                    /** @description Name of label group */
                    group?: string;
                    /** @description Indicates whether the label is an empty label */
                    is_empty?: boolean;
                    /** @description Indicates whether the label is going to be deleted */
                    is_deleted?: boolean;
                    /** @description Name of parent label */
                    parent_id?: unknown;
                    /** @description On label schema change, whether to mark the annotations linked to this label as "to be revisited" by the user */
                    revisit_affected_annotations?: boolean;
                  }[];
                /**
                 * @description Mongo ID of the object
                 * @example 60d31793d5f1fb7e6e3c1a4c
                 */
                label_schema_id?: string | null;
                /** @description The keypoint structure which holds the edges of the graph, and the position of the keypoints. Supported only for Keypoint Detection tasks. */
                keypoint_structure?: Record<string, never>;
              })[];
          };
          /**
           * @description Mongo ID of the object
           * @example 60d31793d5f1fb7e6e3c1a4c
           */
          id: string;
          /** @description Creation time of the project */
          creation_time?: string;
          /** @description The username of the creator of the project */
          creator_id?: string;
          performance?: {
            /**
             * Format: float
             * @description Average score of task scores of a project, null if no model is trained.
             */
            score?: number | null;
            task_performances?: ({
                /**
                 * @description Mongo ID of the object
                 * @example 60d31793d5f1fb7e6e3c1a4c
                 */
                task_id: string;
                /** @description Model score for the task, null if no model is trained. */
                score: null | {
                  /**
                   * Format: float
                   * @description Value of the score.
                   */
                  value: number;
                  /** @description Name of the algorithm that is used to calculate the metric value, eg dice average, f-measure, etc. */
                  metric_type: string;
                };
              })[];
          };
          /** @description Thumbnail url */
          thumbnail?: string;
          /** @description List of datasets in the project */
          datasets?: {
              /**
               * @description Mongo ID of the object
               * @example 60d31793d5f1fb7e6e3c1a4c
               */
              id?: string;
              /** @description Name of the dataset */
              name?: string;
            }[];
        };
      };
    };
    responses: {
      /** @description Project successfully edited */
      200: {
        content: {
          "application/json": {
            /** @description Project name */
            name?: string;
            /**
             * @description Mongo ID of the object
             * @example 60d31793d5f1fb7e6e3c1a4c
             */
            id?: string;
            pipeline: {
              /** @description List of connections between pipeline tasks */
              connections: {
                  /**
                   * @description Mongo ID of the object
                   * @example 60d31793d5f1fb7e6e3c1a4c
                   */
                  from?: string;
                  /**
                   * @description Mongo ID of the object
                   * @example 60d31793d5f1fb7e6e3c1a4c
                   */
                  to?: string;
                }[];
              /** @description List of tasks in the pipeline */
              tasks: ({
                  /** @description Task title, must be unique */
                  title: string;
                  /** @description Task type; should be one of: [ classification, detection, segmentation, crop, dataset ] */
                  task_type: string;
                  /** @description List of labels */
                  labels?: ({
                      /** @description Label name, must be unique */
                      name: string;
                      /**
                       * @description Mongo ID of the object
                       * @example 60d31793d5f1fb7e6e3c1a4c
                       */
                      id: string;
                      /** @description Label color, picked at random if not specified */
                      color: string;
                      /** @description Name of label group */
                      group: string;
                      /** @description Name of parent label */
                      parent_id: string | null;
                      /** @description Indicates whether the label is an empty label */
                      is_empty: boolean;
                      /** @description Indicates whether the label is anomalous or not */
                      is_anomalous: boolean;
                      /** @description Indicates whether the label is deleted */
                      is_deleted?: boolean;
                      /** @description Key or combination of key to select this label. Can be empty (no key). */
                      hotkey: string;
                    })[];
                  /**
                   * @description Mongo ID of the object
                   * @example 60d31793d5f1fb7e6e3c1a4c
                   */
                  id: string;
                  /**
                   * @description Mongo ID of the object
                   * @example 60d31793d5f1fb7e6e3c1a4c
                   */
                  label_schema_id?: string;
                  /** @description The keypoint structure which holds the edges of the graph, and the position of the keypoints. Supported only for Keypoint Detection tasks. */
                  keypoint_structure?: Record<string, never>;
                })[];
            };
            /** @description Creation time of the project */
            creation_time?: string;
            /** @description The ID of the user who created the project */
            creator_id?: string;
            performance?: {
              /**
               * Format: float
               * @description Average score of task scores of a project, null if no model is trained.
               */
              score?: number | null;
              task_performances?: ({
                  /**
                   * @description Mongo ID of the object
                   * @example 60d31793d5f1fb7e6e3c1a4c
                   */
                  task_id: string;
                  /** @description Model score for the task, null if no model is trained. */
                  score: null | {
                    /**
                     * Format: float
                     * @description Value of the score.
                     */
                    value: number;
                    /** @description Name of the algorithm that is used to calculate the metric value, eg dice average, f-measure, etc. */
                    metric_type: string;
                  };
                })[];
            };
            /** @description Thumbnail url */
            thumbnail?: string;
            /** @description List of datasets in the project */
            datasets: {
                /**
                 * @description Mongo ID of the object
                 * @example 60d31793d5f1fb7e6e3c1a4c
                 */
                id: string;
                /** @description Name of the dataset */
                name: string;
                /** @description Creation time of the dataset */
                creation_time: string;
                /** @description Indicates if the dataset is used to train the active model */
                use_for_training: boolean;
              }[];
            storage_info: {
              /** Project size in bytes */
              size?: number;
            };
          };
        };
      };
      /** @description Request body is invalid */
      400: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 400 | 404 | 405 | 409 | 412 | 413 | 415 | 422 | 423 | 500 | 501 | 503;
            /** @description Message from server */
            message: string;
            /** @description Error code from server */
            error_code: string;
          };
        };
      };
      /** @description Object not found. See the examples for details. */
      404: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 400 | 404 | 405 | 409 | 412 | 413 | 415 | 422 | 423 | 500 | 501 | 503;
            /** @description Message from server */
            message: string;
            /** @description Error code from server */
            error_code: string;
          };
        };
      };
      /** @description Requested project cannot be edited */
      409: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 400 | 404 | 405 | 409 | 412 | 413 | 415 | 422 | 423 | 500 | 501 | 503;
            /** @description Message from server */
            message: string;
            /** @description Error code from server */
            error_code: string;
          };
        };
      };
    };
  };
  /**
   * Delete a project
   * @description Delete a project. Note that a deleted project cannot be recovered.
   */
  DeleteProject: {
    parameters: {
      path: {
        /** @description The ID of the organization. */
        organization_id: string;
        /** @description The ID of the workspace. */
        workspace_id: string;
        /** @description The ID of the project. */
        project_id: string;
      };
    };
    responses: {
      /** @description Successfully deleted project */
      200: {
        content: {
          "application/json": unknown;
        };
      };
      /** @description Object not found. See the examples for details. */
      404: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 400 | 404 | 405 | 409 | 412 | 413 | 415 | 422 | 423 | 500 | 501 | 503;
            /** @description Message from server */
            message: string;
            /** @description Error code from server */
            error_code: string;
          };
        };
      };
      /** @description Requested project cannot be deleted due to running jobs */
      409: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 400 | 404 | 405 | 409 | 412 | 413 | 415 | 422 | 423 | 500 | 501 | 503;
            /** @description Message from server */
            message: string;
            /** @description Error code from server */
            error_code: string;
          };
        };
      };
    };
  };
  /**
   * Download the thumbnail of a project
   * @description Download a project thumbnail with height and width as specified in the request parameters.
   */
  DownloadProjectThumbnail: {
    parameters: {
      path: {
        /** @description The ID of the organization. */
        organization_id: string;
        /** @description The ID of the workspace. */
        workspace_id: string;
        /** @description The ID of the project. */
        project_id: string;
      };
    };
    responses: {
      /** @description The requested project thumbnail */
      200: {
        content: {
          "image/*": string;
        };
      };
      /** @description No media in project. */
      204: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 200 | 201 | 202 | 203 | 204 | 205 | 206;
            /** @description Message from server */
            message: string;
          };
        };
      };
      /** @description Object not found. See the examples for details. */
      404: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 400 | 404 | 405 | 409 | 412 | 413 | 415 | 422 | 423 | 500 | 501 | 503;
            /** @description Message from server */
            message: string;
            /** @description Error code from server */
            error_code: string;
          };
        };
      };
      /** @description Internal server error */
      500: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 400 | 404 | 405 | 409 | 412 | 413 | 415 | 422 | 423 | 500 | 501 | 503;
            /** @description Message from server */
            message: string;
            /** @description Error code from server */
            error_code: string;
          };
        };
      };
    };
  };
  /**
   * Get datasets
   * @description List all the datasets in a project.
   */
  GetDatasetsInfo: {
    parameters: {
      path: {
        /** @description The ID of the organization. */
        organization_id: string;
        /** @description The ID of the workspace. */
        workspace_id: string;
        /** @description The ID of the project. */
        project_id: string;
      };
    };
    responses: {
      /** @description Info of the datasets in project */
      200: {
        content: {
          "application/json": {
            /** @description Array of datasets */
            datasets?: {
                /**
                 * @description Mongo ID of the object
                 * @example 60d31793d5f1fb7e6e3c1a4c
                 */
                id?: string;
                /** @description Dataset name */
                name?: string;
                /** @description Whether dataset is used for training */
                use_for_training?: boolean;
                /** @description Creation time of the dataset */
                creation_time?: string;
              }[];
          };
        };
      };
      /** @description Object not found. See the examples for details. */
      404: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 400 | 404 | 405 | 409 | 412 | 413 | 415 | 422 | 423 | 500 | 501 | 503;
            /** @description Message from server */
            message: string;
            /** @description Error code from server */
            error_code: string;
          };
        };
      };
    };
  };
  /**
   * Create dataset
   * @description Create a new dataset in a project.
   * At the moment, the new dataset can be used as a held-out testing dataset via model testing job.
   */
  CreateDataset: {
    parameters: {
      path: {
        /** @description The ID of the organization. */
        organization_id: string;
        /** @description The ID of the workspace. */
        workspace_id: string;
        /** @description The ID of the project. */
        project_id: string;
      };
    };
    requestBody?: {
      content: {
        "application/json": {
          /** @description Dataset name */
          name: string;
        };
      };
    };
    responses: {
      /** @description Created dataset successfully */
      200: {
        content: {
          "application/json": {
            /**
             * @description Mongo ID of the object
             * @example 60d31793d5f1fb7e6e3c1a4c
             */
            id?: string;
            /** @description Dataset name */
            name?: string;
            /** @description Whether dataset is used for training */
            use_for_training?: boolean;
            /** @description Creation time of the dataset */
            creation_time?: string;
          };
        };
      };
      /** @description Object not found. See the examples for details. */
      404: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 400 | 404 | 405 | 409 | 412 | 413 | 415 | 422 | 423 | 500 | 501 | 503;
            /** @description Message from server */
            message: string;
            /** @description Error code from server */
            error_code: string;
          };
        };
      };
      /** @description dataset name already exists. */
      409: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 400 | 404 | 405 | 409 | 412 | 413 | 415 | 422 | 423 | 500 | 501 | 503;
            /** @description Message from server */
            message: string;
            /** @description Error code from server */
            error_code: string;
          };
        };
      };
    };
  };
  /**
   * Get info about dataset
   * @description Get information about a dataset in a project.
   */
  GetDatasetInfo: {
    parameters: {
      path: {
        /** @description The ID of the organization. */
        organization_id: string;
        /** @description The ID of the workspace. */
        workspace_id: string;
        /** @description The ID of the project. */
        project_id: string;
        /** @description The ID of the dataset in the project. */
        dataset_id: string;
      };
    };
    responses: {
      /** @description Info about the dataset */
      200: {
        content: {
          "application/json": {
            /**
             * @description Mongo ID of the object
             * @example 60d31793d5f1fb7e6e3c1a4c
             */
            id?: string;
            /** @description Dataset name */
            name?: string;
            /** @description Whether dataset is used for training */
            use_for_training?: boolean;
            /** @description Creation time of the dataset */
            creation_time?: string;
          };
        };
      };
      /** @description Object not found. See the examples for details. */
      404: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 400 | 404 | 405 | 409 | 412 | 413 | 415 | 422 | 423 | 500 | 501 | 503;
            /** @description Message from server */
            message: string;
            /** @description Error code from server */
            error_code: string;
          };
        };
      };
    };
  };
  /**
   * Update dataset
   * @description Edit a dataset, currently limited to dataset renaming.
   */
  UpdateDatasetInfo: {
    parameters: {
      path: {
        /** @description The ID of the organization. */
        organization_id: string;
        /** @description The ID of the workspace. */
        workspace_id: string;
        /** @description The ID of the project. */
        project_id: string;
        /** @description The ID of the dataset in the project. */
        dataset_id: string;
      };
    };
    requestBody?: {
      content: {
        "application/json": {
          /** @description Dataset name */
          name?: string;
        };
      };
    };
    responses: {
      /** @description Updated info about dataset */
      200: {
        content: {
          "application/json": {
            /**
             * @description Mongo ID of the object
             * @example 60d31793d5f1fb7e6e3c1a4c
             */
            id?: string;
            /** @description Dataset name */
            name?: string;
            /** @description Whether dataset is used for training */
            use_for_training?: boolean;
            /** @description Creation time of the dataset */
            creation_time?: string;
          };
        };
      };
      /** @description Object not found. See the examples for details. */
      404: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 400 | 404 | 405 | 409 | 412 | 413 | 415 | 422 | 423 | 500 | 501 | 503;
            /** @description Message from server */
            message: string;
            /** @description Error code from server */
            error_code: string;
          };
        };
      };
      /** @description Dataset with same name already exists. */
      409: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 400 | 404 | 405 | 409 | 412 | 413 | 415 | 422 | 423 | 500 | 501 | 503;
            /** @description Message from server */
            message: string;
            /** @description Error code from server */
            error_code: string;
          };
        };
      };
    };
  };
  /**
   * Delete dataset
   * @description Delete dataset along with its media and annotations. Note that this operation is not reversible.
   */
  DeleteDataset: {
    parameters: {
      path: {
        /** @description The ID of the organization. */
        organization_id: string;
        /** @description The ID of the workspace. */
        workspace_id: string;
        /** @description The ID of the project. */
        project_id: string;
        /** @description The ID of the dataset in the project. */
        dataset_id: string;
      };
    };
    responses: {
      /** @description Dataset deleted successfully */
      200: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 200 | 201 | 202 | 203 | 204 | 205 | 206;
            /** @description Message from server */
            message: string;
          };
        };
      };
      /** @description Object not found. See the examples for details. */
      404: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 400 | 404 | 405 | 409 | 412 | 413 | 415 | 422 | 423 | 500 | 501 | 503;
            /** @description Message from server */
            message: string;
            /** @description Error code from server */
            error_code: string;
          };
        };
      };
    };
  };
  /**
   * Get statistics for a dataset
   * @description Retrieve the dataset statistics overview, this includes the number of images/videos, number of annotations, and number of objects per label.
   */
  GetDatasetStatistics: {
    parameters: {
      query?: {
        /**
         * @description Provide the task ID to get the statistics specifically for that task. For example in a task chain project,
         * if you are interested only in the statistics of the first task, you need to specify the ID of the first task.
         * The task ID can be found in the response body of the [project detail](#Projects/GetProjectInfo) endpoint.
         *
         * If no task id is provided, the response will contain statistics for all tasks in the project.
         */
        task_id?: string;
      };
      path: {
        /** @description The ID of the organization. */
        organization_id: string;
        /** @description The ID of the workspace. */
        workspace_id: string;
        /** @description The ID of the project. */
        project_id: string;
        /** @description The ID of the dataset in the project. */
        dataset_id: string;
      };
    };
    responses: {
      /** @description Statistics for the requested dataset */
      200: {
        content: {
          "application/json": {
            /** @description Overview of the dataset statistics */
            overview?: {
              /**
               * Format: int32
               * @description Number of images in the dataset
               */
              images?: number;
              /**
               * Format: int32
               * @description Number of videos in the dataset
               */
              videos?: number;
              /**
               * Format: int32
               * @description Number of annotated video frames in the dataset
               */
              annotated_frames?: number;
              /**
               * Format: int32
               * @description Number of annotated images in the dataset
               */
              annotated_images?: number;
              /**
               * Format: int32
               * @description Number of annotated videos in the dataset
               */
              annotated_videos?: number;
            };
            /** @description List with statistics for each task in the project */
            tasks?: {
                /**
                 * Format: int32
                 * @description Number of annotated frames per task
                 */
                annotated_frames?: number;
                /**
                 * Format: int32
                 * @description Number of annotated images per task
                 */
                annotated_images?: number;
                /**
                 * Format: int32
                 * @description Number of annotated videos per task
                 */
                annotated_videos?: number;
                /** @description Number of annotated shapes per label */
                objects_per_label?: {
                    /**
                     * @description Mongo ID of the object
                     * @example 60d31793d5f1fb7e6e3c1a4c
                     */
                    id?: string;
                    /** @description Name of the label */
                    name?: string;
                    /** @description Color of the label */
                    color?: string;
                    /**
                     * Format: int32
                     * @description Number of annotated shapes for this label
                     */
                    value?: number;
                  }[];
                /** @description List with information on object size distribution per label */
                object_size_distribution_per_label?: {
                    /** @description Mean x/y values of the sizes of the objects */
                    cluster_center?: number[];
                    /** @description Width/height values for drawing ellipse from cluster center */
                    cluster_width_height?: number[];
                    /**
                     * @description Mongo ID of the object
                     * @example 60d31793d5f1fb7e6e3c1a4c
                     */
                    id?: string;
                    /** @description Color of the label */
                    color?: string;
                    /** @description Name of the label */
                    name?: string;
                    /** @description Information on the distribution of aspect ratios of annotation shapes */
                    object_distribution_from_aspect_ratio?: {
                      /** Format: int32 */
                      balanced?: number;
                      /** Format: int32 */
                      tall?: number;
                      /** Format: int32 */
                      wide?: number;
                    };
                    /** @description Information on the size distribution of annotation shapes. Contains a list of width/height for every object. */
                    size_distribution?: number[][];
                    /**
                     * Format: float
                     * @description Aspect ratio threshold for classifying a shape as tall
                     */
                    aspect_ratio_threshold_tall?: number;
                    /**
                     * Format: float
                     * @description Aspect ratio threshold for classifying a shape as wide
                     */
                    aspect_ratio_threshold_wide?: number;
                  }[];
                /**
                 * @description Mongo ID of the object
                 * @example 60d31793d5f1fb7e6e3c1a4c
                 */
                task_id?: string;
              }[];
          };
        };
      };
      /** @description Object not found. See the examples for details. */
      404: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 400 | 404 | 405 | 409 | 412 | 413 | 415 | 422 | 423 | 500 | 501 | 503;
            /** @description Message from server */
            message: string;
            /** @description Error code from server */
            error_code: string;
          };
        };
      };
    };
  };
  /**
   * Retrieve media items with query
   * @description Retrieves media in the dataset that fulfill the filter condition.
   * The list of filter fields and their possible operators are shown below.
   * If a field-operation combination is not supported then the endpoint will respond with the possible operators that are allowed for the filter.
   * Note that this endpoint returns images and videos. To retrieve the video frames, use the video id returned by this endpoint and pass it to the
   * [video filtering](#Media/FilterVideoFrames) endpoint.
   *
   * | Filter fields | Supported operations | Value |
   * |--------------|----------------------|-------|
   * |`media_upload_date`, `annotation_creation_date` | `greater`, `less` | Isodate. Example: `2024-09-26T00:00:00+02:00` |
   * |`media_height`, `media_width`, `shape_area_percentage`, `shape_area_pixel`, `media_size`, `video_duration`, `video_frame_rate`, `video_frame_count` | `greater`, `greater_or_equal`, `less`, `less_or_equal`, `equal`, `not_equal` | integer |
   * |`media_name` | `equal`, `not_equal`, `contains` | string |
   * |`label_id`, `shape_type`, `user_name` | `equal`, `not_equal`, `in`, `not_in` | string (id format) |
   * |`annotation_scene_state` | `equal`, `not_equal`, `in` | string (enum: `annotated`, `partially_annotated`, `unannotated`) |
   * |`media_type` | `equal`, `not_equal` | string |
   */
  FilterMedia: {
    parameters: {
      query?: {
        /** @description Number of items returned in the response. Default is 10 and maximum is 100. */
        limit?: number;
        /**
         * @description Number indicating how many items to skip from the first item that matches the query.
         * This field is used in combination with the limit field for the pagination feature.
         */
        skip?: string;
        /** @description Sorting order, could be `asc` (ascending) or `dsc` (descending). */
        sort_direction?: "asc" | "dsc";
        /** @description Field to sort by. */
        sort_by?: "media_name" | "media_upload_date" | "media_width" | "media_height" | "media_size" | "annotation_creation_date";
      };
      path: {
        /** @description The ID of the organization. */
        organization_id: string;
        /** @description The ID of the workspace. */
        workspace_id: string;
        /** @description The ID of the project. */
        project_id: string;
        /** @description The ID of the dataset in the project. */
        dataset_id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": {
          /**
           * @description Condition to apply to group of rules.
           * @enum {string}
           */
          condition?: "and";
          /** @description All the rules to filter a dataset with. */
          rules: ({
              /**
               * @description Field to filter on in the database. Can be one of 'media_upload_date', 'media_height', 'media_width' , 'media_name', 'label_id', 'annotation_creation_date', 'annotation_scene_state', 'shape_type', 'shape_size' or 'user_name'. Note that media related filters do not affect the outcome when using the filter video endpoint as each frame will have the same values.
               * @enum {string}
               */
              field: "media_upload_date" | "media_height" | "media_width" | "media_name" | "label_id" | "annotation_creation_date" | "annotation_scene_state" | "shape_type" | "shape_area_percentage" | "shape_area_pixel" | "user_name";
              /**
               * @description Operator to filter with. Can be one of 'greater', 'less', 'greater_or_equal' , 'less_or_equal', 'equal', 'not_equal', 'in', 'not_in', 'regex'
               * @enum {string}
               */
              operator: "greater" | "less" | "greater_or_equal" | "less_or_equal" | "equal" | "not_equal" | "in" | "not_in" | "regex";
              /** @description Value that the field should match to in combination with the operator */
              value: unknown[] | string | number;
            })[];
        };
      };
    };
    responses: {
      /** @description Media items matching the filter */
      200: {
        content: {
          "application/json": {
            /** @description List of media items */
            media?: (OneOf<[{
                /**
                 * @description Mongo ID of the object
                 * @example 60d31793d5f1fb7e6e3c1a4c
                 */
                id?: string;
                media_information?: {
                  /** @description Display URL of the image or video frame */
                  display_url?: string;
                  /** @description Height of the image or video frame */
                  height?: number;
                  /** @description Width of the image or video frame */
                  width?: number;
                  /** @description Size of the image or video in bytes */
                  size?: number;
                  /** @description Extension of the image or video in lowercase with a dot (e.g. '.jpg') */
                  extension?: string;
                };
                /** @description Name of the image */
                name?: string;
                /** @description List of per-task states obtained aggregating the annotation state with the revisit information */
                annotation_state_per_task?: ({
                    /**
                     * @description Mongo ID of the object
                     * @example 60d31793d5f1fb7e6e3c1a4c
                     */
                    task_id?: string;
                    /**
                     * @description Annotation state of the media for this task
                     * @enum {string|null}
                     */
                    state?: "annotated" | "partially_annotated" | "none" | "to_revisit" | null;
                  })[];
                /** @description Relative URL to the image thumbnail */
                thumbnail?: string;
                /**
                 * @description Type of media. 'image' for images, 'video' for video and 'video_frame' for video frames.
                 * @enum {string}
                 */
                type?: "image";
                /** @description Upload time of the media file */
                upload_time?: string;
                /** @description Optional ID of the annotation scene  if filtering in a specific training revision */
                annotation_scene_id?: string;
                /** @description Optional ID of the roi id if filtering in a specific training revision */
                roi_id?: string;
                /** @description Optional ID of the user that last edited the annotation. */
                last_annotator_id?: string;
              }, {
                /**
                 * @description Mongo ID of the object
                 * @example 60d31793d5f1fb7e6e3c1a4c
                 */
                id?: string;
                media_information?: {
                  /** @description Display URL of the image or video */
                  display_url?: string;
                  /** @description Duration of the video */
                  duration?: number;
                  /** @description Number of frames in the video */
                  frame_count?: number;
                  /** @description Frame stride of the video */
                  frame_stride?: number;
                  /** @description Frame rate of the video */
                  frame_rate?: number;
                  /** @description Height of the video */
                  height?: number;
                  /** @description Width of the video */
                  width?: number;
                  /** @description Size of the video in bytes */
                  size?: number;
                };
                /** @description Name of the image */
                name?: string;
                /** @description List of per-task states obtained aggregating the annotation state with the revisit information */
                annotation_state_per_task?: ({
                    /**
                     * @description Mongo ID of the object
                     * @example 60d31793d5f1fb7e6e3c1a4c
                     */
                    task_id?: string;
                    /**
                     * @description Annotation state of the media for this task
                     * @enum {string|null}
                     */
                    state?: "annotated" | "partially_annotated" | "none" | "to_revisit" | null;
                  })[];
                /** @description Relative URL to the video thumbnail */
                thumbnail?: string;
                /**
                 * @description Type of media. 'image' for images, 'video' for video and 'video_frame' for video frames.
                 * @enum {string}
                 */
                type?: "video";
                /** @description Upload time of the media file */
                upload_time?: string;
                /** @description Number of frames in the video that match the filter. Only returned when filtering by annotation properties. */
                matched_frames?: number | null;
              }, {
                /**
                 * Format: int32
                 * @description The video frame index
                 */
                id?: number;
                media_information?: {
                  /** @description Display URL of the image or video */
                  display_url?: string;
                  /** @description Duration of the video */
                  duration?: number;
                  /** @description Number of frames in the video */
                  frame_count?: number;
                  /** @description Frame stride of the video */
                  frame_stride?: number;
                  /** @description Frame rate of the video */
                  frame_rate?: number;
                  /** @description Height of the video */
                  height?: number;
                  /** @description Width of the video */
                  width?: number;
                  /** @description Size of the video in bytes */
                  size?: number;
                };
                /** @description Name of the image */
                name?: string;
                /** @description List of per-task states obtained aggregating the annotation state with the revisit information */
                annotation_state_per_task?: ({
                    /**
                     * @description Mongo ID of the object
                     * @example 60d31793d5f1fb7e6e3c1a4c
                     */
                    task_id?: string;
                    /**
                     * @description Annotation state of the media for this task
                     * @enum {string|null}
                     */
                    state?: "annotated" | "partially_annotated" | "none" | "to_revisit" | null;
                  })[];
                /** @description Relative URL to the video frame thumbnail */
                thumbnail?: string;
                /**
                 * @description Type of media. 'image' for images, 'video' for video and 'video_frame' for video frames.
                 * @enum {string}
                 */
                type?: "video_frame";
                /** @description Upload time of the media file */
                upload_time?: string;
                /** @description Optional ID of the annotation scene if filtering in a specific training revision */
                annotation_scene_id?: string;
                /** @description Optional ID of the roi id if filtering in a specific training revision */
                roi_id?: string;
                /** @description Optional ID of the user that last edited the annotation. */
                last_annotator_id?: string;
              }]>)[];
            /** @description URL to the next page of results, if the same parameters are used. */
            next_page?: string;
            /** @description Total images that match the query. */
            total_matched_images?: number;
            /** @description Total videos that match the query. */
            total_matched_videos?: number;
            /** @description Total video frames that match the query. */
            total_matched_video_frames?: number;
            /** @description Total images in the dataset. */
            total_images?: number;
            /** @description Total videos in the dataset. */
            total_videos?: number;
          };
        };
      };
      /** @description Bad request. See the examples for details. */
      400: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 400 | 404 | 405 | 409 | 412 | 413 | 415 | 422 | 423 | 500 | 501 | 503;
            /** @description Message from server */
            message: string;
            /** @description Error code from server */
            error_code: string;
          };
        };
      };
      /** @description Object not found. See the examples for details. */
      404: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 400 | 404 | 405 | 409 | 412 | 413 | 415 | 422 | 423 | 500 | 501 | 503;
            /** @description Message from server */
            message: string;
            /** @description Error code from server */
            error_code: string;
          };
        };
      };
    };
  };
  /**
   * Upload an image
   * @description Upload an image to a dataset. Allowed formats are `.jpg`, `.jpeg`, `.bmp`, `.png`, `.tif`, `.tiff`, `.jfif`, and `.webp`. Height and
   * width of the images must be between 32 and 20000 pixels.
   * For a classification project, the uploaded image can be annotated directly by specifying the labels in the field `upload_info`.
   */
  UploadImage: {
    parameters: {
      path: {
        /** @description The ID of the organization. */
        organization_id: string;
        /** @description The ID of the workspace. */
        workspace_id: string;
        /** @description The ID of the project. */
        project_id: string;
        /** @description The ID of the dataset in the project. */
        dataset_id: string;
      };
    };
    requestBody?: {
      content: {
        "multipart/form-data": {
          /**
           * Format: binary
           * @description The image file to be uploaded.
           */
          file: string;
          /**
           * @description IDs of the labels to apply to the image. Uses the format of a json decodable string.
           * The label id's could be found from the response of the [project detail](#Projects/GetProjectInfo) endpoint.
           * Example: *{\"label_ids\":[\"613776cec8223e455a88383d\", \"613776cec8223e455a88383e\"]}*.
           */
          upload_info?: string;
        };
      };
    };
    responses: {
      /** @description The image has been uploaded. The 'size' field represents bits. */
      200: {
        content: {
          "application/json": {
            /**
             * @description Mongo ID of the object
             * @example 60d31793d5f1fb7e6e3c1a4c
             */
            id?: string;
            media_information?: {
              /** @description Display URL of the image or video frame */
              display_url?: string;
              /** @description Height of the image or video frame */
              height?: number;
              /** @description Width of the image or video frame */
              width?: number;
              /** @description Size of the image or video in bytes */
              size?: number;
              /** @description Extension of the image or video in lowercase with a dot (e.g. '.jpg') */
              extension?: string;
            };
            /** @description Name of the image */
            name?: string;
            /** @description ID of the uploader */
            uploader_id?: string;
            /** @description List of per-task states obtained aggregating the annotation state with the revisit information */
            annotation_state_per_task?: ({
                /**
                 * @description Mongo ID of the object
                 * @example 60d31793d5f1fb7e6e3c1a4c
                 */
                task_id?: string;
                /**
                 * @description Annotation state of the media for this task
                 * @enum {string|null}
                 */
                state?: "annotated" | "partially_annotated" | "none" | "to_revisit" | null;
              })[];
            /** @description Media preprocessing related information */
            preprocessing?: {
              /**
               * @description Status of the preprocessing operation
               * @enum {string}
               */
              status: "SCHEDULED" | "IN_PROGRESS" | "FINISHED" | "FAILED";
              /** @description Message associated with the preprocessing operation */
              message?: string;
            };
            /** @description Relative URL to the media thumbnail */
            thumbnail?: string;
            /**
             * @description Type of media. 'image', 'video' or 'video_frame'
             * @enum {string}
             */
            type?: "image";
            /** @description Upload time of the image */
            upload_time?: string;
          };
        };
      };
      /** @description No file provided */
      400: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 400 | 404 | 405 | 409 | 412 | 413 | 415 | 422 | 423 | 500 | 501 | 503;
            /** @description Message from server */
            message: string;
            /** @description Error code from server */
            error_code: string;
          };
        };
      };
      /** @description Object not found. See the examples for details. */
      404: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 400 | 404 | 405 | 409 | 412 | 413 | 415 | 422 | 423 | 500 | 501 | 503;
            /** @description Message from server */
            message: string;
            /** @description Error code from server */
            error_code: string;
          };
        };
      };
      /** @description Payload too large */
      413: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 400 | 404 | 405 | 409 | 412 | 413 | 415 | 422 | 423 | 500 | 501 | 503;
            /** @description Message from server */
            message: string;
            /** @description Error code from server */
            error_code: string;
          };
        };
      };
      /** @description Invalid media */
      415: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 400 | 404 | 405 | 409 | 412 | 413 | 415 | 422 | 423 | 500 | 501 | 503;
            /** @description Message from server */
            message: string;
            /** @description Error code from server */
            error_code: string;
          };
        };
      };
    };
  };
  /**
   * Get image detail
   * @description Retrieves detailed information of an image.
   */
  GetImageDetail: {
    parameters: {
      path: {
        /** @description The ID of the organization. */
        organization_id: string;
        /** @description The ID of the workspace. */
        workspace_id: string;
        /** @description The ID of the project. */
        project_id: string;
        /** @description The ID of the dataset in the project. */
        dataset_id: string;
        /** @description The ID of the image. */
        image_id: string;
      };
    };
    responses: {
      /** @description The detailed info of the requested image. The "size" field represents bits. */
      200: {
        content: {
          "application/json": {
            /**
             * @description Mongo ID of the object
             * @example 60d31793d5f1fb7e6e3c1a4c
             */
            id?: string;
            media_information?: {
              /** @description Display URL of the image or video frame */
              display_url?: string;
              /** @description Height of the image or video frame */
              height?: number;
              /** @description Width of the image or video frame */
              width?: number;
              /** @description Size of the image or video in bytes */
              size?: number;
              /** @description Extension of the image or video in lowercase with a dot (e.g. '.jpg') */
              extension?: string;
            };
            /** @description Name of the image */
            name?: string;
            /** @description ID of the uploader */
            uploader_id?: string;
            /** @description List of per-task states obtained aggregating the annotation state with the revisit information */
            annotation_state_per_task?: ({
                /**
                 * @description Mongo ID of the object
                 * @example 60d31793d5f1fb7e6e3c1a4c
                 */
                task_id?: string;
                /**
                 * @description Annotation state of the media for this task
                 * @enum {string|null}
                 */
                state?: "annotated" | "partially_annotated" | "none" | "to_revisit" | null;
              })[];
            /** @description Media preprocessing related information */
            preprocessing?: {
              /**
               * @description Status of the preprocessing operation
               * @enum {string}
               */
              status: "SCHEDULED" | "IN_PROGRESS" | "FINISHED" | "FAILED";
              /** @description Message associated with the preprocessing operation */
              message?: string;
            };
            /** @description Relative URL to the media thumbnail */
            thumbnail?: string;
            /**
             * @description Type of media. 'image', 'video' or 'video_frame'
             * @enum {string}
             */
            type?: "image";
            /** @description Upload time of the image */
            upload_time?: string;
          };
        };
      };
      /** @description Object not found. See the examples for details. */
      404: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 400 | 404 | 405 | 409 | 412 | 413 | 415 | 422 | 423 | 500 | 501 | 503;
            /** @description Message from server */
            message: string;
            /** @description Error code from server */
            error_code: string;
          };
        };
      };
    };
  };
  /**
   * Delete an image
   * @description Delete an image from a dataset. This operation is not reversible.
   */
  DeleteAnImage: {
    parameters: {
      path: {
        /** @description The ID of the organization. */
        organization_id: string;
        /** @description The ID of the workspace. */
        workspace_id: string;
        /** @description The ID of the project. */
        project_id: string;
        /** @description The ID of the dataset in the project. */
        dataset_id: string;
        /** @description The ID of the image. */
        image_id: string;
      };
    };
    responses: {
      /** @description The image has been deleted */
      200: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 200 | 201 | 202 | 203 | 204 | 205 | 206;
            /** @description Message from server */
            message: string;
          };
        };
      };
      /** @description Object not found. See the examples for details. */
      404: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 400 | 404 | 405 | 409 | 412 | 413 | 415 | 422 | 423 | 500 | 501 | 503;
            /** @description Message from server */
            message: string;
            /** @description Error code from server */
            error_code: string;
          };
        };
      };
      /** @description Requested image cannot be deleted due to running jobs connected to this image */
      409: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 400 | 404 | 405 | 409 | 412 | 413 | 415 | 422 | 423 | 500 | 501 | 503;
            /** @description Message from server */
            message: string;
            /** @description Error code from server */
            error_code: string;
          };
        };
      };
    };
  };
  /**
   * Download full image
   * @description Download the image in the original resolution.
   */
  DownloadFullImage: {
    parameters: {
      path: {
        /** @description The ID of the organization. */
        organization_id: string;
        /** @description The ID of the workspace. */
        workspace_id: string;
        /** @description The ID of the project. */
        project_id: string;
        /** @description The ID of the dataset in the project. */
        dataset_id: string;
        /** @description The ID of the image. */
        image_id: string;
      };
    };
    responses: {
      /** @description The requested image */
      200: {
        content: {
          "image/*": string;
        };
      };
      /** @description Object not found. See the examples for details. */
      404: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 400 | 404 | 405 | 409 | 412 | 413 | 415 | 422 | 423 | 500 | 501 | 503;
            /** @description Message from server */
            message: string;
            /** @description Error code from server */
            error_code: string;
          };
        };
      };
      /** @description Internal server error */
      500: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 400 | 404 | 405 | 409 | 412 | 413 | 415 | 422 | 423 | 500 | 501 | 503;
            /** @description Message from server */
            message: string;
            /** @description Error code from server */
            error_code: string;
          };
        };
      };
    };
  };
  /**
   * Download the thumbnail of an image
   * @description Download the thumbnail version of an image.
   */
  DownloadImageThumbnail: {
    parameters: {
      path: {
        /** @description The ID of the organization. */
        organization_id: string;
        /** @description The ID of the workspace. */
        workspace_id: string;
        /** @description The ID of the project. */
        project_id: string;
        /** @description The ID of the dataset in the project. */
        dataset_id: string;
        /** @description The ID of the image. */
        image_id: string;
      };
    };
    responses: {
      /** @description The requested image thumbnail */
      200: {
        content: {
          "image/*": string;
        };
      };
      /** @description Object not found. See the examples for details. */
      404: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 400 | 404 | 405 | 409 | 412 | 413 | 415 | 422 | 423 | 500 | 501 | 503;
            /** @description Message from server */
            message: string;
            /** @description Error code from server */
            error_code: string;
          };
        };
      };
      /** @description Internal server error */
      500: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 400 | 404 | 405 | 409 | 412 | 413 | 415 | 422 | 423 | 500 | 501 | 503;
            /** @description Message from server */
            message: string;
            /** @description Error code from server */
            error_code: string;
          };
        };
      };
    };
  };
  /**
   * Upload a video
   * @description Upload a video to a dataset. Allowed formats are `.mp4`, `.avi`, `.mkv` `.mov`, `.webm` and `.m4v`. The maximum resolution for
   * videos is 8K and the file may not be larger than 4.7 GB. For a classification project, all frames of the uploaded
   * video can be annotated directly by specifying the labels in the field upload_info.
   */
  UploadVideo: {
    parameters: {
      path: {
        /** @description The ID of the organization. */
        organization_id: string;
        /** @description The ID of the workspace. */
        workspace_id: string;
        /** @description The ID of the project. */
        project_id: string;
        /** @description The ID of the dataset in the project. */
        dataset_id: string;
      };
    };
    requestBody?: {
      content: {
        "multipart/form-data": {
          /**
           * Format: binary
           * @description The video file to be uploaded.
           */
          file: string;
          /**
           * @description IDs of the labels to apply to the video. Uses the format of a json decodable string.
           * The label id's could be found from the response of the [project detail](#Projects/GetProjectInfo) endpoint.
           * Labels are applied to all video frames at 1 fps.
           * Example: *{\"label_ids\":[\"613776cec8223e455a88383d\", \"613776cec8223e455a88383e\"]}*.
           */
          upload_info?: string;
        };
      };
    };
    responses: {
      /** @description Video has been uploaded. The 'size' field represents bits, "duration" is in seconds. */
      200: {
        content: {
          "application/json": {
            /**
             * @description Mongo ID of the object
             * @example 60d31793d5f1fb7e6e3c1a4c
             */
            id?: string;
            media_information?: {
              /** @description Display URL of the image or video */
              display_url?: string;
              /** @description Duration of the video */
              duration?: number;
              /** @description Number of frames in the video */
              frame_count?: number;
              /** @description Frame stride of the video */
              frame_stride?: number;
              /** @description Frame rate of the video */
              frame_rate?: number;
              /** @description Height of the video */
              height?: number;
              /** @description Width of the video */
              width?: number;
              /** @description Size of the video in bytes */
              size?: number;
            };
            /** @description Name of the video */
            name?: string;
            /** @description ID of the uploader */
            uploader_id?: string;
            /** @description List of per-task states obtained aggregating the annotation state with the revisit information */
            annotation_state_per_task?: ({
                /**
                 * @description Mongo ID of the object
                 * @example 60d31793d5f1fb7e6e3c1a4c
                 */
                task_id?: string;
                /**
                 * @description Annotation state of the media for this task
                 * @enum {string|null}
                 */
                state?: "annotated" | "partially_annotated" | "none" | "to_revisit" | null;
              })[];
            annotation_statistics?: {
              /** @description Number of annotated frames within video */
              annotated?: number;
              /** @description Number of partially annotated frames within video */
              partially_annotated?: number;
              /** @description Number of unannotated frames within video */
              unannotated?: number;
            };
            /** @description Media preprocessing related information */
            preprocessing?: {
              /**
               * @description Status of the preprocessing operation
               * @enum {string}
               */
              status: "SCHEDULED" | "IN_PROGRESS" | "FINISHED" | "FAILED";
              /** @description Message associated with the preprocessing operation */
              message?: string;
            };
            /** @description Relative URL to the video thumbnail */
            thumbnail?: string;
            /**
             * @description Type of media. 'image', 'video' or 'video_frame'
             * @enum {string}
             */
            type?: "video";
            /** @description Upload time of the video */
            upload_time?: string;
          };
        };
      };
      /** @description No file provided */
      400: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 400 | 404 | 405 | 409 | 412 | 413 | 415 | 422 | 423 | 500 | 501 | 503;
            /** @description Message from server */
            message: string;
            /** @description Error code from server */
            error_code: string;
          };
        };
      };
      /** @description Object not found. See the examples for details. */
      404: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 400 | 404 | 405 | 409 | 412 | 413 | 415 | 422 | 423 | 500 | 501 | 503;
            /** @description Message from server */
            message: string;
            /** @description Error code from server */
            error_code: string;
          };
        };
      };
      /** @description Payload too large */
      413: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 400 | 404 | 405 | 409 | 412 | 413 | 415 | 422 | 423 | 500 | 501 | 503;
            /** @description Message from server */
            message: string;
            /** @description Error code from server */
            error_code: string;
          };
        };
      };
      /** @description Invalid media */
      415: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 400 | 404 | 405 | 409 | 412 | 413 | 415 | 422 | 423 | 500 | 501 | 503;
            /** @description Message from server */
            message: string;
            /** @description Error code from server */
            error_code: string;
          };
        };
      };
    };
  };
  /**
   * Get video detail
   * @description Retrieves the detail of a video.
   */
  GetVideoDetail: {
    parameters: {
      path: {
        /** @description The ID of the organization. */
        organization_id: string;
        /** @description The ID of the workspace. */
        workspace_id: string;
        /** @description The ID of the project. */
        project_id: string;
        /** @description The ID of the dataset in the project. */
        dataset_id: string;
        /** @description The ID of the video. */
        video_id: string;
      };
    };
    responses: {
      /** @description The requested detailed video info. The 'size' field represents bits, "duration" is in seconds. */
      200: {
        content: {
          "application/json": {
            /**
             * @description Mongo ID of the object
             * @example 60d31793d5f1fb7e6e3c1a4c
             */
            id?: string;
            media_information?: {
              /** @description Display URL of the image or video */
              display_url?: string;
              /** @description Duration of the video */
              duration?: number;
              /** @description Number of frames in the video */
              frame_count?: number;
              /** @description Frame stride of the video */
              frame_stride?: number;
              /** @description Frame rate of the video */
              frame_rate?: number;
              /** @description Height of the video */
              height?: number;
              /** @description Width of the video */
              width?: number;
              /** @description Size of the video in bytes */
              size?: number;
            };
            /** @description Name of the video */
            name?: string;
            /** @description ID of the uploader */
            uploader_id?: string;
            /** @description List of per-task states obtained aggregating the annotation state with the revisit information */
            annotation_state_per_task?: ({
                /**
                 * @description Mongo ID of the object
                 * @example 60d31793d5f1fb7e6e3c1a4c
                 */
                task_id?: string;
                /**
                 * @description Annotation state of the media for this task
                 * @enum {string|null}
                 */
                state?: "annotated" | "partially_annotated" | "none" | "to_revisit" | null;
              })[];
            annotation_statistics?: {
              /** @description Number of annotated frames within video */
              annotated?: number;
              /** @description Number of partially annotated frames within video */
              partially_annotated?: number;
              /** @description Number of unannotated frames within video */
              unannotated?: number;
            };
            /** @description Media preprocessing related information */
            preprocessing?: {
              /**
               * @description Status of the preprocessing operation
               * @enum {string}
               */
              status: "SCHEDULED" | "IN_PROGRESS" | "FINISHED" | "FAILED";
              /** @description Message associated with the preprocessing operation */
              message?: string;
            };
            /** @description Relative URL to the video thumbnail */
            thumbnail?: string;
            /**
             * @description Type of media. 'image', 'video' or 'video_frame'
             * @enum {string}
             */
            type?: "video";
            /** @description Upload time of the video */
            upload_time?: string;
          };
        };
      };
      /** @description Object not found. See the examples for details. */
      404: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 400 | 404 | 405 | 409 | 412 | 413 | 415 | 422 | 423 | 500 | 501 | 503;
            /** @description Message from server */
            message: string;
            /** @description Error code from server */
            error_code: string;
          };
        };
      };
    };
  };
  /**
   * Delete a video
   * @description Delete a video from a dataset. This operation is not reversible.
   */
  DeleteAVideo: {
    parameters: {
      path: {
        /** @description The ID of the organization. */
        organization_id: string;
        /** @description The ID of the workspace. */
        workspace_id: string;
        /** @description The ID of the project. */
        project_id: string;
        /** @description The ID of the dataset in the project. */
        dataset_id: string;
        /** @description The ID of the video. */
        video_id: string;
      };
    };
    responses: {
      /** @description The video was successfully deleted */
      200: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 200 | 201 | 202 | 203 | 204 | 205 | 206;
            /** @description Message from server */
            message: string;
          };
        };
      };
      /** @description Object not found. See the examples for details. */
      404: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 400 | 404 | 405 | 409 | 412 | 413 | 415 | 422 | 423 | 500 | 501 | 503;
            /** @description Message from server */
            message: string;
            /** @description Error code from server */
            error_code: string;
          };
        };
      };
      /** @description Requested video cannot be deleted due to running jobs connected to the video */
      409: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 400 | 404 | 405 | 409 | 412 | 413 | 415 | 422 | 423 | 500 | 501 | 503;
            /** @description Message from server */
            message: string;
            /** @description Error code from server */
            error_code: string;
          };
        };
      };
    };
  };
  /**
   * Retrieve specific frames from a video by applying a query on the dataset
   * @description Retrieves video frames from a video which fulfill the filter condition.
   * The list of filter fields and their possible operators are shown below.
   * If a field-operation combination is not supported then the endpoint will respond with the possible operators that are allowed for the filter.
   *
   * | Filter fields | Supported operations | Value |
   * |--------------|----------------------|-------|
   * |`annotation_creation_date` | `greater`, `less` | Isodate. Example: `2024-09-26T00:00:00+02:00` |
   * |`shape_area_percentage`, `shape_area_pixel` | `greater`, `greater_or_equal`, `less`, `less_or_equal`, `equal`, `not_equal` | integer |
   * |`label_id`, `shape_type`, `user_name` | `equal`, `not_equal`, `in`, `not_in` | string (id format) |
   * |`annotation_scene_state` | `equal`, `not_equal`, `in` | string (enum: `annotated`, `partially_annotated`, `unannotated`) |
   */
  FilterVideoFrames: {
    parameters: {
      query?: {
        /** @description Number of items returned in the response. Default is 10 and maximum is 100. */
        limit?: number;
        /**
         * @description Number indicating how many items to skip from the first item that matches the query.
         * This field is used in combination with the limit field for the pagination feature.
         */
        skip?: string;
        /** @description Sorting order, could be `asc` (ascending) or `dsc` (descending). */
        sort_direction?: "asc" | "dsc";
        /** @description Field to sort by. */
        sort_by?: "media_name" | "media_upload_date" | "media_width" | "media_height" | "media_size" | "annotation_creation_date";
        /**
         * @description Set to true to include the frame details in the response. Note that this will increase the response size.
         * Default is `false`.
         */
        include_frame_details?: boolean;
      };
      path: {
        /** @description The ID of the organization. */
        organization_id: string;
        /** @description The ID of the workspace. */
        workspace_id: string;
        /** @description The ID of the project. */
        project_id: string;
        /** @description The ID of the dataset in the project. */
        dataset_id: string;
        /** @description The ID of the video. */
        video_id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": {
          /**
           * @description Condition to apply to group of rules.
           * @enum {string}
           */
          condition?: "and";
          /** @description All the rules to filter a dataset with. */
          rules: ({
              /**
               * @description Field to filter on in the database. Can be one of 'media_upload_date', 'media_height', 'media_width' , 'media_name', 'label_id', 'annotation_creation_date', 'annotation_scene_state', 'shape_type', 'shape_size' or 'user_name'. Note that media related filters do not affect the outcome when using the filter video endpoint as each frame will have the same values.
               * @enum {string}
               */
              field: "media_upload_date" | "media_height" | "media_width" | "media_name" | "label_id" | "annotation_creation_date" | "annotation_scene_state" | "shape_type" | "shape_area_percentage" | "shape_area_pixel" | "user_name";
              /**
               * @description Operator to filter with. Can be one of 'greater', 'less', 'greater_or_equal' , 'less_or_equal', 'equal', 'not_equal', 'in', 'not_in', 'regex'
               * @enum {string}
               */
              operator: "greater" | "less" | "greater_or_equal" | "less_or_equal" | "equal" | "not_equal" | "in" | "not_in" | "regex";
              /** @description Value that the field should match to in combination with the operator */
              value: unknown[] | string | number;
            })[];
        };
      };
    };
    responses: {
      /** @description Frames matching the filter */
      200: {
        content: {
          "application/json": {
            /** @description List of video frame indices */
            video_frame_indices?: number[];
            /** @description List of video frame items */
            video_frames?: ({
                /**
                 * Format: int32
                 * @description The video frame index
                 */
                id?: number;
                media_information?: {
                  /** @description Display URL of the image or video */
                  display_url?: string;
                  /** @description Duration of the video */
                  duration?: number;
                  /** @description Number of frames in the video */
                  frame_count?: number;
                  /** @description Frame stride of the video */
                  frame_stride?: number;
                  /** @description Frame rate of the video */
                  frame_rate?: number;
                  /** @description Height of the video */
                  height?: number;
                  /** @description Width of the video */
                  width?: number;
                  /** @description Size of the video in bytes */
                  size?: number;
                };
                /** @description Name of the image */
                name?: string;
                /** @description List of per-task states obtained aggregating the annotation state with the revisit information */
                annotation_state_per_task?: ({
                    /**
                     * @description Mongo ID of the object
                     * @example 60d31793d5f1fb7e6e3c1a4c
                     */
                    task_id?: string;
                    /**
                     * @description Annotation state of the media for this task
                     * @enum {string|null}
                     */
                    state?: "annotated" | "partially_annotated" | "none" | "to_revisit" | null;
                  })[];
                /** @description Relative URL to the video frame thumbnail */
                thumbnail?: string;
                /**
                 * @description Type of media. 'image' for images, 'video' for video and 'video_frame' for video frames.
                 * @enum {string}
                 */
                type?: "video_frame";
                /** @description Upload time of the media file */
                upload_time?: string;
                /** @description Optional ID of the annotation scene if filtering in a specific training revision */
                annotation_scene_id?: string;
                /** @description Optional ID of the roi id if filtering in a specific training revision */
                roi_id?: string;
                /** @description Optional ID of the user that last edited the annotation. */
                last_annotator_id?: string;
              })[];
            video_information?: {
              /** @description Display URL of the image or video */
              display_url?: string;
              /** @description Duration of the video */
              duration?: number;
              /** @description Number of frames in the video */
              frame_count?: number;
              /** @description Frame stride of the video */
              frame_stride?: number;
              /** @description Frame rate of the video */
              frame_rate?: number;
              /** @description Height of the video */
              height?: number;
              /** @description Width of the video */
              width?: number;
              /** @description Size of the video in bytes */
              size?: number;
            };
            /** @description URL to the next page of results, if the same parameters are used. */
            next_page?: string;
            /** @description Total video frames that match the query. */
            total_matched_video_frames?: number;
          };
        };
      };
      /** @description Bad request. See the examples for details. */
      400: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 400 | 404 | 405 | 409 | 412 | 413 | 415 | 422 | 423 | 500 | 501 | 503;
            /** @description Message from server */
            message: string;
            /** @description Error code from server */
            error_code: string;
          };
        };
      };
      /** @description Object not found. See the examples for details. */
      404: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 400 | 404 | 405 | 409 | 412 | 413 | 415 | 422 | 423 | 500 | 501 | 503;
            /** @description Message from server */
            message: string;
            /** @description Error code from server */
            error_code: string;
          };
        };
      };
    };
  };
  /**
   * Download video stream
   * @description Download the video stream in original resolution.
   */
  DownloadVideoStream: {
    parameters: {
      path: {
        /** @description The ID of the organization. */
        organization_id: string;
        /** @description The ID of the workspace. */
        workspace_id: string;
        /** @description The ID of the project. */
        project_id: string;
        /** @description The ID of the dataset in the project. */
        dataset_id: string;
        /** @description The ID of the video. */
        video_id: string;
      };
    };
    responses: {
      /** @description The requested video stream */
      200: {
        content: {
          "image/*": string;
        };
      };
      /** @description Object not found. See the examples for details. */
      404: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 400 | 404 | 405 | 409 | 412 | 413 | 415 | 422 | 423 | 500 | 501 | 503;
            /** @description Message from server */
            message: string;
            /** @description Error code from server */
            error_code: string;
          };
        };
      };
    };
  };
  /**
   * Download the thumbnail for a video
   * @description Download the thumbnail of a video.
   * The video thumbnail is the downscaled version of a frame from the middle of the video.
   */
  DownloadVideoThumbnail: {
    parameters: {
      path: {
        /** @description The ID of the organization. */
        organization_id: string;
        /** @description The ID of the workspace. */
        workspace_id: string;
        /** @description The ID of the project. */
        project_id: string;
        /** @description The ID of the dataset in the project. */
        dataset_id: string;
        /** @description The ID of the video. */
        video_id: string;
      };
    };
    responses: {
      /** @description The requested video thumbnail */
      200: {
        content: {
          "image/*": string;
        };
      };
      /** @description Object not found. See the examples for details. */
      404: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 400 | 404 | 405 | 409 | 412 | 413 | 415 | 422 | 423 | 500 | 501 | 503;
            /** @description Message from server */
            message: string;
            /** @description Error code from server */
            error_code: string;
          };
        };
      };
      /** @description Internal server error */
      500: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 400 | 404 | 405 | 409 | 412 | 413 | 415 | 422 | 423 | 500 | 501 | 503;
            /** @description Message from server */
            message: string;
            /** @description Error code from server */
            error_code: string;
          };
        };
      };
    };
  };
  /**
   * Download a video frame
   * @description Download a video frame in original resolution.
   */
  DownloadVideoFrameFull: {
    parameters: {
      path: {
        /** @description The ID of the organization. */
        organization_id: string;
        /** @description The ID of the workspace. */
        workspace_id: string;
        /** @description The ID of the project. */
        project_id: string;
        /** @description The ID of the dataset in the project. */
        dataset_id: string;
        /** @description The ID of the video. */
        video_id: string;
        /**
         * @description This is a 0-based index, meaning to retrieve the first frame of the video, this parameter should be set to `0`.
         * The possible values for this parameter range from `0` to `frame_count-1`. The `frame_count` is the total number of frames contained in the video
         * and it can be retrieved from the response body of [video detail](#Media/GetVideoDetail) endpoint.
         */
        frame_index: number;
      };
    };
    responses: {
      /** @description The requested video */
      200: {
        content: {
          "image/*": string;
        };
      };
      /** @description Object not found. See the examples for details. */
      404: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 400 | 404 | 405 | 409 | 412 | 413 | 415 | 422 | 423 | 500 | 501 | 503;
            /** @description Message from server */
            message: string;
            /** @description Error code from server */
            error_code: string;
          };
        };
      };
      /** @description Internal server error */
      500: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 400 | 404 | 405 | 409 | 412 | 413 | 415 | 422 | 423 | 500 | 501 | 503;
            /** @description Message from server */
            message: string;
            /** @description Error code from server */
            error_code: string;
          };
        };
      };
    };
  };
  /**
   * Download a thumbnail for a video frame
   * @description Download a video frame thumbnail.
   */
  DownloadVideoFrameThumbnail: {
    parameters: {
      path: {
        /** @description The ID of the organization. */
        organization_id: string;
        /** @description The ID of the workspace. */
        workspace_id: string;
        /** @description The ID of the project. */
        project_id: string;
        /** @description The ID of the dataset in the project. */
        dataset_id: string;
        /** @description The ID of the video. */
        video_id: string;
        /**
         * @description This is a 0-based index, meaning to retrieve the first frame of the video, this parameter should be set to `0`.
         * The possible values for this parameter range from `0` to `frame_count-1`. The `frame_count` is the total number of frames contained in the video
         * and it can be retrieved from the response body of [video detail](#Media/GetVideoDetail) endpoint.
         */
        frame_index: number;
      };
    };
    responses: {
      /** @description The requested video frame thumbnail */
      200: {
        content: {
          "image/*": string;
        };
      };
      /** @description Object not found. See the examples for details. */
      404: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 400 | 404 | 405 | 409 | 412 | 413 | 415 | 422 | 423 | 500 | 501 | 503;
            /** @description Message from server */
            message: string;
            /** @description Error code from server */
            error_code: string;
          };
        };
      };
      /** @description Internal server error */
      500: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 400 | 404 | 405 | 409 | 412 | 413 | 415 | 422 | 423 | 500 | 501 | 503;
            /** @description Message from server */
            message: string;
            /** @description Error code from server */
            error_code: string;
          };
        };
      };
    };
  };
  /**
   * Create an annotation for an image
   * @description Create a user annotation for an image. The user annotation scene contains multiple annotations, each of which is defined by a geometric shape and a
   * list of labels for that shape. The shape is defined in pixels.
   */
  CreateImageAnnotation: {
    parameters: {
      path: {
        /** @description The ID of the organization. */
        organization_id: string;
        /** @description The ID of the workspace. */
        workspace_id: string;
        /** @description The ID of the project. */
        project_id: string;
        /** @description The ID of the dataset in the project. */
        dataset_id: string;
        /** @description The ID of the image. */
        image_id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": {
          /** @description List of annotations */
          annotations: {
              /**
               * @description A UUID, used to identify an annotation.
               * @example e42cf382-5f7b-4fda-980a-fa0fab00243c
               */
              id?: string;
              shape: OneOf<[{
                /**
                 * @description Type of the shape.
                 * @enum {string}
                 */
                type: "RECTANGLE";
                /** @description x-coordinate of the left side of the rectangle. Coordinates are pixel values. */
                x: number;
                /** @description y-coordinate of the top of the rectangle. Coordinates are pixel values. */
                y: number;
                /** @description Width of the rectangle. Coordinates are pixel values. */
                width: number;
                /** @description Height of the rectangle. Coordinates are pixel values. */
                height: number;
              }, {
                /**
                 * @description Type of the shape.
                 * @enum {string}
                 */
                type: "POLYGON";
                /** @description Array of points that define the polygon. */
                points: {
                    /** @description x-coordinate of the point. Coordinates are pixel values. */
                    x: number;
                    /** @description y-coordinate of the point. Coordinates are pixel values. */
                    y: number;
                  }[];
              }, {
                /**
                 * @description Type of the shape.
                 * @enum {string}
                 */
                type: "ELLIPSE";
                /** @description Lowest x-coordinate of the ellipse. Coordinates are pixel values. */
                x: number;
                /** @description Lowest y-coordinate of the ellipse. Coordinates are pixel values. */
                y: number;
                /** @description Width of the ellipse. Coordinates are pixel values. */
                width: number;
                /** @description Height of the ellipse. Coordinates are pixel values. */
                height: number;
              }, {
                /**
                 * @description Type of the shape.
                 * @enum {string}
                 */
                type: "ROTATED_RECTANGLE";
                /** @description Center x-coordinate of the rotated rectangle. Coordinates are pixel values. */
                x: number;
                /** @description Center y-coordinate of the rotated rectangle. Coordinates are pixel values. */
                y: number;
                /** @description Width of the rotated rectangle (not the encapsulating box of the rectangle). Coordinates are pixel values. */
                width: number;
                /** @description Height of the rotated rectangle (not the encapsulating box of the rectangle). Coordinates are pixel values. */
                height: number;
                /** @description Clockwise angle in degrees for the rectangle. */
                angle: number;
              }, {
                /**
                 * @description Type of the shape.
                 * @enum {string}
                 */
                type: "KEYPOINT";
                /** @description X-coordinate of the keypoint. Coordinates are pixel values. */
                x: number;
                /** @description Y-coordinate of the keypoint. Coordinates are pixel values. */
                y: number;
                /** @description Indicates whether the feature the keypoint is describing is visible in the image. */
                is_visible: boolean;
              }]>;
              /** @description List of labels */
              labels: {
                  /**
                   * @description Mongo ID of the object
                   * @example 60d31793d5f1fb7e6e3c1a4c
                   */
                  id: string;
                }[];
              /** @description List of labels IDs for which the annotation should be revisited */
              labels_to_revisit?: string[];
            }[];
          media_identifier?: {
            /**
             * @description Mongo ID of the object
             * @example 60d31793d5f1fb7e6e3c1a4c
             */
            image_id?: string;
            /**
             * @description Type of media. 'image' for images, 'video' for videos.
             * @enum {string}
             */
            type?: "image";
          };
          /** @description Modification date */
          modified?: string;
          /** @description List of labels IDs for which the scene (full-image ROI) should be revisited */
          labels_to_revisit_full_scene?: string[];
        };
      };
    };
    responses: {
      /** @description Annotation successfully uploaded for image */
      200: {
        content: {
          "application/json": {
            /** @description List of annotations */
            annotations: ({
                /**
                 * @description A UUID, used to identify an annotation.
                 * @example e42cf382-5f7b-4fda-980a-fa0fab00243c
                 */
                id: string;
                shape?: OneOf<[{
                  /**
                   * @description Type of the shape.
                   * @enum {string}
                   */
                  type: "RECTANGLE";
                  /** @description x-coordinate of the left side of the rectangle. Coordinates are pixel values. */
                  x: number;
                  /** @description y-coordinate of the top of the rectangle. Coordinates are pixel values. */
                  y: number;
                  /** @description Width of the rectangle. Coordinates are pixel values. */
                  width: number;
                  /** @description Height of the rectangle. Coordinates are pixel values. */
                  height: number;
                }, {
                  /**
                   * @description Type of the shape.
                   * @enum {string}
                   */
                  type: "POLYGON";
                  /** @description Array of points that define the polygon. */
                  points: {
                      /** @description x-coordinate of the point. Coordinates are pixel values. */
                      x: number;
                      /** @description y-coordinate of the point. Coordinates are pixel values. */
                      y: number;
                    }[];
                }, {
                  /**
                   * @description Type of the shape.
                   * @enum {string}
                   */
                  type: "ELLIPSE";
                  /** @description Lowest x-coordinate of the ellipse. Coordinates are pixel values. */
                  x: number;
                  /** @description Lowest y-coordinate of the ellipse. Coordinates are pixel values. */
                  y: number;
                  /** @description Width of the ellipse. Coordinates are pixel values. */
                  width: number;
                  /** @description Height of the ellipse. Coordinates are pixel values. */
                  height: number;
                }, {
                  /**
                   * @description Type of the shape.
                   * @enum {string}
                   */
                  type: "ROTATED_RECTANGLE";
                  /** @description Center x-coordinate of the rotated rectangle. Coordinates are pixel values. */
                  x: number;
                  /** @description Center y-coordinate of the rotated rectangle. Coordinates are pixel values. */
                  y: number;
                  /** @description Width of the rotated rectangle (not the encapsulating box of the rectangle). Coordinates are pixel values. */
                  width: number;
                  /** @description Height of the rotated rectangle (not the encapsulating box of the rectangle). Coordinates are pixel values. */
                  height: number;
                  /** @description Clockwise angle in degrees for the rectangle. */
                  angle: number;
                }, {
                  /**
                   * @description Type of the shape.
                   * @enum {string}
                   */
                  type: "KEYPOINT";
                  /** @description X-coordinate of the keypoint. Coordinates are pixel values. */
                  x: number;
                  /** @description Y-coordinate of the keypoint. Coordinates are pixel values. */
                  y: number;
                  /** @description Indicates whether the feature the keypoint is describing is visible in the image. */
                  is_visible: boolean;
                }]>;
                /** @description List of labels */
                labels: ({
                    /**
                     * @description Mongo ID of the object
                     * @example 60d31793d5f1fb7e6e3c1a4c
                     */
                    id?: string;
                    /**
                     * Probability
                     * Format: float
                     * @description Estimated probability of a prediction. For annotations, this is set to 1.
                     */
                    probability?: number;
                    source?: {
                      /** @description User name of the user that added the label or accepted the prediction */
                      user_id?: string | null;
                      /** @description Model id of the model that predicted the label */
                      model_id?: string | null;
                      /** @description Model storage id of model that predicted the label */
                      model_storage_id?: string | null;
                    };
                  })[];
                /** @description Modification date */
                modified: string;
                /** @description List of labels IDs for which the annotation should be revisited */
                labels_to_revisit?: string[];
              })[];
            /**
             * @description Mongo ID of the object
             * @example 60d31793d5f1fb7e6e3c1a4c
             */
            id: string;
            /**
             * @description Kind of annotation (prediction or annotation).
             * @enum {string}
             */
            kind: "prediction" | "annotation";
            media_identifier: {
              /**
               * @description Mongo ID of the object
               * @example 60d31793d5f1fb7e6e3c1a4c
               */
              image_id?: string;
              /**
               * @description Type of media. 'image' for images, 'video' for videos.
               * @enum {string}
               */
              type?: "image";
            };
            /** @description Modification date */
            modified: string;
            /** @description List of labels IDs for which the scene (full-image ROI) should be revisited */
            labels_to_revisit_full_scene: string[];
            /** @description List of per-task states obtained aggregating the annotation state with the revisit information */
            annotation_state_per_task: ({
                /**
                 * @description Mongo ID of the object
                 * @example 60d31793d5f1fb7e6e3c1a4c
                 */
                task_id?: string;
                /**
                 * @description Overall state obtained aggregating the annotation states with the 'revisit' information on a per-task basis. This only has meaning for an  image/frame/scene, as a video does not have an annotation scene. - Image/VideoFrame/AnnotationScene: - to_revisit: Some annotations need to be revisited by the user for this task - annotated: All the ROIs for this task are annotated (contain a label for the task) - partially_annotated: Some ROIs for this task do not contain labels, other ones do - none: No label is present for this task - Video: - all tasks are set to null
                 * @enum {string|null}
                 */
                state?: "to_revisit" | "annotated" | "partially_annotated" | "none" | null;
              })[];
          };
        };
      };
      /** @description Annotation is invalid */
      400: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 400 | 404 | 405 | 409 | 412 | 413 | 415 | 422 | 423 | 500 | 501 | 503;
            /** @description Message from server */
            message: string;
            /** @description Error code from server */
            error_code: string;
          };
        };
      };
      /** @description Object not found. See the examples for details. */
      404: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 400 | 404 | 405 | 409 | 412 | 413 | 415 | 422 | 423 | 500 | 501 | 503;
            /** @description Message from server */
            message: string;
            /** @description Error code from server */
            error_code: string;
          };
        };
      };
    };
  };
  /**
   * Get annotations from an image
   * @description Get the user annotation of an image.
   */
  GetImageAnnotation: {
    parameters: {
      query?: {
        /** @description Set to `true` to return the annotations without the geometric shapes. Default is `false`. */
        label_only?: boolean;
      };
      path: {
        /** @description The ID of the organization. */
        organization_id: string;
        /** @description The ID of the workspace. */
        workspace_id: string;
        /** @description The ID of the project. */
        project_id: string;
        /** @description The ID of the dataset in the project. */
        dataset_id: string;
        /** @description The ID of the image. */
        image_id: string;
        /**
         * @description Set to `latest` to fetch the latest annotations.
         * This parameter can also be set to the ID of a specific annotation. For example, the specific ID could be obtained
         * from the [training revision](#Training%20dataset%20versions/GetMediaForDataset) response,
         * where the response includes the specific user annotation for a media that is used for training.
         */
        annotation_id: string | "latest";
      };
    };
    responses: {
      /** @description Annotation successfully retrieved */
      200: {
        content: {
          "application/json": {
            /** @description List of annotations */
            annotations: ({
                /**
                 * @description A UUID, used to identify an annotation.
                 * @example e42cf382-5f7b-4fda-980a-fa0fab00243c
                 */
                id: string;
                shape?: OneOf<[{
                  /**
                   * @description Type of the shape.
                   * @enum {string}
                   */
                  type: "RECTANGLE";
                  /** @description x-coordinate of the left side of the rectangle. Coordinates are pixel values. */
                  x: number;
                  /** @description y-coordinate of the top of the rectangle. Coordinates are pixel values. */
                  y: number;
                  /** @description Width of the rectangle. Coordinates are pixel values. */
                  width: number;
                  /** @description Height of the rectangle. Coordinates are pixel values. */
                  height: number;
                }, {
                  /**
                   * @description Type of the shape.
                   * @enum {string}
                   */
                  type: "POLYGON";
                  /** @description Array of points that define the polygon. */
                  points: {
                      /** @description x-coordinate of the point. Coordinates are pixel values. */
                      x: number;
                      /** @description y-coordinate of the point. Coordinates are pixel values. */
                      y: number;
                    }[];
                }, {
                  /**
                   * @description Type of the shape.
                   * @enum {string}
                   */
                  type: "ELLIPSE";
                  /** @description Lowest x-coordinate of the ellipse. Coordinates are pixel values. */
                  x: number;
                  /** @description Lowest y-coordinate of the ellipse. Coordinates are pixel values. */
                  y: number;
                  /** @description Width of the ellipse. Coordinates are pixel values. */
                  width: number;
                  /** @description Height of the ellipse. Coordinates are pixel values. */
                  height: number;
                }, {
                  /**
                   * @description Type of the shape.
                   * @enum {string}
                   */
                  type: "ROTATED_RECTANGLE";
                  /** @description Center x-coordinate of the rotated rectangle. Coordinates are pixel values. */
                  x: number;
                  /** @description Center y-coordinate of the rotated rectangle. Coordinates are pixel values. */
                  y: number;
                  /** @description Width of the rotated rectangle (not the encapsulating box of the rectangle). Coordinates are pixel values. */
                  width: number;
                  /** @description Height of the rotated rectangle (not the encapsulating box of the rectangle). Coordinates are pixel values. */
                  height: number;
                  /** @description Clockwise angle in degrees for the rectangle. */
                  angle: number;
                }, {
                  /**
                   * @description Type of the shape.
                   * @enum {string}
                   */
                  type: "KEYPOINT";
                  /** @description X-coordinate of the keypoint. Coordinates are pixel values. */
                  x: number;
                  /** @description Y-coordinate of the keypoint. Coordinates are pixel values. */
                  y: number;
                  /** @description Indicates whether the feature the keypoint is describing is visible in the image. */
                  is_visible: boolean;
                }]>;
                /** @description List of labels */
                labels: ({
                    /**
                     * @description Mongo ID of the object
                     * @example 60d31793d5f1fb7e6e3c1a4c
                     */
                    id?: string;
                    /**
                     * Probability
                     * Format: float
                     * @description Estimated probability of a prediction. For annotations, this is set to 1.
                     */
                    probability?: number;
                    source?: {
                      /** @description User name of the user that added the label or accepted the prediction */
                      user_id?: string | null;
                      /** @description Model id of the model that predicted the label */
                      model_id?: string | null;
                      /** @description Model storage id of model that predicted the label */
                      model_storage_id?: string | null;
                    };
                  })[];
                /** @description Modification date */
                modified: string;
                /** @description List of labels IDs for which the annotation should be revisited */
                labels_to_revisit?: string[];
              })[];
            /**
             * @description Mongo ID of the object
             * @example 60d31793d5f1fb7e6e3c1a4c
             */
            id: string;
            /**
             * @description Kind of annotation (prediction or annotation).
             * @enum {string}
             */
            kind: "prediction" | "annotation";
            media_identifier: {
              /**
               * @description Mongo ID of the object
               * @example 60d31793d5f1fb7e6e3c1a4c
               */
              image_id?: string;
              /**
               * @description Type of media. 'image' for images, 'video' for videos.
               * @enum {string}
               */
              type?: "image";
            };
            /** @description Modification date */
            modified: string;
            /** @description List of labels IDs for which the scene (full-image ROI) should be revisited */
            labels_to_revisit_full_scene: string[];
            /** @description List of per-task states obtained aggregating the annotation state with the revisit information */
            annotation_state_per_task: ({
                /**
                 * @description Mongo ID of the object
                 * @example 60d31793d5f1fb7e6e3c1a4c
                 */
                task_id?: string;
                /**
                 * @description Overall state obtained aggregating the annotation states with the 'revisit' information on a per-task basis. This only has meaning for an  image/frame/scene, as a video does not have an annotation scene. - Image/VideoFrame/AnnotationScene: - to_revisit: Some annotations need to be revisited by the user for this task - annotated: All the ROIs for this task are annotated (contain a label for the task) - partially_annotated: Some ROIs for this task do not contain labels, other ones do - none: No label is present for this task - Video: - all tasks are set to null
                 * @enum {string|null}
                 */
                state?: "to_revisit" | "annotated" | "partially_annotated" | "none" | null;
              })[];
          };
        };
      };
      /** @description The latest annotation could not be found or does not exist for the requested image. */
      204: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 200 | 201 | 202 | 203 | 204 | 205 | 206;
            /** @description Message from server */
            message: string;
          };
        };
      };
      /** @description Object not found. See the examples for details. */
      404: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 400 | 404 | 405 | 409 | 412 | 413 | 415 | 422 | 423 | 500 | 501 | 503;
            /** @description Message from server */
            message: string;
            /** @description Error code from server */
            error_code: string;
          };
        };
      };
    };
  };
  /**
   * Create an annotation for a video frame
   * @description Create a user annotation for a video frame. The user annotation scene contains multiple annotations, each of which is defined by a geometric shape and a
   * list of labels for that shape. The shape is defined in pixels.
   */
  CreateVideoFrameAnnotation: {
    parameters: {
      path: {
        /** @description The ID of the organization. */
        organization_id: string;
        /** @description The ID of the workspace. */
        workspace_id: string;
        /** @description The ID of the project. */
        project_id: string;
        /** @description The ID of the dataset in the project. */
        dataset_id: string;
        /** @description The ID of the video. */
        video_id: string;
        /**
         * @description This is a 0-based index, meaning to retrieve the first frame of the video, this parameter should be set to `0`.
         * The possible values for this parameter range from `0` to `frame_count-1`. The `frame_count` is the total number of frames contained in the video
         * and it can be retrieved from the response body of [video detail](#Media/GetVideoDetail) endpoint.
         */
        frame_index: number;
      };
    };
    requestBody: {
      content: {
        "application/json": {
          /** @description List of annotations */
          annotations: {
              /**
               * @description A UUID, used to identify an annotation.
               * @example e42cf382-5f7b-4fda-980a-fa0fab00243c
               */
              id?: string;
              shape: OneOf<[{
                /**
                 * @description Type of the shape.
                 * @enum {string}
                 */
                type: "RECTANGLE";
                /** @description x-coordinate of the left side of the rectangle. Coordinates are pixel values. */
                x: number;
                /** @description y-coordinate of the top of the rectangle. Coordinates are pixel values. */
                y: number;
                /** @description Width of the rectangle. Coordinates are pixel values. */
                width: number;
                /** @description Height of the rectangle. Coordinates are pixel values. */
                height: number;
              }, {
                /**
                 * @description Type of the shape.
                 * @enum {string}
                 */
                type: "POLYGON";
                /** @description Array of points that define the polygon. */
                points: {
                    /** @description x-coordinate of the point. Coordinates are pixel values. */
                    x: number;
                    /** @description y-coordinate of the point. Coordinates are pixel values. */
                    y: number;
                  }[];
              }, {
                /**
                 * @description Type of the shape.
                 * @enum {string}
                 */
                type: "ELLIPSE";
                /** @description Lowest x-coordinate of the ellipse. Coordinates are pixel values. */
                x: number;
                /** @description Lowest y-coordinate of the ellipse. Coordinates are pixel values. */
                y: number;
                /** @description Width of the ellipse. Coordinates are pixel values. */
                width: number;
                /** @description Height of the ellipse. Coordinates are pixel values. */
                height: number;
              }, {
                /**
                 * @description Type of the shape.
                 * @enum {string}
                 */
                type: "ROTATED_RECTANGLE";
                /** @description Center x-coordinate of the rotated rectangle. Coordinates are pixel values. */
                x: number;
                /** @description Center y-coordinate of the rotated rectangle. Coordinates are pixel values. */
                y: number;
                /** @description Width of the rotated rectangle (not the encapsulating box of the rectangle). Coordinates are pixel values. */
                width: number;
                /** @description Height of the rotated rectangle (not the encapsulating box of the rectangle). Coordinates are pixel values. */
                height: number;
                /** @description Clockwise angle in degrees for the rectangle. */
                angle: number;
              }, {
                /**
                 * @description Type of the shape.
                 * @enum {string}
                 */
                type: "KEYPOINT";
                /** @description X-coordinate of the keypoint. Coordinates are pixel values. */
                x: number;
                /** @description Y-coordinate of the keypoint. Coordinates are pixel values. */
                y: number;
                /** @description Indicates whether the feature the keypoint is describing is visible in the image. */
                is_visible: boolean;
              }]>;
              /** @description List of labels */
              labels: {
                  /**
                   * @description Mongo ID of the object
                   * @example 60d31793d5f1fb7e6e3c1a4c
                   */
                  id: string;
                }[];
              /** @description List of labels IDs for which the annotation should be revisited */
              labels_to_revisit?: string[];
            }[];
          media_identifier?: {
            /** Format: int32 */
            frame_index?: number;
            /**
             * @description Mongo ID of the object
             * @example 60d31793d5f1fb7e6e3c1a4c
             */
            video_id?: string;
            /**
             * @description Type of media. 'image' for images, 'video' for videos.
             * @enum {string}
             */
            type?: "video_frame";
          };
          /** @description Modification date */
          modified?: string;
          /** @description List of labels IDs for which the scene (full-image ROI) should be revisited */
          labels_to_revisit_full_scene?: string[];
        };
      };
    };
    responses: {
      /** @description Annotation successfully uploaded for a video frame */
      200: {
        content: {
          "application/json": {
            /** @description List of annotations */
            annotations?: ({
                /**
                 * @description A UUID, used to identify an annotation.
                 * @example e42cf382-5f7b-4fda-980a-fa0fab00243c
                 */
                id: string;
                shape?: OneOf<[{
                  /**
                   * @description Type of the shape.
                   * @enum {string}
                   */
                  type: "RECTANGLE";
                  /** @description x-coordinate of the left side of the rectangle. Coordinates are pixel values. */
                  x: number;
                  /** @description y-coordinate of the top of the rectangle. Coordinates are pixel values. */
                  y: number;
                  /** @description Width of the rectangle. Coordinates are pixel values. */
                  width: number;
                  /** @description Height of the rectangle. Coordinates are pixel values. */
                  height: number;
                }, {
                  /**
                   * @description Type of the shape.
                   * @enum {string}
                   */
                  type: "POLYGON";
                  /** @description Array of points that define the polygon. */
                  points: {
                      /** @description x-coordinate of the point. Coordinates are pixel values. */
                      x: number;
                      /** @description y-coordinate of the point. Coordinates are pixel values. */
                      y: number;
                    }[];
                }, {
                  /**
                   * @description Type of the shape.
                   * @enum {string}
                   */
                  type: "ELLIPSE";
                  /** @description Lowest x-coordinate of the ellipse. Coordinates are pixel values. */
                  x: number;
                  /** @description Lowest y-coordinate of the ellipse. Coordinates are pixel values. */
                  y: number;
                  /** @description Width of the ellipse. Coordinates are pixel values. */
                  width: number;
                  /** @description Height of the ellipse. Coordinates are pixel values. */
                  height: number;
                }, {
                  /**
                   * @description Type of the shape.
                   * @enum {string}
                   */
                  type: "ROTATED_RECTANGLE";
                  /** @description Center x-coordinate of the rotated rectangle. Coordinates are pixel values. */
                  x: number;
                  /** @description Center y-coordinate of the rotated rectangle. Coordinates are pixel values. */
                  y: number;
                  /** @description Width of the rotated rectangle (not the encapsulating box of the rectangle). Coordinates are pixel values. */
                  width: number;
                  /** @description Height of the rotated rectangle (not the encapsulating box of the rectangle). Coordinates are pixel values. */
                  height: number;
                  /** @description Clockwise angle in degrees for the rectangle. */
                  angle: number;
                }, {
                  /**
                   * @description Type of the shape.
                   * @enum {string}
                   */
                  type: "KEYPOINT";
                  /** @description X-coordinate of the keypoint. Coordinates are pixel values. */
                  x: number;
                  /** @description Y-coordinate of the keypoint. Coordinates are pixel values. */
                  y: number;
                  /** @description Indicates whether the feature the keypoint is describing is visible in the image. */
                  is_visible: boolean;
                }]>;
                /** @description List of labels */
                labels: ({
                    /**
                     * @description Mongo ID of the object
                     * @example 60d31793d5f1fb7e6e3c1a4c
                     */
                    id?: string;
                    /**
                     * Probability
                     * Format: float
                     * @description Estimated probability of a prediction. For annotations, this is set to 1.
                     */
                    probability?: number;
                    source?: {
                      /** @description User name of the user that added the label or accepted the prediction */
                      user_id?: string | null;
                      /** @description Model id of the model that predicted the label */
                      model_id?: string | null;
                      /** @description Model storage id of model that predicted the label */
                      model_storage_id?: string | null;
                    };
                  })[];
                /** @description Modification date */
                modified: string;
                /** @description List of labels IDs for which the annotation should be revisited */
                labels_to_revisit?: string[];
              })[];
            /**
             * @description Mongo ID of the object
             * @example 60d31793d5f1fb7e6e3c1a4c
             */
            id?: string;
            /**
             * @description Kind of annotation (prediction or annotation).
             * @enum {string}
             */
            kind?: "prediction" | "annotation";
            media_identifier?: {
              frame_index?: number;
              /**
               * @description Mongo ID of the object
               * @example 60d31793d5f1fb7e6e3c1a4c
               */
              video_id?: string;
              /**
               * @description Type of media. 'image' for images, 'video' for videos.
               * @enum {string}
               */
              type?: "video_frame";
            };
            /** @description Modification date */
            modified?: string;
            /** @description List of labels IDs for which the scene (full-image ROI) should be revisited */
            labels_to_revisit_full_scene?: string[];
            /** @description List of per-task states obtained aggregating the annotation state with the revisit information */
            annotation_state_per_task?: ({
                /**
                 * @description Mongo ID of the object
                 * @example 60d31793d5f1fb7e6e3c1a4c
                 */
                task_id?: string;
                /**
                 * @description Overall state obtained aggregating the annotation states with the 'revisit' information on a per-task basis. This only has meaning for an  image/frame/scene, as a video does not have an annotation scene. - Image/VideoFrame/AnnotationScene: - to_revisit: Some annotations need to be revisited by the user for this task - annotated: All the ROIs for this task are annotated (contain a label for the task) - partially_annotated: Some ROIs for this task do not contain labels, other ones do - none: No label is present for this task - Video: - all tasks are set to null
                 * @enum {string|null}
                 */
                state?: "to_revisit" | "annotated" | "partially_annotated" | "none" | null;
              })[];
          };
        };
      };
      /** @description Annotation is invalid */
      400: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 400 | 404 | 405 | 409 | 412 | 413 | 415 | 422 | 423 | 500 | 501 | 503;
            /** @description Message from server */
            message: string;
            /** @description Error code from server */
            error_code: string;
          };
        };
      };
      /** @description Object not found. See the examples for details. */
      404: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 400 | 404 | 405 | 409 | 412 | 413 | 415 | 422 | 423 | 500 | 501 | 503;
            /** @description Message from server */
            message: string;
            /** @description Error code from server */
            error_code: string;
          };
        };
      };
    };
  };
  /**
   * Get annotations from a video frame
   * @description Get the user annotation of a video frame.
   */
  GetVideoFrameAnnotation: {
    parameters: {
      query?: {
        /** @description Set to `true` to return the annotations without the geometric shapes. Default is `false`. */
        label_only?: boolean;
      };
      path: {
        /** @description The ID of the organization. */
        organization_id: string;
        /** @description The ID of the workspace. */
        workspace_id: string;
        /** @description The ID of the project. */
        project_id: string;
        /** @description The ID of the dataset in the project. */
        dataset_id: string;
        /** @description The ID of the video. */
        video_id: string;
        /**
         * @description This is a 0-based index, meaning to retrieve the first frame of the video, this parameter should be set to `0`.
         * The possible values for this parameter range from `0` to `frame_count-1`. The `frame_count` is the total number of frames contained in the video
         * and it can be retrieved from the response body of [video detail](#Media/GetVideoDetail) endpoint.
         */
        frame_index: number;
        /**
         * @description Set to `latest` to fetch the latest annotations.
         * This parameter can also be set to the ID of a specific annotation. For example, the specific ID could be obtained
         * from the [training revision](#Training%20dataset%20versions/GetMediaForDataset) response,
         * where the response includes the specific user annotation for a media that is used for training.
         */
        annotation_id: string | "latest";
      };
    };
    responses: {
      /** @description Annotation successfully retrieved */
      200: {
        content: {
          "application/json": {
            /** @description List of annotations */
            annotations?: ({
                /**
                 * @description A UUID, used to identify an annotation.
                 * @example e42cf382-5f7b-4fda-980a-fa0fab00243c
                 */
                id: string;
                shape?: OneOf<[{
                  /**
                   * @description Type of the shape.
                   * @enum {string}
                   */
                  type: "RECTANGLE";
                  /** @description x-coordinate of the left side of the rectangle. Coordinates are pixel values. */
                  x: number;
                  /** @description y-coordinate of the top of the rectangle. Coordinates are pixel values. */
                  y: number;
                  /** @description Width of the rectangle. Coordinates are pixel values. */
                  width: number;
                  /** @description Height of the rectangle. Coordinates are pixel values. */
                  height: number;
                }, {
                  /**
                   * @description Type of the shape.
                   * @enum {string}
                   */
                  type: "POLYGON";
                  /** @description Array of points that define the polygon. */
                  points: {
                      /** @description x-coordinate of the point. Coordinates are pixel values. */
                      x: number;
                      /** @description y-coordinate of the point. Coordinates are pixel values. */
                      y: number;
                    }[];
                }, {
                  /**
                   * @description Type of the shape.
                   * @enum {string}
                   */
                  type: "ELLIPSE";
                  /** @description Lowest x-coordinate of the ellipse. Coordinates are pixel values. */
                  x: number;
                  /** @description Lowest y-coordinate of the ellipse. Coordinates are pixel values. */
                  y: number;
                  /** @description Width of the ellipse. Coordinates are pixel values. */
                  width: number;
                  /** @description Height of the ellipse. Coordinates are pixel values. */
                  height: number;
                }, {
                  /**
                   * @description Type of the shape.
                   * @enum {string}
                   */
                  type: "ROTATED_RECTANGLE";
                  /** @description Center x-coordinate of the rotated rectangle. Coordinates are pixel values. */
                  x: number;
                  /** @description Center y-coordinate of the rotated rectangle. Coordinates are pixel values. */
                  y: number;
                  /** @description Width of the rotated rectangle (not the encapsulating box of the rectangle). Coordinates are pixel values. */
                  width: number;
                  /** @description Height of the rotated rectangle (not the encapsulating box of the rectangle). Coordinates are pixel values. */
                  height: number;
                  /** @description Clockwise angle in degrees for the rectangle. */
                  angle: number;
                }, {
                  /**
                   * @description Type of the shape.
                   * @enum {string}
                   */
                  type: "KEYPOINT";
                  /** @description X-coordinate of the keypoint. Coordinates are pixel values. */
                  x: number;
                  /** @description Y-coordinate of the keypoint. Coordinates are pixel values. */
                  y: number;
                  /** @description Indicates whether the feature the keypoint is describing is visible in the image. */
                  is_visible: boolean;
                }]>;
                /** @description List of labels */
                labels: ({
                    /**
                     * @description Mongo ID of the object
                     * @example 60d31793d5f1fb7e6e3c1a4c
                     */
                    id?: string;
                    /**
                     * Probability
                     * Format: float
                     * @description Estimated probability of a prediction. For annotations, this is set to 1.
                     */
                    probability?: number;
                    source?: {
                      /** @description User name of the user that added the label or accepted the prediction */
                      user_id?: string | null;
                      /** @description Model id of the model that predicted the label */
                      model_id?: string | null;
                      /** @description Model storage id of model that predicted the label */
                      model_storage_id?: string | null;
                    };
                  })[];
                /** @description Modification date */
                modified: string;
                /** @description List of labels IDs for which the annotation should be revisited */
                labels_to_revisit?: string[];
              })[];
            /**
             * @description Mongo ID of the object
             * @example 60d31793d5f1fb7e6e3c1a4c
             */
            id?: string;
            /**
             * @description Kind of annotation (prediction or annotation).
             * @enum {string}
             */
            kind?: "prediction" | "annotation";
            media_identifier?: {
              frame_index?: number;
              /**
               * @description Mongo ID of the object
               * @example 60d31793d5f1fb7e6e3c1a4c
               */
              video_id?: string;
              /**
               * @description Type of media. 'image' for images, 'video' for videos.
               * @enum {string}
               */
              type?: "video_frame";
            };
            /** @description Modification date */
            modified?: string;
            /** @description List of labels IDs for which the scene (full-image ROI) should be revisited */
            labels_to_revisit_full_scene?: string[];
            /** @description List of per-task states obtained aggregating the annotation state with the revisit information */
            annotation_state_per_task?: ({
                /**
                 * @description Mongo ID of the object
                 * @example 60d31793d5f1fb7e6e3c1a4c
                 */
                task_id?: string;
                /**
                 * @description Overall state obtained aggregating the annotation states with the 'revisit' information on a per-task basis. This only has meaning for an  image/frame/scene, as a video does not have an annotation scene. - Image/VideoFrame/AnnotationScene: - to_revisit: Some annotations need to be revisited by the user for this task - annotated: All the ROIs for this task are annotated (contain a label for the task) - partially_annotated: Some ROIs for this task do not contain labels, other ones do - none: No label is present for this task - Video: - all tasks are set to null
                 * @enum {string|null}
                 */
                state?: "to_revisit" | "annotated" | "partially_annotated" | "none" | null;
              })[];
          };
        };
      };
      /** @description The latest annotation could not be found or does not exist for the requested video frame. */
      204: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 200 | 201 | 202 | 203 | 204 | 205 | 206;
            /** @description Message from server */
            message: string;
          };
        };
      };
      /** @description Object not found. See the examples for details. */
      404: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 400 | 404 | 405 | 409 | 412 | 413 | 415 | 422 | 423 | 500 | 501 | 503;
            /** @description Message from server */
            message: string;
            /** @description Error code from server */
            error_code: string;
          };
        };
      };
    };
  };
  /**
   * Get the video annotation range
   * @description Get the labels per frame range for a video. A frame range is a range from a start to end frame combined
   * with labels. The start and end frame are inclusive.
   */
  GetVideoAnnotationRange: {
    parameters: {
      path: {
        /** @description The ID of the organization. */
        organization_id: string;
        /** @description The ID of the workspace. */
        workspace_id: string;
        /** @description The ID of the project. */
        project_id: string;
        /** @description The ID of the dataset in the project. */
        dataset_id: string;
        /** @description The ID of the video. */
        video_id: string;
      };
    };
    responses: {
      /** @description Annotation range successfully retrieved */
      200: {
        content: {
          "application/json": {
            /**
             * @description A UUID, used to identify an annotation.
             * @example e42cf382-5f7b-4fda-980a-fa0fab00243c
             */
            video_id?: string;
            /** @description List of range labels */
            range_labels: {
                /** @description Frame index that represents the left endpoint (inclusive) of the range */
                start_frame: number;
                /** @description Frame index that represents the right endpoint (inclusive) of the range */
                end_frame: number;
                /** @description ids of the labels assigned to the range */
                label_ids: string[];
              }[];
          };
        };
      };
      /** @description Object not found. See the examples for details. */
      404: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 400 | 404 | 405 | 409 | 412 | 413 | 415 | 422 | 423 | 500 | 501 | 503;
            /** @description Message from server */
            message: string;
            /** @description Error code from server */
            error_code: string;
          };
        };
      };
    };
  };
  /**
   * Create a video annotation range
   * @description Create a video annotation range for a video. The request body should contain the full list of
   * frame ranges along with the ids of the labels associated with those ranges. Any previously submitted annotation range
   * for the same video is overridden by the new request; moreover, any interval of frames that is not explicitly specified
   * in the request is marked as unannotated.
   */
  CreateVideoAnnotationRange: {
    parameters: {
      query?: {
        /** @description Number indicating for how many frames in the video an annotation should be uploaded. A value of 1 means every frame is annotated while a value of 10 means every 10th frame gets an annotation. If nothing is passed, it defaults to the video fps. */
        skip_frame?: string;
      };
      path: {
        /** @description The ID of the organization. */
        organization_id: string;
        /** @description The ID of the workspace. */
        workspace_id: string;
        /** @description The ID of the project. */
        project_id: string;
        /** @description The ID of the dataset in the project. */
        dataset_id: string;
        /** @description The ID of the video. */
        video_id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": {
          /** @description List of frame ranges and their associated labels */
          range_labels: {
              /** @description Frame index that represents the left endpoint (inclusive) of the range */
              start_frame: number;
              /** @description Frame index that represents the right endpoint (inclusive) of the range */
              end_frame: number;
              /** @description ids of the labels to assign to the range */
              label_ids: string[];
            }[];
        };
      };
    };
    responses: {
      /** @description Annotation range successfully uploaded */
      200: {
        content: {
          "application/json": {
            /**
             * @description A UUID, used to identify an annotation.
             * @example e42cf382-5f7b-4fda-980a-fa0fab00243c
             */
            video_id?: string;
            /** @description List of range labels */
            range_labels: {
                /** @description Frame index that represents the left endpoint (inclusive) of the range */
                start_frame: number;
                /** @description Frame index that represents the right endpoint (inclusive) of the range */
                end_frame: number;
                /** @description ids of the labels assigned to the range */
                label_ids: string[];
              }[];
          };
        };
      };
      /** @description Annotation range is invalid */
      400: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 400 | 404 | 405 | 409 | 412 | 413 | 415 | 422 | 423 | 500 | 501 | 503;
            /** @description Message from server */
            message: string;
            /** @description Error code from server */
            error_code: string;
          };
        };
      };
      /** @description Object not found. See the examples for details. */
      404: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 400 | 404 | 405 | 409 | 412 | 413 | 415 | 422 | 423 | 500 | 501 | 503;
            /** @description Message from server */
            message: string;
            /** @description Error code from server */
            error_code: string;
          };
        };
      };
    };
  };
  /**
   * Get the annotations from a video
   * @description Get the user annotations for the video frames in a video.
   */
  GetVideoAnnotation: {
    parameters: {
      query?: {
        /** @description Set to `true` to return the annotations without the geometric shapes. Default is `false`. */
        label_only?: boolean;
        /**
         * @description The starting index of the range of interest. This is a 0-based inclusive index, meaning to include the first frame of the video,
         * this parameter should be set to `0`. The value cannot be bigger than `frame_count-1`.
         * The `frame_count` is the total number of frames contained in the video
         * and it can be retrieved from the response body of [video detail](#Media/GetVideoDetail) endpoint.
         */
        start_frame?: number;
        /** @description :- The ending index of the range of interest. This is a 0-based inclusive index, meaning to include the last frame of the video, this parameter should be set to `frame_count-1`; the value cannot be bigger than `frame_count-1`. The `frame_count` is the total number of frames contained in the video and it can be retrieved from the response body of [video detail](#Media/GetVideoDetail) endpoint. */
        end_frame?: number;
        /**
         * @description Set to the number of desired frame intervals in the response. For example, to retrieve all frame annotations of the video, set this value to `1`.
         * If not set, this value will be equal to the video fps. The video fps can be obtained from the response of the [video detail](#Media/GetVideoDetail)
         * endpoint.
         */
        frameskip?: number;
      };
      path: {
        /** @description The ID of the organization. */
        organization_id: string;
        /** @description The ID of the workspace. */
        workspace_id: string;
        /** @description The ID of the project. */
        project_id: string;
        /** @description The ID of the dataset in the project. */
        dataset_id: string;
        /** @description The ID of the video. */
        video_id: string;
      };
    };
    responses: {
      /** @description Annotations successfully retrieved */
      200: {
        content: {
          "application/json": {
            /** @description List of annotations */
            annotations?: ({
                /**
                 * @description A UUID, used to identify an annotation.
                 * @example e42cf382-5f7b-4fda-980a-fa0fab00243c
                 */
                id: string;
                shape?: OneOf<[{
                  /**
                   * @description Type of the shape.
                   * @enum {string}
                   */
                  type: "RECTANGLE";
                  /** @description x-coordinate of the left side of the rectangle. Coordinates are pixel values. */
                  x: number;
                  /** @description y-coordinate of the top of the rectangle. Coordinates are pixel values. */
                  y: number;
                  /** @description Width of the rectangle. Coordinates are pixel values. */
                  width: number;
                  /** @description Height of the rectangle. Coordinates are pixel values. */
                  height: number;
                }, {
                  /**
                   * @description Type of the shape.
                   * @enum {string}
                   */
                  type: "POLYGON";
                  /** @description Array of points that define the polygon. */
                  points: {
                      /** @description x-coordinate of the point. Coordinates are pixel values. */
                      x: number;
                      /** @description y-coordinate of the point. Coordinates are pixel values. */
                      y: number;
                    }[];
                }, {
                  /**
                   * @description Type of the shape.
                   * @enum {string}
                   */
                  type: "ELLIPSE";
                  /** @description Lowest x-coordinate of the ellipse. Coordinates are pixel values. */
                  x: number;
                  /** @description Lowest y-coordinate of the ellipse. Coordinates are pixel values. */
                  y: number;
                  /** @description Width of the ellipse. Coordinates are pixel values. */
                  width: number;
                  /** @description Height of the ellipse. Coordinates are pixel values. */
                  height: number;
                }, {
                  /**
                   * @description Type of the shape.
                   * @enum {string}
                   */
                  type: "ROTATED_RECTANGLE";
                  /** @description Center x-coordinate of the rotated rectangle. Coordinates are pixel values. */
                  x: number;
                  /** @description Center y-coordinate of the rotated rectangle. Coordinates are pixel values. */
                  y: number;
                  /** @description Width of the rotated rectangle (not the encapsulating box of the rectangle). Coordinates are pixel values. */
                  width: number;
                  /** @description Height of the rotated rectangle (not the encapsulating box of the rectangle). Coordinates are pixel values. */
                  height: number;
                  /** @description Clockwise angle in degrees for the rectangle. */
                  angle: number;
                }, {
                  /**
                   * @description Type of the shape.
                   * @enum {string}
                   */
                  type: "KEYPOINT";
                  /** @description X-coordinate of the keypoint. Coordinates are pixel values. */
                  x: number;
                  /** @description Y-coordinate of the keypoint. Coordinates are pixel values. */
                  y: number;
                  /** @description Indicates whether the feature the keypoint is describing is visible in the image. */
                  is_visible: boolean;
                }]>;
                /** @description List of labels */
                labels: ({
                    /**
                     * @description Mongo ID of the object
                     * @example 60d31793d5f1fb7e6e3c1a4c
                     */
                    id?: string;
                    /**
                     * Probability
                     * Format: float
                     * @description Estimated probability of a prediction. For annotations, this is set to 1.
                     */
                    probability?: number;
                    source?: {
                      /** @description User name of the user that added the label or accepted the prediction */
                      user_id?: string | null;
                      /** @description Model id of the model that predicted the label */
                      model_id?: string | null;
                      /** @description Model storage id of model that predicted the label */
                      model_storage_id?: string | null;
                    };
                  })[];
                /** @description Modification date */
                modified: string;
                /** @description List of labels IDs for which the annotation should be revisited */
                labels_to_revisit?: string[];
              })[];
            /**
             * @description Mongo ID of the object
             * @example 60d31793d5f1fb7e6e3c1a4c
             */
            id?: string;
            /**
             * @description Kind of annotation (prediction or annotation).
             * @enum {string}
             */
            kind?: "prediction" | "annotation";
            media_identifier?: {
              frame_index?: number;
              /**
               * @description Mongo ID of the object
               * @example 60d31793d5f1fb7e6e3c1a4c
               */
              video_id?: string;
              /**
               * @description Type of media. 'image' for images, 'video' for videos.
               * @enum {string}
               */
              type?: "video_frame";
            };
            /** @description Modification date */
            modified?: string;
            /** @description List of labels IDs for which the scene (full-image ROI) should be revisited */
            labels_to_revisit_full_scene?: string[];
            /** @description List of per-task states obtained aggregating the annotation state with the revisit information */
            annotation_state_per_task?: ({
                /**
                 * @description Mongo ID of the object
                 * @example 60d31793d5f1fb7e6e3c1a4c
                 */
                task_id?: string;
                /**
                 * @description Overall state obtained aggregating the annotation states with the 'revisit' information on a per-task basis. This only has meaning for an  image/frame/scene, as a video does not have an annotation scene. - Image/VideoFrame/AnnotationScene: - to_revisit: Some annotations need to be revisited by the user for this task - annotated: All the ROIs for this task are annotated (contain a label for the task) - partially_annotated: Some ROIs for this task do not contain labels, other ones do - none: No label is present for this task - Video: - all tasks are set to null
                 * @enum {string|null}
                 */
                state?: "to_revisit" | "annotated" | "partially_annotated" | "none" | null;
              })[];
          };
        };
      };
      /** @description Annotation could not be found. */
      204: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 200 | 201 | 202 | 203 | 204 | 205 | 206;
            /** @description Message from server */
            message: string;
          };
        };
      };
      /** @description Object not found. See the examples for details. */
      404: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 400 | 404 | 405 | 409 | 412 | 413 | 415 | 422 | 423 | 500 | 501 | 503;
            /** @description Message from server */
            message: string;
            /** @description Error code from server */
            error_code: string;
          };
        };
      };
    };
  };
  /**
   * Get supported algorithms
   * @description List the algorithms (model architectures) supported for the tasks within a project.
   */
  GetSupportedAlgorithms: {
    parameters: {
      query?: {
        /** @description Whether to include obsolete algorithms in the response. */
        include_obsolete?: boolean;
      };
      path: {
        /** @description The ID of the organization. */
        organization_id: string;
        /** @description The ID of the workspace. */
        workspace_id: string;
        /** @description The ID of the project. */
        project_id: string;
      };
    };
    responses: {
      /** @description List of supported algorithms */
      200: {
        content: {
          "application/json": {
            /** @description List of supported algorithms */
            supported_algorithms?: ({
                /** @description Name of the algorithm */
                name?: string;
                /**
                 * @description Task type of the algorithm.
                 * @enum {string}
                 */
                task_type?: "detection" | "rotated_detection" | "anomaly" | "segmentation" | "instance_segmentation" | "classification" | "keypoint_detection";
                /**
                 * Format: float
                 * @description Storage size of the model, in MB
                 */
                model_size?: number;
                /** @description Unique identifier for the algorithm */
                model_template_id?: string;
                /**
                 * Format: float
                 * @description Theoretical complexity of the model, in billions of operations
                 */
                gigaflops?: number;
                /** @description A short summary that gives information about the algorithm */
                summary?: string;
                /**
                 * @deprecated
                 * @description Boolean that indicates whether the algorithm supports automatic hyper parameter optimization.
                 * This field is deprecated and should not be used, it will be removed in the future.
                 */
                supports_auto_hpo?: boolean;
                /** @description Boolean that indicates whether the model template is the default selection for the task */
                default_algorithm?: boolean;
                /**
                 * @description The category of the model template. Some algorithms focus more on accuracy, others on inference speed.
                 * @enum {string}
                 */
                performance_category?: "balance" | "speed" | "accuracy" | "other";
                /**
                 * @description The current support status of the model architecture. 'Active' algorithms are fully supported and maintained.
                 * 'Deprecated' ones are still supported, but not recommended for training; in a later version, they may be
                 * discontinued and become 'obsolete', which means that new models cannot be trained with such algorithms.
                 * @enum {string}
                 */
                lifecycle_stage?: "active" | "deprecated" | "obsolete";
              })[];
          };
        };
      };
      /** @description Task type is not recognized or supported */
      400: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 400 | 404 | 405 | 409 | 412 | 413 | 415 | 422 | 423 | 500 | 501 | 503;
            /** @description Message from server */
            message: string;
            /** @description Error code from server */
            error_code: string;
          };
        };
      };
    };
  };
  /**
   * Train a model
   * @description Submit a training job.
   */
  TrainModel: {
    parameters: {
      path: {
        /** @description The ID of the organization. */
        organization_id: string;
        /** @description The ID of the workspace. */
        workspace_id: string;
        /** @description The ID of the project. */
        project_id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": {
          /** @description The ID of the model architecture to be trained. This can be obtained from the [supported algorithms endpoint](#Projects/GetSupportedAlgorithms). */
          model_template_id?: string;
          /**
           * @description The ID of the task to train. For task-chain projects, this is a required parameter.
           * The task ID can be found in the response body of the [project detail](#Projects/GetProjectInfo) endpoint.
           */
          task_id?: string;
          /** @description Set to `true` to train the model from scratch (i.e., not finetuning from previous version). */
          train_from_scratch?: boolean;
          /** @description Set to `true` to reset the train, test and validation subsets (Only valid when `train_from_scratch` is set to `true`). */
          reshuffle_subsets?: boolean;
          /** @description Defines the maximum dataset size for training. If no value is provided, the whole dataset is used. */
          max_training_dataset_size?: number;
          /**
           * @deprecated
           * @description Boolean that indicates whether to run hyper-parameter optimization (HPO) before training.
           * This field is deprecated and should not be used, it will be removed in the future.
           */
          enable_hyper_parameter_optimization?: boolean;
          /**
           * @deprecated
           * @description These parameters control the automatic hyper parameter optimization process, if it is enabled. If `enable_hyper_parameter_optimization` is set to `true`, the hpo_parameters in this field must be specified. Otherwise, this field can be left empty.
           */
          hpo_parameters?: {
            /**
             * Format: float
             * @description This parameter controls the time allotted for automatic hyper parameter optimization. It is measured in multiples of training time, e.g. setting `hpo_time_ratio` to `4.0` will result in the hpo process taking approximately 4 times as long as a normal training without hpo would.
             */
            hpo_time_ratio?: number;
          };
          /** @description Hyper parameters for the model to be trained */
          hyper_parameters?: {
            /** @description Array of hyper parameter groups */
            components: ({
                /** Hyper parameter group entity identifier */
                entity_identifier: {
                  workspace_id?: string;
                  /**
                   * @description Mongo ID of the object
                   * @example 60d31793d5f1fb7e6e3c1a4c
                   */
                  model_storage_id: string;
                  /** @description The name of the hyper parameter group */
                  group_name: string;
                  /**
                   * @description Describes the type of the component. For hyper parameter groups, type is always set to HYPER_PARAMETER_GROUP
                   * @enum {string}
                   */
                  type: "HYPER_PARAMETER_GROUP";
                };
                groups?: ({
                    /** @description Name of the parameter group */
                    name: string;
                    /** @description Array of parameters */
                    parameters: ({
                        /** @description Value to set the parameter to. */
                        value: string | number | boolean;
                        /** @description Name to identify the parameter by in the system. */
                        name: string;
                      })[];
                  })[];
                parameters?: ({
                    /** @description Value to set the parameter to. */
                    value: string | number | boolean;
                    /** @description Name to identify the parameter by in the system. */
                    name: string;
                  })[];
              })[];
          };
        };
      };
    };
    responses: {
      /** @description Training job submitted */
      200: {
        content: {
          "application/json": {
            /**
             * @description Mongo ID of the object
             * @example 60d31793d5f1fb7e6e3c1a4c
             */
            job_id?: string;
          };
        };
      };
      /** @description Object not found. See the examples for details. */
      404: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 400 | 404 | 405 | 409 | 412 | 413 | 415 | 422 | 423 | 500 | 501 | 503;
            /** @description Message from server */
            message: string;
            /** @description Error code from server */
            error_code: string;
          };
        };
      };
      /** @description Insufficient balance for training job execution. */
      412: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 400 | 404 | 405 | 409 | 412 | 413 | 415 | 422 | 423 | 500 | 501 | 503;
            /** @description Message from server */
            message: string;
            /** @description Error code from server */
            error_code: string;
          };
        };
      };
      /** @description Unprocessable Content. See the examples for details. */
      422: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 400 | 404 | 405 | 409 | 412 | 413 | 415 | 422 | 423 | 500 | 501 | 503;
            /** @description Message from server */
            message: string;
            /** @description Error code from server */
            error_code: string;
          };
        };
      };
    };
  };
  /**
   * Train a model
   * @deprecated
   * @description Submit a training job. Note - This endpoint is deprecated and will be removed after 2025-03-31. Please use the new endpoint `:train` instead.
   */
  LegacyTrainModel: {
    parameters: {
      path: {
        /** @description The ID of the organization. */
        organization_id: string;
        /** @description The ID of the workspace. */
        workspace_id: string;
        /** @description The ID of the project. */
        project_id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": {
          /** @description The ID of the model architecture to be trained. This can be obtained from the [supported algorithms endpoint](#Projects/GetSupportedAlgorithms). */
          model_template_id?: string;
          /**
           * @description The ID of the task to train. For task-chain projects, this is a required parameter.
           * The task ID can be found in the response body of the [project detail](#Projects/GetProjectInfo) endpoint.
           */
          task_id?: string;
          /** @description Set to `true` to train the model from scratch (i.e., not finetuning from previous version). */
          train_from_scratch?: boolean;
          /** @description Set to `true` to reset the train, test and validation subsets (Only valid when `train_from_scratch` is set to `true`). */
          reshuffle_subsets?: boolean;
          /** @description Defines the maximum dataset size for training. If no value is provided, the whole dataset is used. */
          max_training_dataset_size?: number;
          /**
           * @deprecated
           * @description Boolean that indicates whether to run hyper-parameter optimization (HPO) before training.
           * This field is deprecated and should not be used, it will be removed in the future.
           */
          enable_hyper_parameter_optimization?: boolean;
          /**
           * @deprecated
           * @description These parameters control the automatic hyper parameter optimization process, if it is enabled. If `enable_hyper_parameter_optimization` is set to `true`, the hpo_parameters in this field must be specified. Otherwise, this field can be left empty.
           */
          hpo_parameters?: {
            /**
             * Format: float
             * @description This parameter controls the time allotted for automatic hyper parameter optimization. It is measured in multiples of training time, e.g. setting `hpo_time_ratio` to `4.0` will result in the hpo process taking approximately 4 times as long as a normal training without hpo would.
             */
            hpo_time_ratio?: number;
          };
          /** @description Hyper parameters for the model to be trained */
          hyper_parameters?: {
            /** @description Array of hyper parameter groups */
            components: ({
                /** Hyper parameter group entity identifier */
                entity_identifier: {
                  workspace_id?: string;
                  /**
                   * @description Mongo ID of the object
                   * @example 60d31793d5f1fb7e6e3c1a4c
                   */
                  model_storage_id: string;
                  /** @description The name of the hyper parameter group */
                  group_name: string;
                  /**
                   * @description Describes the type of the component. For hyper parameter groups, type is always set to HYPER_PARAMETER_GROUP
                   * @enum {string}
                   */
                  type: "HYPER_PARAMETER_GROUP";
                };
                groups?: ({
                    /** @description Name of the parameter group */
                    name: string;
                    /** @description Array of parameters */
                    parameters: ({
                        /** @description Value to set the parameter to. */
                        value: string | number | boolean;
                        /** @description Name to identify the parameter by in the system. */
                        name: string;
                      })[];
                  })[];
                parameters?: ({
                    /** @description Value to set the parameter to. */
                    value: string | number | boolean;
                    /** @description Name to identify the parameter by in the system. */
                    name: string;
                  })[];
              })[];
          };
        };
      };
    };
    responses: {
      /** @description Training job submitted */
      200: {
        content: {
          "application/json": {
            /**
             * @description Mongo ID of the object
             * @example 60d31793d5f1fb7e6e3c1a4c
             */
            job_id?: string;
          };
        };
      };
      /** @description Object not found. See the examples for details. */
      404: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 400 | 404 | 405 | 409 | 412 | 413 | 415 | 422 | 423 | 500 | 501 | 503;
            /** @description Message from server */
            message: string;
            /** @description Error code from server */
            error_code: string;
          };
        };
      };
      /** @description Unprocessable Content. See the examples for details. */
      422: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 400 | 404 | 405 | 409 | 412 | 413 | 415 | 422 | 423 | 500 | 501 | 503;
            /** @description Message from server */
            message: string;
            /** @description Error code from server */
            error_code: string;
          };
        };
      };
    };
  };
  /**
   * Get information on all models and their groups belonging to a project
   * @description Get information on all model groups in a project. Each model group represents one model architecture that has been trained in the project and
   * contains a list of successfully trained models of that architecture.
   * To obtain more detail on each of the model version, please use the [model detail](#Models/GetModelDetail) endpoint.
   */
  GetModelGroups: {
    parameters: {
      query?: {
        /**
         * @description Provide the task ID to get the model groups related to that task. For example in a task chain project,
         * set this parameter to the ID of the first task if you are interested only in the model groups of the first task.
         * The task ID can be found in the response body of the [project detail](#Projects/GetProjectInfo) endpoint.
         *
         * If no task id is provided, the response will contain the model groups for all tasks in the project.
         */
        task_id?: string;
      };
      path: {
        /** @description The ID of the organization. */
        organization_id: string;
        /** @description The ID of the workspace. */
        workspace_id: string;
        /** @description The ID of the project. */
        project_id: string;
      };
    };
    responses: {
      /** @description Information on all models and their groups belonging to a project */
      200: {
        content: {
          "application/json": {
            /** @description Array of model groups */
            model_groups?: ({
                /**
                 * @description Array of models. The models at this level represent the successfully trained models. Note that these are not
                 * the (OpenVINO or ONNX) optimized models;
                 * the list of optimized models can be found through the [model detail](#Models/GetModelDetail) endpoint.
                 */
                models?: ({
                    /**
                     * @description Mongo ID of the object
                     * @example 60d31793d5f1fb7e6e3c1a4c
                     */
                    id?: string;
                    /** @description Name of the model. */
                    name?: string;
                    /** @description Creation date of the model. */
                    creation_date?: string;
                    /**
                     * Format: int32
                     * @description Model size in bytes.
                     */
                    size?: number;
                    /**
                     * Format: int32
                     * @description The aggregated size (bytes) for model-related files. This includes all the exportable binaries, such as exportable code,
                     * and the binaries from the optimized models.
                     */
                    total_disk_size?: number;
                    performance?: {
                      /**
                       * Format: float
                       * @description Accuracy score for the model. Only applicable for non-anomaly projects.
                       */
                      score?: number | null;
                    };
                    /** @description Boolean that indicates whether the label schema for the model is in sync with the latest label schema for the task containing the model */
                    label_schema_in_sync?: boolean;
                    /**
                     * @deprecated
                     * @description Boolean indicating whether the score of the model is the most recent score.
                     * This parameter is deprecated and should not be used, it will be removed in the future.
                     */
                    score_up_to_date?: boolean;
                    /** @description ID of the model storage */
                    model_storage_id?: string;
                    /** @description Boolean indicating that the model is used for inference requests for the project. */
                    active_model?: boolean;
                    /** @description Version of the model */
                    version?: number;
                    /**
                     * @description Purging state of the model. A model is purged when all its binary files are removed from the server.
                     * This is performed through the [purge model](#Models/ArchiveModel) endpoint.
                     */
                    purge_info?: {
                      /** @description Boolean indicating if the model is purged. */
                      is_purged?: boolean;
                      /** @description The user ID who requested the cancellation. */
                      user_uid?: string | null;
                      /**
                       * Format: date-time
                       * @description The time when the model was purged.
                       */
                      purge_time?: string | null;
                    };
                    /**
                     * @description The current support status of the model format. 'Active' models are fully supported and maintained.
                     * 'Obsolete' ones can be used for inference and deployment, but they can no longer be optimized.
                     * In addition, training with an 'obsolete' happens from scratch rather than incrementally.
                     * @enum {string}
                     */
                    lifecycle_stage?: "active" | "obsolete";
                  })[];
                /**
                 * @description Mongo ID of the object
                 * @example 60d31793d5f1fb7e6e3c1a4c
                 */
                task_id?: string;
                /**
                 * @description Mongo ID of the object
                 * @example 60d31793d5f1fb7e6e3c1a4c
                 */
                id?: string;
                /** @description Name of the model group, typically the name of the architecture. */
                name?: string;
                /** @description The ID of the model architecture. */
                model_template_id?: string;
                /**
                 * @description The learning approach from which the model is generated.
                 *
                 * `fully_supervised` is for models that are trained through training job; while `one_shot` models are not. For example, `one_shot`
                 * is used for visual prompt models.
                 * @enum {string}
                 */
                learning_approach?: "fully_supervised" | "one_shot";
                /**
                 * @description The current support status of the model architecture. 'Active' algorithms are fully supported and maintained.
                 * 'Deprecated' ones are still supported, but not recommended for training; in a later version, they may be
                 * discontinued and become 'obsolete', which means that new models cannot be trained with such algorithms.
                 * @enum {string}
                 */
                lifecycle_stage?: "active" | "deprecated" | "obsolete";
              })[];
          };
        };
      };
      /** @description Object not found. See the examples for details. */
      404: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 400 | 404 | 405 | 409 | 412 | 413 | 415 | 422 | 423 | 500 | 501 | 503;
            /** @description Message from server */
            message: string;
            /** @description Error code from server */
            error_code: string;
          };
        };
      };
    };
  };
  /**
   * Get information on all models in a model group
   * @description Get information about a specific model group, including the models in that group.
   * Each model group represents one model architecture that has been trained in the project and
   * contains a list of successfully trained models of that architecture.
   */
  GetModelGroup: {
    parameters: {
      path: {
        /** @description The ID of the organization. */
        organization_id: string;
        /** @description The ID of the workspace. */
        workspace_id: string;
        /** @description The ID of the project. */
        project_id: string;
        /** @description The ID of the model group of interest. This can be found as `model_groups[].id` in the response body of [model group listing](#Models/GetModelGroups) endpoint. */
        model_group_id: string;
      };
    };
    responses: {
      /** @description Information on all models and their groups belonging to a project */
      200: {
        content: {
          "application/json": {
            /**
             * @description Array of models. The models at this level represent the successfully trained models. Note that these are not
             * the (OpenVINO or ONNX) optimized models;
             * the list of optimized models can be found through the [model detail](#Models/GetModelDetail) endpoint.
             */
            models?: ({
                /**
                 * @description Mongo ID of the object
                 * @example 60d31793d5f1fb7e6e3c1a4c
                 */
                id?: string;
                /** @description Name of the model. */
                name?: string;
                /** @description Creation date of the model. */
                creation_date?: string;
                /**
                 * Format: int32
                 * @description Model size in bytes.
                 */
                size?: number;
                /**
                 * Format: int32
                 * @description The aggregated size (bytes) for model-related files. This includes all the exportable binaries, such as exportable code,
                 * and the binaries from the optimized models.
                 */
                total_disk_size?: number;
                performance?: {
                  /**
                   * Format: float
                   * @description Accuracy score for the model. Only applicable for non-anomaly projects.
                   */
                  score?: number | null;
                };
                /** @description Boolean that indicates whether the label schema for the model is in sync with the latest label schema for the task containing the model */
                label_schema_in_sync?: boolean;
                /**
                 * @deprecated
                 * @description Boolean indicating whether the score of the model is the most recent score.
                 * This parameter is deprecated and should not be used, it will be removed in the future.
                 */
                score_up_to_date?: boolean;
                /** @description ID of the model storage */
                model_storage_id?: string;
                /** @description Boolean indicating that the model is used for inference requests for the project. */
                active_model?: boolean;
                /** @description Version of the model */
                version?: number;
                /**
                 * @description Purging state of the model. A model is purged when all its binary files are removed from the server.
                 * This is performed through the [purge model](#Models/ArchiveModel) endpoint.
                 */
                purge_info?: {
                  /** @description Boolean indicating if the model is purged. */
                  is_purged?: boolean;
                  /** @description The user ID who requested the cancellation. */
                  user_uid?: string | null;
                  /**
                   * Format: date-time
                   * @description The time when the model was purged.
                   */
                  purge_time?: string | null;
                };
                /**
                 * @description The current support status of the model format. 'Active' models are fully supported and maintained.
                 * 'Obsolete' ones can be used for inference and deployment, but they can no longer be optimized.
                 * In addition, training with an 'obsolete' happens from scratch rather than incrementally.
                 * @enum {string}
                 */
                lifecycle_stage?: "active" | "obsolete";
              })[];
            /**
             * @description Mongo ID of the object
             * @example 60d31793d5f1fb7e6e3c1a4c
             */
            task_id?: string;
            /**
             * @description Mongo ID of the object
             * @example 60d31793d5f1fb7e6e3c1a4c
             */
            id?: string;
            /** @description Name of the model group, typically the name of the architecture. */
            name?: string;
            /** @description The ID of the model architecture. */
            model_template_id?: string;
            /**
             * @description The learning approach from which the model is generated.
             *
             * `fully_supervised` is for models that are trained through training job; while `one_shot` models are not. For example, `one_shot`
             * is used for visual prompt models.
             * @enum {string}
             */
            learning_approach?: "fully_supervised" | "one_shot";
            /**
             * @description The current support status of the model architecture. 'Active' algorithms are fully supported and maintained.
             * 'Deprecated' ones are still supported, but not recommended for training; in a later version, they may be
             * discontinued and become 'obsolete', which means that new models cannot be trained with such algorithms.
             * @enum {string}
             */
            lifecycle_stage?: "active" | "deprecated" | "obsolete";
          };
        };
      };
      /** @description Object not found. See the examples for details. */
      404: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 400 | 404 | 405 | 409 | 412 | 413 | 415 | 422 | 423 | 500 | 501 | 503;
            /** @description Message from server */
            message: string;
            /** @description Error code from server */
            error_code: string;
          };
        };
      };
    };
  };
  /**
   * Set the latest model in the model group as the active model
   * @description Set the latest model of the model group to be the active model.
   * Active model is used to generate predictions requested through the
   * [predict](#Predictions/GetSinglePrediction) or [explain](#Predictions/GetSingleExplanation) endpoints
   * (and their batch variants).
   */
  ActivateModelGroup: {
    parameters: {
      path: {
        /** @description The ID of the organization. */
        organization_id: string;
        /** @description The ID of the workspace. */
        workspace_id: string;
        /** @description The ID of the project. */
        project_id: string;
        /** @description The ID of the model group of interest. This can be found as `model_groups[].id` in the response body of [model group listing](#Models/GetModelGroups) endpoint. */
        model_group_id: string;
      };
    };
    responses: {
      /** @description Model group successfully activated */
      200: {
        content: {
          "application/json": {
            /**
             * @description Array of models. The models at this level represent the successfully trained models. Note that these are not
             * the (OpenVINO or ONNX) optimized models;
             * the list of optimized models can be found through the [model detail](#Models/GetModelDetail) endpoint.
             */
            models?: ({
                /**
                 * @description Mongo ID of the object
                 * @example 60d31793d5f1fb7e6e3c1a4c
                 */
                id?: string;
                /** @description Name of the model. */
                name?: string;
                /** @description Creation date of the model. */
                creation_date?: string;
                /**
                 * Format: int32
                 * @description Model size in bytes.
                 */
                size?: number;
                /**
                 * Format: int32
                 * @description The aggregated size (bytes) for model-related files. This includes all the exportable binaries, such as exportable code,
                 * and the binaries from the optimized models.
                 */
                total_disk_size?: number;
                performance?: {
                  /**
                   * Format: float
                   * @description Accuracy score for the model. Only applicable for non-anomaly projects.
                   */
                  score?: number | null;
                };
                /** @description Boolean that indicates whether the label schema for the model is in sync with the latest label schema for the task containing the model */
                label_schema_in_sync?: boolean;
                /**
                 * @deprecated
                 * @description Boolean indicating whether the score of the model is the most recent score.
                 * This parameter is deprecated and should not be used, it will be removed in the future.
                 */
                score_up_to_date?: boolean;
                /** @description ID of the model storage */
                model_storage_id?: string;
                /** @description Boolean indicating that the model is used for inference requests for the project. */
                active_model?: boolean;
                /** @description Version of the model */
                version?: number;
                /**
                 * @description Purging state of the model. A model is purged when all its binary files are removed from the server.
                 * This is performed through the [purge model](#Models/ArchiveModel) endpoint.
                 */
                purge_info?: {
                  /** @description Boolean indicating if the model is purged. */
                  is_purged?: boolean;
                  /** @description The user ID who requested the cancellation. */
                  user_uid?: string | null;
                  /**
                   * Format: date-time
                   * @description The time when the model was purged.
                   */
                  purge_time?: string | null;
                };
                /**
                 * @description The current support status of the model format. 'Active' models are fully supported and maintained.
                 * 'Obsolete' ones can be used for inference and deployment, but they can no longer be optimized.
                 * In addition, training with an 'obsolete' happens from scratch rather than incrementally.
                 * @enum {string}
                 */
                lifecycle_stage?: "active" | "obsolete";
              })[];
            /**
             * @description Mongo ID of the object
             * @example 60d31793d5f1fb7e6e3c1a4c
             */
            task_id?: string;
            /**
             * @description Mongo ID of the object
             * @example 60d31793d5f1fb7e6e3c1a4c
             */
            id?: string;
            /** @description Name of the model group, typically the name of the architecture. */
            name?: string;
            /** @description The ID of the model architecture. */
            model_template_id?: string;
            /**
             * @description The learning approach from which the model is generated.
             *
             * `fully_supervised` is for models that are trained through training job; while `one_shot` models are not. For example, `one_shot`
             * is used for visual prompt models.
             * @enum {string}
             */
            learning_approach?: "fully_supervised" | "one_shot";
            /**
             * @description The current support status of the model architecture. 'Active' algorithms are fully supported and maintained.
             * 'Deprecated' ones are still supported, but not recommended for training; in a later version, they may be
             * discontinued and become 'obsolete', which means that new models cannot be trained with such algorithms.
             * @enum {string}
             */
            lifecycle_stage?: "active" | "deprecated" | "obsolete";
          };
        };
      };
      /** @description Object not found. See the examples for details. */
      404: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 400 | 404 | 405 | 409 | 412 | 413 | 415 | 422 | 423 | 500 | 501 | 503;
            /** @description Message from server */
            message: string;
            /** @description Error code from server */
            error_code: string;
          };
        };
      };
      /** @description Model group cannot be activated. It does not contain successful models */
      405: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 400 | 404 | 405 | 409 | 412 | 413 | 415 | 422 | 423 | 500 | 501 | 503;
            /** @description Message from server */
            message: string;
            /** @description Error code from server */
            error_code: string;
          };
        };
      };
    };
  };
  /**
   * Get detailed information on a model
   * @description Get detailed information on a model. The response contains the base model version as well as the list of
   * optimized models (OpenVINO and ONNX) that are generated from the base model.
   */
  GetModelDetail: {
    parameters: {
      path: {
        /** @description The ID of the organization. */
        organization_id: string;
        /** @description The ID of the workspace. */
        workspace_id: string;
        /** @description The ID of the project. */
        project_id: string;
        /** @description The ID of the model group of interest. This can be found as `model_groups[].id` in the response body of [model group listing](#Models/GetModelGroups) endpoint. */
        model_group_id: string;
        /**
         * @description The ID of the model of interest. This can be found as `model_groups[].models[].id` from the response of [model group listing](#Models/GetModelGroups)
         * endpoint or `models[].id` from [model group detail](#Models/GetModelGroup) endpoint.
         */
        model_id: string;
      };
    };
    responses: {
      /** @description Detailed information on a model */
      200: {
        content: {
          "application/json": {
            /**
             * @description Mongo ID of the object
             * @example 60d31793d5f1fb7e6e3c1a4c
             */
            id?: string;
            /** @description Network architecture of the model */
            architecture?: string;
            /** @description Name of the model */
            name?: string;
            /** @description Creation date of the model */
            creation_date?: string;
            /**
             * Format: int32
             * @description Model size in bytes
             */
            size?: number;
            /**
             * Format: int32
             * @description The aggregated size (bytes) for model-related files. This includes all the exportable binaries, such as exportable code,
             * and the binaries from the optimized models.
             */
            total_disk_size?: number;
            performance?: {
              /**
               * Format: float
               * @description Accuracy score for the model. Only applicable for non-anomaly projects.
               */
              score?: number | null;
            };
            /** @description Boolean that indicates whether the label schema for the model is in sync with the latest label schema for the task containing the model */
            label_schema_in_sync?: boolean;
            /**
             * @deprecated
             * @description Boolean that indicates whether the score of the model is the most recent score.
             * This parameter is deprecated and should not be used, it will be removed in the future.
             */
            score_up_to_date?: boolean;
            /**
             * Format: int32
             * @deprecated
             * @description FPS throughput for the model.
             * This parameter is deprecated and should not be used, it will be removed in the future.
             */
            fps_throughput?: number;
            /**
             * Format: int32
             * @deprecated
             * @description Latency for the model, in ms.
             * This parameter is deprecated and should not be used, it will be removed in the future.
             */
            latency?: number;
            precision?: string[];
            /**
             * @deprecated
             * @description Type of device the model is best used on.
             * This parameter is deprecated and should not be used, it will be removed in the future.
             */
            target_device?: string;
            /**
             * @deprecated
             * @description Detailed type of device the model is best used on.
             * This parameter is deprecated and should not be used, it will be removed in the future.
             */
            target_device_type?: string;
            /** @description Version of the model */
            version?: number;
            /** @description ID of the previous model */
            previous_revision_id?: string;
            /** @description ID of the previous trained model */
            previous_trained_revision_id?: string;
            /** @description Array of optimized models */
            optimized_models?: ({
                /** @description ID of the optimized model */
                id?: string;
                /**
                 * Format: int32
                 * @description Model size in bytes
                 */
                size?: number;
                /**
                 * Format: int32
                 * @deprecated
                 * @description FPS throughput of the optimized model.
                 * This parameter is deprecated and should not be used, it will be removed in the future.
                 */
                fps_throughput?: number;
                /**
                 * Format: int32
                 * @deprecated
                 * @description Latency for the optimized model, in ms.
                 * This parameter is deprecated and should not be used, it will be removed in the future.
                 */
                latency?: number;
                optimization_levels?: Record<string, never>;
                /** @description Array of optimization methods */
                optimization_methods?: string[];
                /** @description Optimization type of the model */
                optimization_type?: string;
                /** @description Precision of the model */
                precision?: string[];
                /** @description Whether the model also outputs eXplainable AI artifacts, e.g. saliency maps. */
                has_xai_head?: boolean;
                /**
                 * @description Format of the model
                 * @enum {string}
                 */
                model_format?: "OpenVINO" | "ONNX";
                /** @description Version of the model */
                version?: number;
                /** @description ID of the prevoius model */
                previous_revision_id?: string;
                /** @description ID of the previous trained model */
                previous_trained_revision_id?: string;
                performance?: {
                  /**
                   * Format: float
                   * @description Accuracy score for the model. Only applicable for non-anomaly projects.
                   */
                  score?: number | null;
                };
                /**
                 * @deprecated
                 * @description Type of device the model is best used on.
                 * This parameter is deprecated and should not be used, it will be removed in the future.
                 */
                target_device?: string;
                /**
                 * @deprecated
                 * @description Detailed type of device the model is best used on.
                 * This parameter is deprecated and should not be used, it will be removed in the future.
                 */
                target_device_type?: string;
                /** @description Name of the model */
                name?: string;
                /**
                 * @description Status of the model
                 * @enum {string}
                 */
                model_status?: "NOT_READY" | "WEIGHTS_INITIALIZED" | "SUCCESS" | "FAILED" | "NOT_IMPROVED";
                /** @description Array of additional configuration parameters */
                configurations?: {
                    /** @description name of the configuration parameter */
                    name?: string;
                    /** @description value of the configuration parameter */
                    value?: unknown;
                  }[];
                /**
                 * @description The current support status of the model format. 'Active' models are fully supported and maintained.
                 * 'Obsolete' ones can be used for inference and deployment, but they can no longer be optimized.
                 * In addition, training with an 'obsolete' happens from scratch rather than incrementally.
                 * @enum {string}
                 */
                lifecycle_stage?: "active" | "obsolete";
              })[];
            /** @description Array of labels */
            labels?: ({
                /** @description Label name, must be unique */
                name: string;
                /**
                 * @description Mongo ID of the object
                 * @example 60d31793d5f1fb7e6e3c1a4c
                 */
                id: string;
                /** @description Label color, picked at random if not specified */
                color: string;
                /** @description Name of label group */
                group: string;
                /** @description Name of parent label */
                parent_id: string | null;
                /** @description Indicates whether the label is an empty label */
                is_empty: boolean;
                /** @description Indicates whether the label is anomalous or not */
                is_anomalous: boolean;
                /** @description Indicates whether the label is deleted */
                is_deleted?: boolean;
                /** @description Key or combination of key to select this label. Can be empty (no key). */
                hotkey: string;
              })[];
            training_dataset_info?: {
              /**
               * @description Mongo ID of the object
               * @example 60d31793d5f1fb7e6e3c1a4c
               */
              dataset_storage_id?: string;
              /**
               * @description Mongo ID of the object
               * @example 60d31793d5f1fb7e6e3c1a4c
               */
              dataset_revision_id?: string;
              /**
               * Format: int32
               * @description The number of items in the training dataset. Note that for the second task in a task chain, this could be more than
               * `n_images + n_frames` because each bounding box of the first task corresponds to one dataset item of the second task.
               */
              n_samples?: number;
              /**
               * Format: int32
               * @description The number of distinct images in the dataset
               */
              n_images?: number;
              /**
               * Format: int32
               * @description The number of distinct video frames in the dataset
               */
              n_frames?: number;
            };
            /** @description Information about the framework used to train the model */
            training_framework?: {
              /**
               * @description Type of the training framework
               * @enum {string}
               */
              type?: "otx" | "third_party";
              /** @description Version of the training framework */
              version?: string;
            };
            /**
             * @description Purging state of the model. A model is purged when all its binary files are removed from the server.
             * This is performed through the [purge model](#Models/ArchiveModel) endpoint.
             */
            purge_info?: {
              /** @description Boolean indicating if the model is purged. */
              is_purged?: boolean;
              /** @description The user ID who requested the cancellation. */
              user_uid?: string | null;
              /**
               * Format: date-time
               * @description The time when the model was purged.
               */
              purge_time?: string | null;
            };
            /**
             * @description The learning approach from which the model is generated.
             *
             * `fully_supervised` is for models that are trained through training job; while `one_shot` models are not. For example, `one_shot`
             * is used for visual prompt models.
             * @enum {string}
             */
            learning_approach?: "fully_supervised" | "one_shot";
            /**
             * @description The current support status of the model format. 'Active' models are fully supported and maintained.
             * 'Obsolete' ones can be used for inference and deployment, but they can no longer be optimized.
             * In addition, training with an 'obsolete' happens from scratch rather than incrementally.
             * @enum {string}
             */
            lifecycle_stage?: "active" | "obsolete";
          };
        };
      };
      /** @description Object not found. See the examples for details. */
      404: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 400 | 404 | 405 | 409 | 412 | 413 | 415 | 422 | 423 | 500 | 501 | 503;
            /** @description Message from server */
            message: string;
            /** @description Error code from server */
            error_code: string;
          };
        };
      };
    };
  };
  /**
   * Get statistics for a model
   * @description Get statistics for a model. The statistics includes training and evaluation statistics.
   * The response will be a list of charts; each chart will be one of the following types: `text`, `bar`, `radial_bar`, `line` or `matrix`. For each type of chart, the response body has a different
   * format. See the schemas for information on the format of the response.
   */
  GetModelStatistics: {
    parameters: {
      path: {
        /** @description The ID of the organization. */
        organization_id: string;
        /** @description The ID of the workspace. */
        workspace_id: string;
        /** @description The ID of the project. */
        project_id: string;
        /** @description The ID of the model group of interest. This can be found as `model_groups[].id` in the response body of [model group listing](#Models/GetModelGroups) endpoint. */
        model_group_id: string;
        /**
         * @description The ID of the model of interest. This can be found as `model_groups[].models[].id` from the response of [model group listing](#Models/GetModelGroups)
         * endpoint or `models[].id` from [model group detail](#Models/GetModelGroup) endpoint.
         */
        model_id: string;
      };
    };
    responses: {
      /** @description Training statistics for a model */
      200: {
        content: {
          "application/json": {
            model_statistics?: ({
                /** @description Header describing the chart */
                header?: string;
                /** @description Unique key for the chart */
                key?: string;
                /**
                 * @description Type of chart. Current implementation allows 'line', 'text', 'bar', 'radial_bar' and 'matrix'.
                 * @enum {string}
                 */
                type?: "text" | "line" | "bar" | "radial_bar" | "matrix";
                value?: OneOf<[string | number, ({
                    /** @description Name of the bar */
                    header?: string;
                    /** @description Unique key for the bar */
                    key?: string;
                    /** @description Value for the bar */
                    value?: number;
                    /** @description Color of the bar in hex format */
                    color?: string | null;
                  })[], {
                  /** @description Label of the x-axis for the line chart */
                  x_axis_label: string;
                  /** @description Label of the y-axis for the line chart */
                  y_axis_label: string;
                  /** @description Color of the bar in hex format */
                  color?: string | null;
                  /** @description Array of line data, each containing the information for one line. */
                  line_data: {
                      /** @description List of coordinates of the points in the line chart */
                      points?: {
                          /** @description X coordinate of the point */
                          x?: number;
                          /** @description Y coordinate of the point */
                          y?: number;
                        }[];
                    }[];
                }, {
                  /** @description The header for all the rows in the matrix */
                  row_header: string;
                  /** @description The header for all the columns in the matrix */
                  column_header: string;
                  /** @description Array of matrices */
                  matrix_data: {
                      /** @description Array containing the names of the matrix rows */
                      row_names?: string[];
                      /** @description Array containing the names of the matrix columns */
                      column_names?: string[];
                      /** @description Array of matrix values */
                      matrix_values?: number[][];
                    }[];
                }]>;
              })[];
          };
        };
      };
      /** @description Object not found. See the examples for details. */
      404: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 400 | 404 | 405 | 409 | 412 | 413 | 415 | 422 | 423 | 500 | 501 | 503;
            /** @description Message from server */
            message: string;
            /** @description Error code from server */
            error_code: string;
          };
        };
      };
    };
  };
  /**
   * Export a model.
   * @description Export a zip file with data from a base (non-optimized) model.
   * This endpoint only handles the export of base model weights, and does not include code.
   */
  ExportModel: {
    parameters: {
      path: {
        /** @description The ID of the organization. */
        organization_id: string;
        /** @description The ID of the workspace. */
        workspace_id: string;
        /** @description The ID of the project. */
        project_id: string;
        /** @description The ID of the model group of interest. This can be found as `model_groups[].id` in the response body of [model group listing](#Models/GetModelGroups) endpoint. */
        model_group_id: string;
        /**
         * @description The ID of the model of interest. This can be found as `model_groups[].models[].id` from the response of [model group listing](#Models/GetModelGroups)
         * endpoint or `models[].id` from [model group detail](#Models/GetModelGroup) endpoint.
         */
        model_id: string;
      };
    };
    responses: {
      /** @description Export a full model */
      200: {
        content: {
          "zip file": string;
        };
      };
      /** @description Object not found. See the examples for details. */
      404: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 400 | 404 | 405 | 409 | 412 | 413 | 415 | 422 | 423 | 500 | 501 | 503;
            /** @description Message from server */
            message: string;
            /** @description Error code from server */
            error_code: string;
          };
        };
      };
    };
  };
  /**
   * Export an optimized model
   * @description Export a zip file with data from an optimized model (OpenVINO or ONNX).
   */
  ExportOptimizedModel: {
    parameters: {
      query?: {
        /**
         * @description Only applicable to OpenVINO-optimized models. Set to `true` to only download the model binaries; set to `false` to also include
         * the code in the exported file.
         */
        model_only?: boolean;
      };
      path: {
        /** @description The ID of the organization. */
        organization_id: string;
        /** @description The ID of the workspace. */
        workspace_id: string;
        /** @description The ID of the project. */
        project_id: string;
        /** @description The ID of the model group of interest. This can be found as `model_groups[].id` in the response body of [model group listing](#Models/GetModelGroups) endpoint. */
        model_group_id: string;
        /**
         * @description The ID of the model of interest. This can be found as `model_groups[].models[].id` from the response of [model group listing](#Models/GetModelGroups)
         * endpoint or `models[].id` from [model group detail](#Models/GetModelGroup) endpoint.
         */
        model_id: string;
        /** @description The ID of the optimized model */
        optimized_model_id: string;
      };
    };
    responses: {
      /** @description Export an optimized model */
      200: {
        content: {
          "zip file": string;
        };
      };
      /** @description Bad request. See the examples for details. */
      400: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 400 | 404 | 405 | 409 | 412 | 413 | 415 | 422 | 423 | 500 | 501 | 503;
            /** @description Message from server */
            message: string;
            /** @description Error code from server */
            error_code: string;
          };
        };
      };
      /** @description Object not found. See the examples for details. */
      404: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 400 | 404 | 405 | 409 | 412 | 413 | 415 | 422 | 423 | 500 | 501 | 503;
            /** @description Message from server */
            message: string;
            /** @description Error code from server */
            error_code: string;
          };
        };
      };
    };
  };
  /**
   * Optimize a model
   * @description Submit an optimization job for a model.
   * The optimization is done through [post-training quantization](https://github.com/openvinotoolkit/nncf/blob/develop/docs/usage/post_training_compression/post_training_quantization/Usage.md).
   */
  OptimizeModel: {
    parameters: {
      path: {
        /** @description The ID of the organization. */
        organization_id: string;
        /** @description The ID of the workspace. */
        workspace_id: string;
        /** @description The ID of the project. */
        project_id: string;
        /** @description The ID of the model group of interest. This can be found as `model_groups[].id` in the response body of [model group listing](#Models/GetModelGroups) endpoint. */
        model_group_id: string;
        /**
         * @description The ID of the model of interest. This can be found as `model_groups[].models[].id` from the response of [model group listing](#Models/GetModelGroups)
         * endpoint or `models[].id` from [model group detail](#Models/GetModelGroup) endpoint.
         */
        model_id: string;
      };
    };
    requestBody?: {
      content: {
        "application/json": {
          /** @description This field is deprecated and ignored by the server. */
          enable_nncf_optimization?: boolean;
          /** @description This field is deprecated and ignored by the server. */
          enable_pot_optimization?: boolean;
          /** @description This field is deprecated and ignored by the server. */
          optimization_parameters?: Record<string, never>;
        };
      };
    };
    responses: {
      /** @description Optimization job is submitted */
      200: {
        content: {
          "application/json": {
            /**
             * @description Mongo ID of the object
             * @example 60d31793d5f1fb7e6e3c1a4c
             */
            job_id?: string;
          };
        };
      };
      /** @description Object not found. See the examples for details. */
      404: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 400 | 404 | 405 | 409 | 412 | 413 | 415 | 422 | 423 | 500 | 501 | 503;
            /** @description Message from server */
            message: string;
            /** @description Error code from server */
            error_code: string;
          };
        };
      };
    };
  };
  /**
   * Optimize a model. Note - This endpoint is deprecated. Please use the new endpoint `:optimize` instead.
   * @deprecated
   * @description Submit an optimization job for a model.
   * The optimization is done through [post-training quantization](https://github.com/openvinotoolkit/nncf/blob/develop/docs/usage/post_training_compression/post_training_quantization/Usage.md).
   */
  LegacyOptimizeModel: {
    parameters: {
      path: {
        /** @description The ID of the organization. */
        organization_id: string;
        /** @description The ID of the workspace. */
        workspace_id: string;
        /** @description The ID of the project. */
        project_id: string;
        /** @description The ID of the model group of interest. This can be found as `model_groups[].id` in the response body of [model group listing](#Models/GetModelGroups) endpoint. */
        model_group_id: string;
        /**
         * @description The ID of the model of interest. This can be found as `model_groups[].models[].id` from the response of [model group listing](#Models/GetModelGroups)
         * endpoint or `models[].id` from [model group detail](#Models/GetModelGroup) endpoint.
         */
        model_id: string;
      };
    };
    requestBody?: {
      content: {
        "application/json": {
          /** @description This field is deprecated and ignored by the server. */
          enable_nncf_optimization?: boolean;
          /** @description This field is deprecated and ignored by the server. */
          enable_pot_optimization?: boolean;
          /** @description This field is deprecated and ignored by the server. */
          optimization_parameters?: Record<string, never>;
        };
      };
    };
    responses: {
      /** @description Optimization job is submitted */
      200: {
        content: {
          "application/json": {
            /**
             * @description Mongo ID of the object
             * @example 60d31793d5f1fb7e6e3c1a4c
             */
            job_id?: string;
          };
        };
      };
      /** @description Object not found. See the examples for details. */
      404: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 400 | 404 | 405 | 409 | 412 | 413 | 415 | 422 | 423 | 500 | 501 | 503;
            /** @description Message from server */
            message: string;
            /** @description Error code from server */
            error_code: string;
          };
        };
      };
    };
  };
  /**
   * Archive a model
   * @description Archive a model. This will permanently delete all the binary files related to the model including base model
   * weights, optimized model weights and exportable code. This endpoint can only be called on base models, not optimized
   * models. Additionally, the model must not be the latest in a model group or be the active model.
   */
  ArchiveModel: {
    parameters: {
      path: {
        /** @description The ID of the organization. */
        organization_id: string;
        /** @description The ID of the workspace. */
        workspace_id: string;
        /** @description The ID of the project. */
        project_id: string;
        /** @description The ID of the model group of interest. This can be found as `model_groups[].id` in the response body of [model group listing](#Models/GetModelGroups) endpoint. */
        model_group_id: string;
        /**
         * @description The ID of the model of interest. This can be found as `model_groups[].models[].id` from the response of [model group listing](#Models/GetModelGroups)
         * endpoint or `models[].id` from [model group detail](#Models/GetModelGroup) endpoint.
         */
        model_id: string;
      };
    };
    responses: {
      /** @description Model archived successfully */
      204: {
        content: never;
      };
      /** @description Object not found. See the examples for details. */
      404: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 400 | 404 | 405 | 409 | 412 | 413 | 415 | 422 | 423 | 500 | 501 | 503;
            /** @description Message from server */
            message: string;
            /** @description Error code from server */
            error_code: string;
          };
        };
      };
      /** @description Model can not be archived. */
      422: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 400 | 404 | 405 | 409 | 412 | 413 | 415 | 422 | 423 | 500 | 501 | 503;
            /** @description Message from server */
            message: string;
            /** @description Error code from server */
            error_code: string;
          };
        };
      };
    };
  };
  /**
   * Get a prediction for an image
   * @description Get a prediction for an image. This endpoint currently only supports 'latest' prediction type, where the server returns the latest prediction from cache. Other types have been deprecated: if you want to generate a fresh prediction with the active model ('online') then use the pipelines/<pipeline_id>:predict endpoint.
   */
  GetImagePrediction: {
    parameters: {
      query?: {
        /** @description The ID of the task in the project. */
        task_id?: string;
        /** @description The ID of the ROI to predict on. Can only be an ID of a user annotated ROI. Note that if you pass an ID for an ROI you should in most cases also pass a task_id. For example, in a detection -> classification chain if a user  annotates a ROI (box for first task) and requests a prediction for this ROI you don't want the detection task to have to find the same object again that the user annotated but immediately skip to the classification task. */
        roi_id?: string;
      };
      path: {
        /** @description The ID of the organization. */
        organization_id: string;
        /** @description The ID of the workspace. */
        workspace_id: string;
        /** @description The ID of the project. */
        project_id: string;
        /** @description The ID of the dataset in the project. */
        dataset_id: string;
        /** @description The ID of the image. */
        image_id: string;
        /**
         * @description Either the id of a prediction or 'latest'. The latter fetches the latest prediction from the cache, if available.
         * @example latest
         */
        prediction_type_or_id: string | "latest";
      };
    };
    responses: {
      /** @description Prediction successfully retrieved */
      200: {
        content: {
          "application/json": {
            /** @description List of predictions */
            annotations?: ({
                /**
                 * @description A UUID, used to identify an annotation.
                 * @example e42cf382-5f7b-4fda-980a-fa0fab00243c
                 */
                id: string;
                shape?: OneOf<[{
                  /**
                   * @description Type of the shape.
                   * @enum {string}
                   */
                  type: "RECTANGLE";
                  /** @description x-coordinate of the left side of the rectangle. Coordinates are pixel values. */
                  x: number;
                  /** @description y-coordinate of the top of the rectangle. Coordinates are pixel values. */
                  y: number;
                  /** @description Width of the rectangle. Coordinates are pixel values. */
                  width: number;
                  /** @description Height of the rectangle. Coordinates are pixel values. */
                  height: number;
                }, {
                  /**
                   * @description Type of the shape.
                   * @enum {string}
                   */
                  type: "POLYGON";
                  /** @description Array of points that define the polygon. */
                  points: {
                      /** @description x-coordinate of the point. Coordinates are pixel values. */
                      x: number;
                      /** @description y-coordinate of the point. Coordinates are pixel values. */
                      y: number;
                    }[];
                }, {
                  /**
                   * @description Type of the shape.
                   * @enum {string}
                   */
                  type: "ELLIPSE";
                  /** @description Lowest x-coordinate of the ellipse. Coordinates are pixel values. */
                  x: number;
                  /** @description Lowest y-coordinate of the ellipse. Coordinates are pixel values. */
                  y: number;
                  /** @description Width of the ellipse. Coordinates are pixel values. */
                  width: number;
                  /** @description Height of the ellipse. Coordinates are pixel values. */
                  height: number;
                }, {
                  /**
                   * @description Type of the shape.
                   * @enum {string}
                   */
                  type: "ROTATED_RECTANGLE";
                  /** @description Center x-coordinate of the rotated rectangle. Coordinates are pixel values. */
                  x: number;
                  /** @description Center y-coordinate of the rotated rectangle. Coordinates are pixel values. */
                  y: number;
                  /** @description Width of the rotated rectangle (not the encapsulating box of the rectangle). Coordinates are pixel values. */
                  width: number;
                  /** @description Height of the rotated rectangle (not the encapsulating box of the rectangle). Coordinates are pixel values. */
                  height: number;
                  /** @description Clockwise angle in degrees for the rectangle. */
                  angle: number;
                }, {
                  /**
                   * @description Type of the shape.
                   * @enum {string}
                   */
                  type: "KEYPOINT";
                  /** @description X-coordinate of the keypoint. Coordinates are pixel values. */
                  x: number;
                  /** @description Y-coordinate of the keypoint. Coordinates are pixel values. */
                  y: number;
                  /** @description Indicates whether the feature the keypoint is describing is visible in the image. */
                  is_visible: boolean;
                }]>;
                /** @description List of labels */
                labels: ({
                    /**
                     * @description Mongo ID of the object
                     * @example 60d31793d5f1fb7e6e3c1a4c
                     */
                    id?: string;
                    /**
                     * Probability
                     * Format: float
                     * @description Estimated probability of a prediction. For annotations, this is set to 1.
                     */
                    probability?: number;
                    source?: {
                      /** @description User name of the user that added the label or accepted the prediction */
                      user_id?: string | null;
                      /** @description Model id of the model that predicted the label */
                      model_id?: string | null;
                      /** @description Model storage id of model that predicted the label */
                      model_storage_id?: string | null;
                    };
                  })[];
                /** @description Modification date */
                modified: string;
                /** @description List of labels IDs for which the annotation should be revisited */
                labels_to_revisit?: string[];
              })[];
            /**
             * @description Mongo ID of the object
             * @example 60d31793d5f1fb7e6e3c1a4c
             */
            id?: string;
            /**
             * @description Kind of annotation (prediction or annotation).
             * @enum {string}
             */
            kind?: "prediction";
            media_identifier?: {
              /**
               * @description Mongo ID of the object
               * @example 60d31793d5f1fb7e6e3c1a4c
               */
              image_id?: string;
              /**
               * @description Type of media. 'image' for images, 'video' for videos.
               * @enum {string}
               */
              type?: "image";
            };
            /** @description Modification date */
            modified?: string;
            /**
             * @deprecated
             * @description List of result media options
             * This parameter is deprecated and should not be used, it will be removed in the future.
             */
            maps?: {
                /**
                 * @description Mongo ID of the object
                 * @example 60d31793d5f1fb7e6e3c1a4c
                 */
                id?: string;
                /** @description Name for the result media option */
                name?: string;
                /** @description Type of the result media */
                type?: string;
                /** @description Url where the result media can be found */
                url?: string;
                /** @description A base 64 encoded representation of the binary data of the result media */
                binary?: string;
                /**
                 * @description Mongo ID of the object
                 * @example 60d31793d5f1fb7e6e3c1a4c
                 */
                label_id?: string;
                roi?: {
                  /**
                   * @description Mongo ID of the object
                   * @example 60d31793d5f1fb7e6e3c1a4c
                   */
                  id?: string;
                  /**
                   * Rectangle
                   * @example {
                   *   "type": "RECTANGLE",
                   *   "x": 320,
                   *   "y": 240,
                   *   "width": 50,
                   *   "height": 25
                   * }
                   */
                  shape?: {
                    /**
                     * @description Type of the shape.
                     * @enum {string}
                     */
                    type: "RECTANGLE";
                    /** @description x-coordinate of the left side of the rectangle. Coordinates are pixel values. */
                    x: number;
                    /** @description y-coordinate of the top of the rectangle. Coordinates are pixel values. */
                    y: number;
                    /** @description Width of the rectangle. Coordinates are pixel values. */
                    width: number;
                    /** @description Height of the rectangle. Coordinates are pixel values. */
                    height: number;
                  };
                };
              }[];
          };
        };
      };
      /** @description No prediction available for the requested media. */
      204: {
        content: never;
      };
      /** @description Object not found. See the examples for details. */
      404: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 400 | 404 | 405 | 409 | 412 | 413 | 415 | 422 | 423 | 500 | 501 | 503;
            /** @description Message from server */
            message: string;
            /** @description Error code from server */
            error_code: string;
          };
        };
      };
    };
  };
  /**
   * Get cached predictions for a video
   * @description Get predictions for a video from the database cache. Note that this endpoint **does not** generate predictions on the fly. For predictions on the fly,
   * use the [single prediction](#Predictions/GetSinglePrediction) or the [batch prediction](#Predictions/GetBatchPrediction) endpoints.
   *
   * Parameters `start_frame`, `end_frame` and `frameskip` can be used
   * to only get predictions in a certain range. There is a maximum amount of 20 predictions that can be
   * returned by the endpoint. If the combination of `start_frame`, `end_frame` and `frameskip` results in more than 20 predictions,
   * only the first 20 frames will be returned and there is a `next_page` object in the response pointing to the URL that will return
   * the next predictions.
   */
  GetCachedVideoPrediction: {
    parameters: {
      query?: {
        /**
         * @description The starting index of the range of interest. This is a 0-based inclusive index, meaning to include the first frame of the video,
         * this parameter should be set to `0`. The value cannot be bigger than `frame_count-1`.
         * The `frame_count` is the total number of frames contained in the video
         * and it can be retrieved from the response body of [video detail](#Media/GetVideoDetail) endpoint.
         */
        start_frame?: number;
        /** @description :- The ending index of the range of interest. This is a 0-based inclusive index, meaning to include the last frame of the video, this parameter should be set to `frame_count-1`; the value cannot be bigger than `frame_count-1`. The `frame_count` is the total number of frames contained in the video and it can be retrieved from the response body of [video detail](#Media/GetVideoDetail) endpoint. */
        end_frame?: number;
        /**
         * @description Set to the number of desired frame intervals in the response. For example, to retrieve all frame annotations of the video, set this value to `1`.
         * If not set, this value will be equal to the video fps. The video fps can be obtained from the response of the [video detail](#Media/GetVideoDetail)
         * endpoint.
         */
        frameskip?: number;
      };
      path: {
        /** @description The ID of the organization. */
        organization_id: string;
        /** @description The ID of the workspace. */
        workspace_id: string;
        /** @description The ID of the project. */
        project_id: string;
        /** @description The ID of the dataset in the project. */
        dataset_id: string;
        /** @description The ID of the video. */
        video_id: string;
      };
    };
    responses: {
      /** @description Predictions successfully retrieved */
      200: {
        content: {
          "application/json": {
            /** @description Array of video frame predictions */
            video_predictions?: ({
                /** @description List of predictions */
                annotations?: ({
                    /**
                     * @description A UUID, used to identify an annotation.
                     * @example e42cf382-5f7b-4fda-980a-fa0fab00243c
                     */
                    id: string;
                    shape?: OneOf<[{
                      /**
                       * @description Type of the shape.
                       * @enum {string}
                       */
                      type: "RECTANGLE";
                      /** @description x-coordinate of the left side of the rectangle. Coordinates are pixel values. */
                      x: number;
                      /** @description y-coordinate of the top of the rectangle. Coordinates are pixel values. */
                      y: number;
                      /** @description Width of the rectangle. Coordinates are pixel values. */
                      width: number;
                      /** @description Height of the rectangle. Coordinates are pixel values. */
                      height: number;
                    }, {
                      /**
                       * @description Type of the shape.
                       * @enum {string}
                       */
                      type: "POLYGON";
                      /** @description Array of points that define the polygon. */
                      points: {
                          /** @description x-coordinate of the point. Coordinates are pixel values. */
                          x: number;
                          /** @description y-coordinate of the point. Coordinates are pixel values. */
                          y: number;
                        }[];
                    }, {
                      /**
                       * @description Type of the shape.
                       * @enum {string}
                       */
                      type: "ELLIPSE";
                      /** @description Lowest x-coordinate of the ellipse. Coordinates are pixel values. */
                      x: number;
                      /** @description Lowest y-coordinate of the ellipse. Coordinates are pixel values. */
                      y: number;
                      /** @description Width of the ellipse. Coordinates are pixel values. */
                      width: number;
                      /** @description Height of the ellipse. Coordinates are pixel values. */
                      height: number;
                    }, {
                      /**
                       * @description Type of the shape.
                       * @enum {string}
                       */
                      type: "ROTATED_RECTANGLE";
                      /** @description Center x-coordinate of the rotated rectangle. Coordinates are pixel values. */
                      x: number;
                      /** @description Center y-coordinate of the rotated rectangle. Coordinates are pixel values. */
                      y: number;
                      /** @description Width of the rotated rectangle (not the encapsulating box of the rectangle). Coordinates are pixel values. */
                      width: number;
                      /** @description Height of the rotated rectangle (not the encapsulating box of the rectangle). Coordinates are pixel values. */
                      height: number;
                      /** @description Clockwise angle in degrees for the rectangle. */
                      angle: number;
                    }, {
                      /**
                       * @description Type of the shape.
                       * @enum {string}
                       */
                      type: "KEYPOINT";
                      /** @description X-coordinate of the keypoint. Coordinates are pixel values. */
                      x: number;
                      /** @description Y-coordinate of the keypoint. Coordinates are pixel values. */
                      y: number;
                      /** @description Indicates whether the feature the keypoint is describing is visible in the image. */
                      is_visible: boolean;
                    }]>;
                    /** @description List of labels */
                    labels: ({
                        /**
                         * @description Mongo ID of the object
                         * @example 60d31793d5f1fb7e6e3c1a4c
                         */
                        id?: string;
                        /**
                         * Probability
                         * Format: float
                         * @description Estimated probability of a prediction. For annotations, this is set to 1.
                         */
                        probability?: number;
                        source?: {
                          /** @description User name of the user that added the label or accepted the prediction */
                          user_id?: string | null;
                          /** @description Model id of the model that predicted the label */
                          model_id?: string | null;
                          /** @description Model storage id of model that predicted the label */
                          model_storage_id?: string | null;
                        };
                      })[];
                    /** @description Modification date */
                    modified: string;
                    /** @description List of labels IDs for which the annotation should be revisited */
                    labels_to_revisit?: string[];
                  })[];
                /**
                 * @description Mongo ID of the object
                 * @example 60d31793d5f1fb7e6e3c1a4c
                 */
                id?: string;
                /**
                 * @description Kind of annotation (prediction or annotation).
                 * @enum {string}
                 */
                kind?: "prediction";
                media_identifier?: {
                  /** Format: int32 */
                  frame_index?: number;
                  /**
                   * @description Mongo ID of the object
                   * @example 60d31793d5f1fb7e6e3c1a4c
                   */
                  video_id?: string;
                  /**
                   * @description Type of media. 'image' for images, 'video' for videos.
                   * @enum {string}
                   */
                  type?: "video_frame";
                };
                /** @description Modification date */
                modified?: string;
                /**
                 * @deprecated
                 * @description List of result media options
                 * This parameter is deprecated and should not be used, it will be removed in the future.
                 */
                maps?: {
                    /**
                     * @description Mongo ID of the object
                     * @example 60d31793d5f1fb7e6e3c1a4c
                     */
                    id?: string;
                    /** @description Name for the result media option */
                    name?: string;
                    /** @description Type of the result media */
                    type?: string;
                    /** @description Url where the result media can be found */
                    url?: string;
                    /** @description A base 64 encoded representation of the binary data of the result media */
                    binary?: string;
                    /**
                     * @description Mongo ID of the object
                     * @example 60d31793d5f1fb7e6e3c1a4c
                     */
                    label_id?: string;
                    roi?: {
                      /**
                       * @description Mongo ID of the object
                       * @example 60d31793d5f1fb7e6e3c1a4c
                       */
                      id?: string;
                      /**
                       * Rectangle
                       * @example {
                       *   "type": "RECTANGLE",
                       *   "x": 320,
                       *   "y": 240,
                       *   "width": 50,
                       *   "height": 25
                       * }
                       */
                      shape?: {
                        /**
                         * @description Type of the shape.
                         * @enum {string}
                         */
                        type: "RECTANGLE";
                        /** @description x-coordinate of the left side of the rectangle. Coordinates are pixel values. */
                        x: number;
                        /** @description y-coordinate of the top of the rectangle. Coordinates are pixel values. */
                        y: number;
                        /** @description Width of the rectangle. Coordinates are pixel values. */
                        width: number;
                        /** @description Height of the rectangle. Coordinates are pixel values. */
                        height: number;
                      };
                    };
                  }[];
              })[];
            /** @description Url to get next page with prediction results. Only appears if number of predictions exceeds maximum allowed predictions defined in backend. */
            next_page?: string;
            video_prediction_properties?: {
              /** @description Total number of frames returned */
              total_count?: number;
              /** @description Integer representing the index of the first returned frame */
              start_frame?: number;
              /** @description Integer representing the index of the last returned frame */
              end_frame?: number;
              /** @description Total number of frames requested by the user */
              total_requested_count?: number;
              /** @description Index of the start frame requested by the user (inclusive) */
              requested_start_frame?: number;
              /** @description Index of the end frame requested by the user (inclusive) */
              requested_end_frame?: number;
            };
          };
        };
      };
      /** @description No predictions available for the requested media. */
      204: {
        content: never;
      };
      /** @description Object not found. See the examples for details. */
      404: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 400 | 404 | 405 | 409 | 412 | 413 | 415 | 422 | 423 | 500 | 501 | 503;
            /** @description Message from server */
            message: string;
            /** @description Error code from server */
            error_code: string;
          };
        };
      };
    };
  };
  /**
   * Get a prediction for a video frame
   * @description Get a prediction for a video frame. This endpoint currently only supports 'latest' prediction type, where the server returns the latest prediction from cache. Other types have been deprecated: if you want to generate a fresh prediction with the active model ('online') then use the pipelines/<pipeline_id>:predict endpoint.
   */
  GetVideoFramePrediction: {
    parameters: {
      query?: {
        /** @description The ID of the task in the project. */
        task_id?: string;
        /** @description The ID of the ROI to predict on. Can only be an ID of a user annotated ROI. Note that if you pass an ID for an ROI you should in most cases also pass a task_id. For example, in a detection -> classification chain if a user  annotates a ROI (box for first task) and requests a prediction for this ROI you don't want the detection task to have to find the same object again that the user annotated but immediately skip to the classification task. */
        roi_id?: string;
      };
      path: {
        /** @description The ID of the organization. */
        organization_id: string;
        /** @description The ID of the workspace. */
        workspace_id: string;
        /** @description The ID of the project. */
        project_id: string;
        /** @description The ID of the dataset in the project. */
        dataset_id: string;
        /** @description The ID of the video. */
        video_id: string;
        /**
         * @description This is a 0-based index, meaning to retrieve the first frame of the video, this parameter should be set to `0`.
         * The possible values for this parameter range from `0` to `frame_count-1`. The `frame_count` is the total number of frames contained in the video
         * and it can be retrieved from the response body of [video detail](#Media/GetVideoDetail) endpoint.
         */
        frame_index: number;
        /**
         * @description Either the id of a prediction or 'latest'. The latter fetches the latest prediction from the cache, if available.
         * @example latest
         */
        prediction_type_or_id: string | "latest";
      };
    };
    responses: {
      /** @description Prediction successfully retrieved */
      200: {
        content: {
          "application/json": ({
              /** @description List of predictions */
              annotations?: ({
                  /**
                   * @description A UUID, used to identify an annotation.
                   * @example e42cf382-5f7b-4fda-980a-fa0fab00243c
                   */
                  id: string;
                  shape?: OneOf<[{
                    /**
                     * @description Type of the shape.
                     * @enum {string}
                     */
                    type: "RECTANGLE";
                    /** @description x-coordinate of the left side of the rectangle. Coordinates are pixel values. */
                    x: number;
                    /** @description y-coordinate of the top of the rectangle. Coordinates are pixel values. */
                    y: number;
                    /** @description Width of the rectangle. Coordinates are pixel values. */
                    width: number;
                    /** @description Height of the rectangle. Coordinates are pixel values. */
                    height: number;
                  }, {
                    /**
                     * @description Type of the shape.
                     * @enum {string}
                     */
                    type: "POLYGON";
                    /** @description Array of points that define the polygon. */
                    points: {
                        /** @description x-coordinate of the point. Coordinates are pixel values. */
                        x: number;
                        /** @description y-coordinate of the point. Coordinates are pixel values. */
                        y: number;
                      }[];
                  }, {
                    /**
                     * @description Type of the shape.
                     * @enum {string}
                     */
                    type: "ELLIPSE";
                    /** @description Lowest x-coordinate of the ellipse. Coordinates are pixel values. */
                    x: number;
                    /** @description Lowest y-coordinate of the ellipse. Coordinates are pixel values. */
                    y: number;
                    /** @description Width of the ellipse. Coordinates are pixel values. */
                    width: number;
                    /** @description Height of the ellipse. Coordinates are pixel values. */
                    height: number;
                  }, {
                    /**
                     * @description Type of the shape.
                     * @enum {string}
                     */
                    type: "ROTATED_RECTANGLE";
                    /** @description Center x-coordinate of the rotated rectangle. Coordinates are pixel values. */
                    x: number;
                    /** @description Center y-coordinate of the rotated rectangle. Coordinates are pixel values. */
                    y: number;
                    /** @description Width of the rotated rectangle (not the encapsulating box of the rectangle). Coordinates are pixel values. */
                    width: number;
                    /** @description Height of the rotated rectangle (not the encapsulating box of the rectangle). Coordinates are pixel values. */
                    height: number;
                    /** @description Clockwise angle in degrees for the rectangle. */
                    angle: number;
                  }, {
                    /**
                     * @description Type of the shape.
                     * @enum {string}
                     */
                    type: "KEYPOINT";
                    /** @description X-coordinate of the keypoint. Coordinates are pixel values. */
                    x: number;
                    /** @description Y-coordinate of the keypoint. Coordinates are pixel values. */
                    y: number;
                    /** @description Indicates whether the feature the keypoint is describing is visible in the image. */
                    is_visible: boolean;
                  }]>;
                  /** @description List of labels */
                  labels: ({
                      /**
                       * @description Mongo ID of the object
                       * @example 60d31793d5f1fb7e6e3c1a4c
                       */
                      id?: string;
                      /**
                       * Probability
                       * Format: float
                       * @description Estimated probability of a prediction. For annotations, this is set to 1.
                       */
                      probability?: number;
                      source?: {
                        /** @description User name of the user that added the label or accepted the prediction */
                        user_id?: string | null;
                        /** @description Model id of the model that predicted the label */
                        model_id?: string | null;
                        /** @description Model storage id of model that predicted the label */
                        model_storage_id?: string | null;
                      };
                    })[];
                  /** @description Modification date */
                  modified: string;
                  /** @description List of labels IDs for which the annotation should be revisited */
                  labels_to_revisit?: string[];
                })[];
              /**
               * @description Mongo ID of the object
               * @example 60d31793d5f1fb7e6e3c1a4c
               */
              id?: string;
              /**
               * @description Kind of annotation (prediction or annotation).
               * @enum {string}
               */
              kind?: "prediction";
              media_identifier?: {
                /** Format: int32 */
                frame_index?: number;
                /**
                 * @description Mongo ID of the object
                 * @example 60d31793d5f1fb7e6e3c1a4c
                 */
                video_id?: string;
                /**
                 * @description Type of media. 'image' for images, 'video' for videos.
                 * @enum {string}
                 */
                type?: "video_frame";
              };
              /** @description Modification date */
              modified?: string;
              /**
               * @deprecated
               * @description List of result media options
               * This parameter is deprecated and should not be used, it will be removed in the future.
               */
              maps?: {
                  /**
                   * @description Mongo ID of the object
                   * @example 60d31793d5f1fb7e6e3c1a4c
                   */
                  id?: string;
                  /** @description Name for the result media option */
                  name?: string;
                  /** @description Type of the result media */
                  type?: string;
                  /** @description Url where the result media can be found */
                  url?: string;
                  /** @description A base 64 encoded representation of the binary data of the result media */
                  binary?: string;
                  /**
                   * @description Mongo ID of the object
                   * @example 60d31793d5f1fb7e6e3c1a4c
                   */
                  label_id?: string;
                  roi?: {
                    /**
                     * @description Mongo ID of the object
                     * @example 60d31793d5f1fb7e6e3c1a4c
                     */
                    id?: string;
                    /**
                     * Rectangle
                     * @example {
                     *   "type": "RECTANGLE",
                     *   "x": 320,
                     *   "y": 240,
                     *   "width": 50,
                     *   "height": 25
                     * }
                     */
                    shape?: {
                      /**
                       * @description Type of the shape.
                       * @enum {string}
                       */
                      type: "RECTANGLE";
                      /** @description x-coordinate of the left side of the rectangle. Coordinates are pixel values. */
                      x: number;
                      /** @description y-coordinate of the top of the rectangle. Coordinates are pixel values. */
                      y: number;
                      /** @description Width of the rectangle. Coordinates are pixel values. */
                      width: number;
                      /** @description Height of the rectangle. Coordinates are pixel values. */
                      height: number;
                    };
                  };
                }[];
            })[];
        };
      };
      /** @description No prediction available for the requested media. */
      204: {
        content: never;
      };
      /** @description Object not found. See the examples for details. */
      404: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 400 | 404 | 405 | 409 | 412 | 413 | 415 | 422 | 423 | 500 | 501 | 503;
            /** @description Message from server */
            message: string;
            /** @description Error code from server */
            error_code: string;
          };
        };
      };
    };
  };
  /**
   * Get the active dataset
   * @description Retrieve active dataset for a project. The active dataset is the set of images and video frames that are suggested for annotation by the active learning algorithm.
   */
  GetActiveDataset: {
    parameters: {
      query?: {
        /** @description Number of items returned in the response. Default is 10 and maximum is 100. */
        limit?: number;
      };
      path: {
        /** @description The ID of the organization. */
        organization_id: string;
        /** @description The ID of the workspace. */
        workspace_id: string;
        /** @description The ID of the project. */
        project_id: string;
      };
    };
    responses: {
      /** @description The requested media entities */
      200: {
        content: {
          "application/json": {
            /** @description List of media items */
            active_set?: (OneOf<[{
                /**
                 * @description Mongo ID of the object
                 * @example 60d31793d5f1fb7e6e3c1a4c
                 */
                id?: string;
                media_information?: {
                  /** @description Display URL of the image or video frame */
                  display_url?: string;
                  /** @description Height of the image or video frame */
                  height?: number;
                  /** @description Width of the image or video frame */
                  width?: number;
                  /** @description Size of the image or video in bytes */
                  size?: number;
                  /** @description Extension of the image or video in lowercase with a dot (e.g. '.jpg') */
                  extension?: string;
                };
                /**
                 * @description Mongo ID of the object
                 * @example 60d31793d5f1fb7e6e3c1a4c
                 */
                dataset_id?: string;
                /** @description Name of the image */
                name?: string;
                /** @description List of per-task states obtained aggregating the annotation state with the revisit information */
                annotation_state_per_task?: ({
                    /**
                     * @description Mongo ID of the object
                     * @example 60d31793d5f1fb7e6e3c1a4c
                     */
                    task_id?: string;
                    /**
                     * @description Annotation state of the media for this task
                     * @enum {string|null}
                     */
                    state?: "annotated" | "partially_annotated" | "none" | "to_revisit" | null;
                  })[];
                /** @description Relative URL to the image thumbnail */
                thumbnail?: string;
                /**
                 * @description Type of media. 'image' for images, 'video' for video.
                 * @enum {string}
                 */
                type?: "image";
                /** @description Upload time of the media file */
                upload_time?: string;
              }, {
                /**
                 * @description Mongo ID of the object
                 * @example 60d31793d5f1fb7e6e3c1a4c
                 */
                id?: string;
                media_information?: {
                  /** @description Display URL of the image or video */
                  display_url?: string;
                  /** @description Duration of the video */
                  duration?: number;
                  /** @description Number of frames in the video */
                  frame_count?: number;
                  /** @description Frame stride of the video */
                  frame_stride?: number;
                  /** @description Frame rate of the video */
                  frame_rate?: number;
                  /** @description Height of the video */
                  height?: number;
                  /** @description Width of the video */
                  width?: number;
                  /** @description Size of the video in bytes */
                  size?: number;
                };
                /** @description List of video frame indices */
                active_frames?: number[];
                /**
                 * @description Mongo ID of the object
                 * @example 60d31793d5f1fb7e6e3c1a4c
                 */
                dataset_id?: string;
                /** @description Name of the image */
                name?: string;
                /** @description List of per-task states obtained aggregating the annotation state with the revisit information */
                annotation_state_per_task?: ({
                    /**
                     * @description Mongo ID of the object
                     * @example 60d31793d5f1fb7e6e3c1a4c
                     */
                    task_id?: string;
                    /**
                     * @description Annotation state of the media for this task
                     * @enum {string|null}
                     */
                    state?: "annotated" | "partially_annotated" | "none" | "to_revisit" | null;
                  })[];
                /** @description Relative URL to the image thumbnail */
                thumbnail?: string;
                /**
                 * @description Type of media. 'image' for images, 'video' for video.
                 * @enum {string}
                 */
                type?: "video";
                /** @description Upload time of the media file */
                upload_time?: string;
              }]>)[];
          };
        };
      };
      /** @description No active media found in dataset. */
      204: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 200 | 201 | 202 | 203 | 204 | 205 | 206;
            /** @description Message from server */
            message: string;
          };
        };
      };
      /** @description Invalid request. */
      400: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 400 | 404 | 405 | 409 | 412 | 413 | 415 | 422 | 423 | 500 | 501 | 503;
            /** @description Message from server */
            message: string;
            /** @description Error code from server */
            error_code: string;
          };
        };
      };
      /** @description Object not found. See the examples for details. */
      404: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 400 | 404 | 405 | 409 | 412 | 413 | 415 | 422 | 423 | 500 | 501 | 503;
            /** @description Message from server */
            message: string;
            /** @description Error code from server */
            error_code: string;
          };
        };
      };
    };
  };
  /**
   * Get info about all tests in project
   * @description Get all tests in the project. Includes info of the model, datasets and the job id.
   */
  GetAllTestsInAProject: {
    parameters: {
      path: {
        /** @description The ID of the organization. */
        organization_id: string;
        /** @description The ID of the workspace. */
        workspace_id: string;
        /** @description The ID of the project. */
        project_id: string;
      };
    };
    responses: {
      /** @description The requested tests info */
      200: {
        content: {
          "application/json": {
            /** @description Array of tests */
            test_results: ({
                /**
                 * @description Mongo ID of the object
                 * @example 60d31793d5f1fb7e6e3c1a4c
                 */
                id: string;
                /** @description Test name */
                name: string;
                /** @description Creation time of the test */
                creation_time: string;
                /** @description Info of job related to the model test result. This attribute is only present after job is created for the model test. */
                job_info: {
                  /**
                   * @description Mongo ID of the object
                   * @example 60d31793d5f1fb7e6e3c1a4c
                   */
                  id?: string;
                  /** @description Status of the testing operation; should be one of: [ PENDING, CREATING_DATASET, INFERRING, EVALUATING, DONE ] */
                  status?: string;
                };
                /** @description Array of datasets */
                datasets_info: {
                    /**
                     * @description Mongo ID of the object
                     * @example 60d31793d5f1fb7e6e3c1a4c
                     */
                    id?: string;
                    /** @description boolean showing whether the dataset is deleted */
                    is_deleted?: boolean;
                    /** @description Name of the dataset */
                    name?: string;
                    /**
                     * Format: int32
                     * @description Number of images in the dataset
                     */
                    n_images?: number;
                    /**
                     * Format: int32
                     * @description Number of frames in the dataset
                     */
                    n_frames?: number;
                    /**
                     * Format: int32
                     * @description Number of samples in the dataset
                     */
                    n_samples?: number;
                  }[];
                model_info: {
                  /**
                   * @description Mongo ID of the object
                   * @example 60d31793d5f1fb7e6e3c1a4c
                   */
                  group_id?: string;
                  /**
                   * @description Mongo ID of the object
                   * @example 60d31793d5f1fb7e6e3c1a4c
                   */
                  id?: string;
                  /**
                   * Format: int32
                   * @description Number of labels model was trained with
                   */
                  n_labels?: number;
                  /** @description Task type; should be one of: [ classification, detection, segmentation, crop, dataset ] */
                  task_type?: string;
                  /** @description Name of the model template for the model */
                  template_id?: string;
                  /** @description Optimization type of the model, one of [ NONE, MO, POT, NNCF ] */
                  optimization_type?: string;
                  /**
                   * Format: int32
                   * @description Version of the model
                   */
                  version?: number;
                };
                /** @description Array of scores */
                scores: ({
                    /** @description Name of the metric */
                    name?: string;
                    /**
                     * Format: float
                     * @description Value of the score
                     */
                    value?: number;
                    /** @description ID of the label corresponding to the score. If  null, the score is for all labels */
                    label_id?: string | null;
                  })[];
              })[];
          };
        };
      };
      /** @description Object not found. See the examples for details. */
      404: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 400 | 404 | 405 | 409 | 412 | 413 | 415 | 422 | 423 | 500 | 501 | 503;
            /** @description Message from server */
            message: string;
            /** @description Error code from server */
            error_code: string;
          };
        };
      };
    };
  };
  /**
   * Start new model test job
   * @description Starts a new model test job which creates and populates a test resource
   */
  TriggerModelTestJob: {
    parameters: {
      path: {
        /** @description The ID of the organization. */
        organization_id: string;
        /** @description The ID of the workspace. */
        workspace_id: string;
        /** @description The ID of the project. */
        project_id: string;
      };
    };
    requestBody?: {
      content: {
        "application/json": {
          /** @description Name of the test */
          name: string;
          /**
           * @description Mongo ID of the object
           * @example 60d31793d5f1fb7e6e3c1a4c
           */
          model_group_id: string;
          /**
           * @description Mongo ID of the object
           * @example 60d31793d5f1fb7e6e3c1a4c
           */
          model_id: string;
          /** @description Array of dataset ids */
          dataset_ids: string[];
          /**
           * @description Pick global to compute the media-level performance (e.g., accuracy), and pick local to compute localized metrics \
           * (e.g., dice for segmentation and f-measure for detection). If no value is passed, we default to local metric.
           *
           * @enum {string}
           */
          metric?: "global";
        };
      };
    };
    responses: {
      /** @description The requested tests info */
      200: {
        content: {
          "application/json": {
            /**
             * @description Mongo ID of the object
             * @example 60d31793d5f1fb7e6e3c1a4c
             */
            job_id?: string;
          };
        };
      };
      /** @description Bad request error. See the examples for details. */
      400: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 400 | 404 | 405 | 409 | 412 | 413 | 415 | 422 | 423 | 500 | 501 | 503;
            /** @description Message from server */
            message: string;
            /** @description Error code from server */
            error_code: string;
          };
        };
      };
      /** @description Object not found. See the examples for details. */
      404: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 400 | 404 | 405 | 409 | 412 | 413 | 415 | 422 | 423 | 500 | 501 | 503;
            /** @description Message from server */
            message: string;
            /** @description Error code from server */
            error_code: string;
          };
        };
      };
    };
  };
  /**
   * Get info about a test in project
   * @description Get info of test in the project. Includes info of the model, datasets and the job id.
   */
  GetTestInAProject: {
    parameters: {
      path: {
        /** @description The ID of the organization. */
        organization_id: string;
        /** @description The ID of the workspace. */
        workspace_id: string;
        /** @description The ID of the project. */
        project_id: string;
        /** @description The ID of the test of interest */
        test_id: string;
      };
    };
    responses: {
      /** @description The requested test info */
      200: {
        content: {
          "application/json": {
            /**
             * @description Mongo ID of the object
             * @example 60d31793d5f1fb7e6e3c1a4c
             */
            id: string;
            /** @description Test name */
            name: string;
            /** @description Creation time of the test */
            creation_time: string;
            /** @description Info of job related to the model test result. This attribute is only present after job is created for the model test. */
            job_info: {
              /**
               * @description Mongo ID of the object
               * @example 60d31793d5f1fb7e6e3c1a4c
               */
              id?: string;
              /** @description Status of the testing operation; should be one of: [ PENDING, CREATING_DATASET, INFERRING, EVALUATING, DONE ] */
              status?: string;
            };
            /** @description Array of datasets */
            datasets_info: {
                /**
                 * @description Mongo ID of the object
                 * @example 60d31793d5f1fb7e6e3c1a4c
                 */
                id?: string;
                /** @description boolean showing whether the dataset is deleted */
                is_deleted?: boolean;
                /** @description Name of the dataset */
                name?: string;
                /**
                 * Format: int32
                 * @description Number of images in the dataset
                 */
                n_images?: number;
                /**
                 * Format: int32
                 * @description Number of frames in the dataset
                 */
                n_frames?: number;
                /**
                 * Format: int32
                 * @description Number of samples in the dataset
                 */
                n_samples?: number;
              }[];
            model_info: {
              /**
               * @description Mongo ID of the object
               * @example 60d31793d5f1fb7e6e3c1a4c
               */
              group_id?: string;
              /**
               * @description Mongo ID of the object
               * @example 60d31793d5f1fb7e6e3c1a4c
               */
              id?: string;
              /**
               * Format: int32
               * @description Number of labels model was trained with
               */
              n_labels?: number;
              /** @description Task type; should be one of: [ classification, detection, segmentation, crop, dataset ] */
              task_type?: string;
              /** @description Name of the model template for the model */
              template_id?: string;
              /** @description Optimization type of the model, one of [ NONE, MO, POT, NNCF ] */
              optimization_type?: string;
              /**
               * Format: int32
               * @description Version of the model
               */
              version?: number;
            };
            /** @description Array of scores */
            scores: ({
                /** @description Name of the metric */
                name?: string;
                /**
                 * Format: float
                 * @description Value of the score
                 */
                value?: number;
                /** @description ID of the label corresponding to the score. If  null, the score is for all labels */
                label_id?: string | null;
              })[];
          };
        };
      };
      /** @description Object not found. See the examples for details. */
      404: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 400 | 404 | 405 | 409 | 412 | 413 | 415 | 422 | 423 | 500 | 501 | 503;
            /** @description Message from server */
            message: string;
            /** @description Error code from server */
            error_code: string;
          };
        };
      };
    };
  };
  /**
   * Delete all info about a test
   * @description Delete all the information relative to a test in the project.
   */
  DeleteTestInAProject: {
    parameters: {
      path: {
        /** @description The ID of the organization. */
        organization_id: string;
        /** @description The ID of the workspace. */
        workspace_id: string;
        /** @description The ID of the project. */
        project_id: string;
        /** @description The ID of the test of interest */
        test_id: string;
      };
    };
    responses: {
      /** @description Test successfully deleted */
      200: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 200 | 201 | 202 | 203 | 204 | 205 | 206;
            /** @description Message from server */
            message: string;
          };
        };
      };
      /** @description Object not found. See the examples for details. */
      404: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 400 | 404 | 405 | 409 | 412 | 413 | 415 | 422 | 423 | 500 | 501 | 503;
            /** @description Message from server */
            message: string;
            /** @description Error code from server */
            error_code: string;
          };
        };
      };
    };
  };
  /**
   * Retrieve specific media test results by applying a query on the test
   * @description Allows the user to quickly filter through their test results by supplying one or more filters to match results against. Currently you can filter on 'score' and 'label_id' fields. The following operators can be used for score 'greater', 'less', 'greater_or_equal', 'less_or_equal'. The following operator can be used for label id 'equal'. If a non-allowed filter is used, then the endpoint will respond with the possible operators that are allowed.
   */
  FilterDataset: {
    parameters: {
      query?: {
        /** @description Number of items returned in the response. Default is 10 and maximum is 100. */
        limit?: number;
        /**
         * @description Number indicating how many items to skip from the first item that matches the query.
         * This field is used in combination with the limit field for the pagination feature.
         */
        skip?: string;
        /** @description Sorting order, could be `asc` (ascending) or `dsc` (descending). */
        sort_direction?: "asc" | "dsc";
        /** @description Field to sort by, only 'score' available */
        sort_by?: "score";
      };
      path: {
        /** @description The ID of the organization. */
        organization_id: string;
        /** @description The ID of the workspace. */
        workspace_id: string;
        /** @description The ID of the project. */
        project_id: string;
        /** @description The ID of the test of interest */
        test_id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": {
          /**
           * @description Connection between the rules of the query
           * @enum {string}
           */
          condition: "and";
          /** @description list of rules used to filter test media results */
          rules: ({
              field: string;
              operator: string;
              value: string | number | null;
            })[];
        };
      };
    };
    responses: {
      /** @description Media items matching the filter */
      200: {
        content: {
          "application/json": {
            /** @description List of media items */
            media?: (({
                annotation_scene_id?: string | null;
                /** @description Annotation state per task of the image. */
                annotation_state_per_task?: ({
                    /**
                     * @description Mongo ID of the object
                     * @example 60d31793d5f1fb7e6e3c1a4c
                     */
                    task_id?: string;
                    /**
                     * @description Overall state obtained aggregating the annotation states with the 'revisit' information on a per-task basis. This only has meaning for an  image/frame/scene, as a video does not have an annotation scene. - Image/VideoFrame/AnnotationScene: - to_revisit: Some annotations need to be revisited by the user for this task - annotated: All the ROIs for this task are annotated (contain a label for the task) - partially_annotated: Some ROIs for this task do not contain labels, other ones do - none: No label is present for this task - Video: - all tasks are set to null
                     * @enum {string|null}
                     */
                    state?: "to_revisit" | "annotated" | "partially_annotated" | "none" | null;
                  })[];
                last_annotator_id?: string | null;
                /**
                 * @description Mongo ID of the object
                 * @example 60d31793d5f1fb7e6e3c1a4c
                 */
                id: string;
                media_information: {
                  /** @description Display URL of the image or video frame */
                  display_url?: string;
                  /** @description Height of the image or video frame */
                  height?: number;
                  /** @description Width of the image or video frame */
                  width?: number;
                  /** @description Size of the image or video in bytes */
                  size?: number;
                  /** @description Extension of the image or video in lowercase with a dot (e.g. '.jpg') */
                  extension?: string;
                };
                /**
                 * @description Status of the preprocessing operation
                 * @enum {string}
                 */
                preprocessing: "SCHEDULED" | "IN_PROGRESS" | "FINISHED" | "FAILED";
                /** @description Name of the image */
                name: string;
                roi_id?: string | null;
                /** @description The media's test info */
                test_result: {
                  /**
                   * @description Mongo ID of the object
                   * @example 60d31793d5f1fb7e6e3c1a4c
                   */
                  annotation_id?: string;
                  /**
                   * @description Mongo ID of the object
                   * @example 60d31793d5f1fb7e6e3c1a4c
                   */
                  prediction_id?: string;
                  scores?: ({
                      /**
                       * @description Mongo ID of the object
                       * @example 60d31793d5f1fb7e6e3c1a4c
                       */
                      label_id?: string | null;
                      /** @description The name of the metric of this score */
                      name?: string;
                      /** @description The score in percentage (0-100) */
                      value?: number;
                    })[];
                };
                /** @description Relative URL to the image thumbnail */
                thumbnail: string;
                /**
                 * @description Type of media. 'image' for images, and 'video_frame' for video frames.
                 * @enum {string}
                 */
                type: "image";
                /** @description Upload time of the media file */
                upload_time?: string;
                /** @description The ID of the user who uploaded the image */
                uploader_id?: string;
              }) | ({
                annotation_scene_id?: string | null;
                /** @description Annotation state per task of the image. */
                annotation_state_per_task?: ({
                    /**
                     * @description Mongo ID of the object
                     * @example 60d31793d5f1fb7e6e3c1a4c
                     */
                    task_id?: string;
                    /**
                     * @description Overall state obtained aggregating the annotation states with the 'revisit' information on a per-task basis. This only has meaning for an  image/frame/scene, as a video does not have an annotation scene. - Image/VideoFrame/AnnotationScene: - to_revisit: Some annotations need to be revisited by the user for this task - annotated: All the ROIs for this task are annotated (contain a label for the task) - partially_annotated: Some ROIs for this task do not contain labels, other ones do - none: No label is present for this task - Video: - all tasks are set to null
                     * @enum {string|null}
                     */
                    state?: "to_revisit" | "annotated" | "partially_annotated" | "none" | null;
                  })[];
                last_annotator_id?: string | null;
                /** @description The index of the video frame (0-based) */
                frame_index: number;
                media_information: {
                  /** @description Display URL of the image or video frame */
                  display_url?: string;
                  /** @description Height of the image or video frame */
                  height?: number;
                  /** @description Width of the image or video frame */
                  width?: number;
                  /** @description Size of the image or video in bytes */
                  size?: number;
                  /** @description Extension of the image or video in lowercase with a dot (e.g. '.jpg') */
                  extension?: string;
                };
                /**
                 * @description Status of the preprocessing operation
                 * @enum {string}
                 */
                preprocessing: "SCHEDULED" | "IN_PROGRESS" | "FINISHED" | "FAILED";
                /** @description The title of the video frame */
                name: string;
                roi_id?: string | null;
                /** @description The media's test info */
                test_result: {
                  /**
                   * @description Mongo ID of the object
                   * @example 60d31793d5f1fb7e6e3c1a4c
                   */
                  annotation_id?: string;
                  /**
                   * @description Mongo ID of the object
                   * @example 60d31793d5f1fb7e6e3c1a4c
                   */
                  prediction_id?: string;
                  scores?: ({
                      /**
                       * @description Mongo ID of the object
                       * @example 60d31793d5f1fb7e6e3c1a4c
                       */
                      label_id?: string | null;
                      /** @description The name of the metric of this score */
                      name?: string;
                      /** @description The score in percentage (0-100) */
                      value?: number;
                    })[];
                };
                /** @description Relative URL to the video frame thumbnail */
                thumbnail: string;
                /**
                 * @description Type of media. 'image' for images, 'video' for video and 'video_frame' for video frames.
                 * @enum {string}
                 */
                type: "video_frame";
                /** @description Upload time of the media file */
                upload_time?: string;
                /** @description The ID of the user who uploaded the video */
                uploader_id?: string;
                /**
                 * @description Mongo ID of the object
                 * @example 60d31793d5f1fb7e6e3c1a4c
                 */
                video_id: string;
              }))[];
            /** @description URL to the next page of results, if the same parameters are used. */
            next_page?: string;
            /** @description Total images that match the query. */
            total_matched_images?: number;
            /** @description Total videos that match the query. */
            total_matched_videos?: number;
            /** @description Total video frames that match the query. */
            total_matched_video_frames?: number;
            /** @description Total images in the dataset. */
            total_images?: number;
            /** @description Total videos in the dataset. */
            total_videos?: number;
          };
        };
      };
      /** @description Bad request. See the examples for details. */
      400: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 400 | 404 | 405 | 409 | 412 | 413 | 415 | 422 | 423 | 500 | 501 | 503;
            /** @description Message from server */
            message: string;
            /** @description Error code from server */
            error_code: string;
          };
        };
      };
      /** @description Object not found. See the examples for details. */
      404: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 400 | 404 | 405 | 409 | 412 | 413 | 415 | 422 | 423 | 500 | 501 | 503;
            /** @description Message from server */
            message: string;
            /** @description Error code from server */
            error_code: string;
          };
        };
      };
    };
  };
  /**
   * Get a prediction from a test in project
   * @description Get a prediction from a test in the project.
   */
  GetPredictionFromTestInAProject: {
    parameters: {
      path: {
        /** @description The ID of the organization. */
        organization_id: string;
        /** @description The ID of the workspace. */
        workspace_id: string;
        /** @description The ID of the project. */
        project_id: string;
        /** @description The ID of the test of interest */
        test_id: string;
        /** @description The ID of the prediction */
        prediction_id: string;
      };
    };
    responses: {
      /** @description Prediction successfully retrieved */
      200: {
        content: {
          "application/json": {
            /** @description List of predictions */
            predictions?: {
                shape?: OneOf<[{
                  /**
                   * @description Type of the shape.
                   * @enum {string}
                   */
                  type: "RECTANGLE";
                  /** @description x-coordinate of the left side of the rectangle. Coordinates are pixel values. */
                  x: number;
                  /** @description y-coordinate of the top of the rectangle. Coordinates are pixel values. */
                  y: number;
                  /** @description Width of the rectangle. Coordinates are pixel values. */
                  width: number;
                  /** @description Height of the rectangle. Coordinates are pixel values. */
                  height: number;
                }, {
                  /**
                   * @description Type of the shape.
                   * @enum {string}
                   */
                  type: "POLYGON";
                  /** @description Array of points that define the polygon. */
                  points: {
                      /** @description x-coordinate of the point. Coordinates are pixel values. */
                      x: number;
                      /** @description y-coordinate of the point. Coordinates are pixel values. */
                      y: number;
                    }[];
                }, {
                  /**
                   * @description Type of the shape.
                   * @enum {string}
                   */
                  type: "ELLIPSE";
                  /** @description Lowest x-coordinate of the ellipse. Coordinates are pixel values. */
                  x: number;
                  /** @description Lowest y-coordinate of the ellipse. Coordinates are pixel values. */
                  y: number;
                  /** @description Width of the ellipse. Coordinates are pixel values. */
                  width: number;
                  /** @description Height of the ellipse. Coordinates are pixel values. */
                  height: number;
                }, {
                  /**
                   * @description Type of the shape.
                   * @enum {string}
                   */
                  type: "ROTATED_RECTANGLE";
                  /** @description Center x-coordinate of the rotated rectangle. Coordinates are pixel values. */
                  x: number;
                  /** @description Center y-coordinate of the rotated rectangle. Coordinates are pixel values. */
                  y: number;
                  /** @description Width of the rotated rectangle (not the encapsulating box of the rectangle). Coordinates are pixel values. */
                  width: number;
                  /** @description Height of the rotated rectangle (not the encapsulating box of the rectangle). Coordinates are pixel values. */
                  height: number;
                  /** @description Clockwise angle in degrees for the rectangle. */
                  angle: number;
                }, {
                  /**
                   * @description Type of the shape.
                   * @enum {string}
                   */
                  type: "KEYPOINT";
                  /** @description X-coordinate of the keypoint. Coordinates are pixel values. */
                  x: number;
                  /** @description Y-coordinate of the keypoint. Coordinates are pixel values. */
                  y: number;
                  /** @description Indicates whether the feature the keypoint is describing is visible in the image. */
                  is_visible: boolean;
                }]>;
                /** @description List of labels */
                labels?: {
                    /**
                     * @description Mongo ID of the object
                     * @example 60d31793d5f1fb7e6e3c1a4c
                     */
                    id?: string;
                    /**
                     * Probability
                     * Format: float
                     * @description Estimated probability of a prediction. For annotations, this is set to 1.
                     */
                    probability?: number;
                  }[];
              }[];
            media_identifier?: {
              /**
               * @description Mongo ID of the object
               * @example 60d31793d5f1fb7e6e3c1a4c
               */
              image_id?: string;
              /**
               * @description Type of media. 'image' for images, 'video' for videos.
               * @enum {string}
               */
              type?: "image";
            };
            /** @description Modification date */
            created?: string;
          };
        };
      };
      /** @description Object not found. See the examples for details. */
      404: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 400 | 404 | 405 | 409 | 412 | 413 | 415 | 422 | 423 | 500 | 501 | 503;
            /** @description Message from server */
            message: string;
            /** @description Error code from server */
            error_code: string;
          };
        };
      };
    };
  };
  /**
   * Get statistics for a training revision
   * @description Retrieves the training revision statistics overview. A training revision is a specific dataset that has been split into the three Deep Learning subsets; Train, Test, and Validation. The "subset_info" retrieves the split of images and frames (aggregated together from the dataset) among the Train, Test, and Validation subsets. The "dataset_info" retrieves the distribution of images, videos, and frames within the whole dataset.
   */
  GetTrainingRevisionStatistics: {
    parameters: {
      path: {
        /** @description The ID of the organization. */
        organization_id: string;
        /** @description The ID of the workspace. */
        workspace_id: string;
        /** @description The ID of the project. */
        project_id: string;
        /** @description The ID of the dataset in the project. */
        dataset_id: string;
        /** @description The ID of the dataset of interest */
        dataset_revision_id: string;
      };
    };
    responses: {
      /** @description Statistics for the requested training revision */
      200: {
        content: {
          "application/json": {
            /**
             * Format: int32
             * @description Number of images in the dataset
             */
            id?: number;
            /** @description Creation time of the project */
            creation_time?: string;
            /** @description Number of items in each subset */
            subset_info?: {
                /**
                 * Format: int32
                 * @description Number of media in the training set
                 */
                training?: number;
                /**
                 * Format: int32
                 * @description Number of media in the testing set
                 */
                testing?: number;
                /**
                 * Format: int32
                 * @description Number of media in the validation set
                 */
                validation?: number;
              }[];
            /** @description Amount per media type in the dataset */
            dataset_info?: {
                /**
                 * Format: int32
                 * @description Number of videos in the dataset
                 */
                videos?: number;
                /**
                 * Format: int32
                 * @description Number of frames in the dataset
                 */
                frames?: number;
                /**
                 * Format: int32
                 * @description Number of images in the dataset
                 */
                images?: number;
              }[];
          };
        };
      };
      /** @description Object not found. See the examples for details. */
      404: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 400 | 404 | 405 | 409 | 412 | 413 | 415 | 422 | 423 | 500 | 501 | 503;
            /** @description Message from server */
            message: string;
            /** @description Error code from server */
            error_code: string;
          };
        };
      };
    };
  };
  /**
   * Retrieve all media in a training revision
   * @description Allows the user to get all the media items in a training revision. A training revision is a dataset which contains the Training, Testing, and Validation subsets. A training revision ID can be obtained after starting at least one training inference.
   */
  GetMediaForDataset: {
    parameters: {
      query?: {
        /** @description Number of items returned in the response. Default is 10 and maximum is 100. */
        limit?: number;
        /**
         * @description Number indicating how many items to skip from the first item that matches the query.
         * This field is used in combination with the limit field for the pagination feature.
         */
        skip?: string;
        /** @description Sorting order, could be `asc` (ascending) or `dsc` (descending). */
        sort_direction?: "asc" | "dsc";
        /** @description Field to sort by. */
        sort_by?: "media_name" | "media_upload_date" | "media_width" | "media_height" | "media_size" | "annotation_creation_date";
      };
      path: {
        /** @description The ID of the organization. */
        organization_id: string;
        /** @description The ID of the workspace. */
        workspace_id: string;
        /** @description The ID of the project. */
        project_id: string;
        /** @description The ID of the dataset in the project. */
        dataset_id: string;
        /** @description The ID of the dataset of interest */
        dataset_revision_id: string;
      };
    };
    responses: {
      /** @description Media items in the training revision */
      200: {
        content: {
          "application/json": {
            /** @description List of media items */
            media?: (OneOf<[{
                /**
                 * @description Mongo ID of the object
                 * @example 60d31793d5f1fb7e6e3c1a4c
                 */
                id?: string;
                media_information?: {
                  /** @description Display URL of the image or video frame */
                  display_url?: string;
                  /** @description Height of the image or video frame */
                  height?: number;
                  /** @description Width of the image or video frame */
                  width?: number;
                  /** @description Size of the image or video in bytes */
                  size?: number;
                  /** @description Extension of the image or video in lowercase with a dot (e.g. '.jpg') */
                  extension?: string;
                };
                /** @description Name of the image */
                name?: string;
                /** @description List of per-task states obtained aggregating the annotation state with the revisit information */
                annotation_state_per_task?: ({
                    /**
                     * @description Mongo ID of the object
                     * @example 60d31793d5f1fb7e6e3c1a4c
                     */
                    task_id?: string;
                    /**
                     * @description Annotation state of the media for this task
                     * @enum {string|null}
                     */
                    state?: "annotated" | "partially_annotated" | "none" | "to_revisit" | null;
                  })[];
                /** @description Relative URL to the image thumbnail */
                thumbnail?: string;
                /**
                 * @description Type of media. 'image' for images, 'video' for video and 'video_frame' for video frames.
                 * @enum {string}
                 */
                type?: "image";
                /** @description Upload time of the media file */
                upload_time?: string;
                /** @description Optional ID of the annotation scene  if filtering in a specific training revision */
                annotation_scene_id?: string;
                /** @description Optional ID of the roi id if filtering in a specific training revision */
                roi_id?: string;
                /** @description Optional ID of the user that last edited the annotation. */
                last_annotator_id?: string;
              }, {
                /**
                 * @description Mongo ID of the object
                 * @example 60d31793d5f1fb7e6e3c1a4c
                 */
                id?: string;
                media_information?: {
                  /** @description Display URL of the image or video */
                  display_url?: string;
                  /** @description Duration of the video */
                  duration?: number;
                  /** @description Number of frames in the video */
                  frame_count?: number;
                  /** @description Frame stride of the video */
                  frame_stride?: number;
                  /** @description Frame rate of the video */
                  frame_rate?: number;
                  /** @description Height of the video */
                  height?: number;
                  /** @description Width of the video */
                  width?: number;
                  /** @description Size of the video in bytes */
                  size?: number;
                };
                /** @description Name of the image */
                name?: string;
                /** @description List of per-task states obtained aggregating the annotation state with the revisit information */
                annotation_state_per_task?: ({
                    /**
                     * @description Mongo ID of the object
                     * @example 60d31793d5f1fb7e6e3c1a4c
                     */
                    task_id?: string;
                    /**
                     * @description Annotation state of the media for this task
                     * @enum {string|null}
                     */
                    state?: "annotated" | "partially_annotated" | "none" | "to_revisit" | null;
                  })[];
                /** @description Relative URL to the video thumbnail */
                thumbnail?: string;
                /**
                 * @description Type of media. 'image' for images, 'video' for video and 'video_frame' for video frames.
                 * @enum {string}
                 */
                type?: "video";
                /** @description Upload time of the media file */
                upload_time?: string;
                /** @description Number of frames in the video that match the filter. Only returned when filtering by annotation properties. */
                matched_frames?: number | null;
              }, {
                /**
                 * Format: int32
                 * @description The video frame index
                 */
                id?: number;
                media_information?: {
                  /** @description Display URL of the image or video */
                  display_url?: string;
                  /** @description Duration of the video */
                  duration?: number;
                  /** @description Number of frames in the video */
                  frame_count?: number;
                  /** @description Frame stride of the video */
                  frame_stride?: number;
                  /** @description Frame rate of the video */
                  frame_rate?: number;
                  /** @description Height of the video */
                  height?: number;
                  /** @description Width of the video */
                  width?: number;
                  /** @description Size of the video in bytes */
                  size?: number;
                };
                /** @description Name of the image */
                name?: string;
                /** @description List of per-task states obtained aggregating the annotation state with the revisit information */
                annotation_state_per_task?: ({
                    /**
                     * @description Mongo ID of the object
                     * @example 60d31793d5f1fb7e6e3c1a4c
                     */
                    task_id?: string;
                    /**
                     * @description Annotation state of the media for this task
                     * @enum {string|null}
                     */
                    state?: "annotated" | "partially_annotated" | "none" | "to_revisit" | null;
                  })[];
                /** @description Relative URL to the video frame thumbnail */
                thumbnail?: string;
                /**
                 * @description Type of media. 'image' for images, 'video' for video and 'video_frame' for video frames.
                 * @enum {string}
                 */
                type?: "video_frame";
                /** @description Upload time of the media file */
                upload_time?: string;
                /** @description Optional ID of the annotation scene if filtering in a specific training revision */
                annotation_scene_id?: string;
                /** @description Optional ID of the roi id if filtering in a specific training revision */
                roi_id?: string;
                /** @description Optional ID of the user that last edited the annotation. */
                last_annotator_id?: string;
              }]>)[];
            /** @description URL to the next page of results, if the same parameters are used. */
            next_page?: string;
            /** @description Total images that match the query. */
            total_matched_images?: number;
            /** @description Total videos that match the query. */
            total_matched_videos?: number;
            /** @description Total video frames that match the query. */
            total_matched_video_frames?: number;
            /** @description Total images in the dataset. */
            total_images?: number;
            /** @description Total videos in the dataset. */
            total_videos?: number;
          };
        };
      };
      /** @description Bad request. See the examples for details. */
      400: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 400 | 404 | 405 | 409 | 412 | 413 | 415 | 422 | 423 | 500 | 501 | 503;
            /** @description Message from server */
            message: string;
            /** @description Error code from server */
            error_code: string;
          };
        };
      };
      /** @description Object not found. See the examples for details. */
      404: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 400 | 404 | 405 | 409 | 412 | 413 | 415 | 422 | 423 | 500 | 501 | 503;
            /** @description Message from server */
            message: string;
            /** @description Error code from server */
            error_code: string;
          };
        };
      };
    };
  };
  /**
   * Retrieve specific media items by applying a query on the training revision
   * @description Allows the user to quickly filter through their training revision by supplying one or more filters to match media items against. Currently you can filter on 'media_upload_date', 'media_height', 'media_width' , 'media_name', 'label_id',  'annotation_scene_state', 'annotation_creation_date', 'shape_type', 'shape_area_percentage', 'shape_area_pixel', 'subset' and 'user_name'. The following operators can be used 'greater', 'less', 'greater_or_equal', 'less_or_equal', 'equal',  'not_equal', 'in' and 'not_in'. Not all combinations of filter and operator can be used. If a combination is not  supported then the endpoint will respond with the possible operators that are allowed for the filter.
   */
  FilterMediaInTrainingRevision: {
    parameters: {
      query?: {
        /** @description Number of items returned in the response. Default is 10 and maximum is 100. */
        limit?: number;
        /**
         * @description Number indicating how many items to skip from the first item that matches the query.
         * This field is used in combination with the limit field for the pagination feature.
         */
        skip?: string;
        /** @description Sorting order, could be `asc` (ascending) or `dsc` (descending). */
        sort_direction?: "asc" | "dsc";
        /** @description Field to sort by. */
        sort_by?: "media_name" | "media_upload_date" | "media_width" | "media_height" | "media_size" | "annotation_creation_date";
      };
      path: {
        /** @description The ID of the organization. */
        organization_id: string;
        /** @description The ID of the workspace. */
        workspace_id: string;
        /** @description The ID of the project. */
        project_id: string;
        /** @description The ID of the dataset in the project. */
        dataset_id: string;
        /** @description The ID of the dataset of interest */
        dataset_revision_id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": {
          /**
           * @description Condition to apply to group of rules.
           * @enum {string}
           */
          condition?: "and";
          /** @description All the rules to filter a dataset with. */
          rules: ({
              /**
               * @description Field to filter on in the database. Can be one of 'media_upload_date', 'media_height', 'media_width' , 'media_name', 'label_id', 'annotation_creation_date', 'annotation_scene_state', 'shape_type', 'shape_size' or 'user_name'. Note that media related filters do not affect the outcome when using the filter video endpoint as each frame will have the same values.
               * @enum {string}
               */
              field: "media_upload_date" | "media_height" | "media_width" | "media_name" | "label_id" | "annotation_creation_date" | "annotation_scene_state" | "shape_type" | "shape_area_percentage" | "shape_area_pixel" | "user_name";
              /**
               * @description Operator to filter with. Can be one of 'greater', 'less', 'greater_or_equal' , 'less_or_equal', 'equal', 'not_equal', 'in', 'not_in', 'regex'
               * @enum {string}
               */
              operator: "greater" | "less" | "greater_or_equal" | "less_or_equal" | "equal" | "not_equal" | "in" | "not_in" | "regex";
              /** @description Value that the field should match to in combination with the operator */
              value: unknown[] | string | number;
            })[];
        };
      };
    };
    responses: {
      /** @description Media items matching in the training revision that match the filter. */
      200: {
        content: {
          "application/json": {
            /** @description List of media items */
            media?: (OneOf<[{
                /**
                 * @description Mongo ID of the object
                 * @example 60d31793d5f1fb7e6e3c1a4c
                 */
                id?: string;
                media_information?: {
                  /** @description Display URL of the image or video frame */
                  display_url?: string;
                  /** @description Height of the image or video frame */
                  height?: number;
                  /** @description Width of the image or video frame */
                  width?: number;
                  /** @description Size of the image or video in bytes */
                  size?: number;
                  /** @description Extension of the image or video in lowercase with a dot (e.g. '.jpg') */
                  extension?: string;
                };
                /** @description Name of the image */
                name?: string;
                /** @description List of per-task states obtained aggregating the annotation state with the revisit information */
                annotation_state_per_task?: ({
                    /**
                     * @description Mongo ID of the object
                     * @example 60d31793d5f1fb7e6e3c1a4c
                     */
                    task_id?: string;
                    /**
                     * @description Annotation state of the media for this task
                     * @enum {string|null}
                     */
                    state?: "annotated" | "partially_annotated" | "none" | "to_revisit" | null;
                  })[];
                /** @description Relative URL to the image thumbnail */
                thumbnail?: string;
                /**
                 * @description Type of media. 'image' for images, 'video' for video and 'video_frame' for video frames.
                 * @enum {string}
                 */
                type?: "image";
                /** @description Upload time of the media file */
                upload_time?: string;
                /** @description Optional ID of the annotation scene  if filtering in a specific training revision */
                annotation_scene_id?: string;
                /** @description Optional ID of the roi id if filtering in a specific training revision */
                roi_id?: string;
                /** @description Optional ID of the user that last edited the annotation. */
                last_annotator_id?: string;
              }, {
                /**
                 * @description Mongo ID of the object
                 * @example 60d31793d5f1fb7e6e3c1a4c
                 */
                id?: string;
                media_information?: {
                  /** @description Display URL of the image or video */
                  display_url?: string;
                  /** @description Duration of the video */
                  duration?: number;
                  /** @description Number of frames in the video */
                  frame_count?: number;
                  /** @description Frame stride of the video */
                  frame_stride?: number;
                  /** @description Frame rate of the video */
                  frame_rate?: number;
                  /** @description Height of the video */
                  height?: number;
                  /** @description Width of the video */
                  width?: number;
                  /** @description Size of the video in bytes */
                  size?: number;
                };
                /** @description Name of the image */
                name?: string;
                /** @description List of per-task states obtained aggregating the annotation state with the revisit information */
                annotation_state_per_task?: ({
                    /**
                     * @description Mongo ID of the object
                     * @example 60d31793d5f1fb7e6e3c1a4c
                     */
                    task_id?: string;
                    /**
                     * @description Annotation state of the media for this task
                     * @enum {string|null}
                     */
                    state?: "annotated" | "partially_annotated" | "none" | "to_revisit" | null;
                  })[];
                /** @description Relative URL to the video thumbnail */
                thumbnail?: string;
                /**
                 * @description Type of media. 'image' for images, 'video' for video and 'video_frame' for video frames.
                 * @enum {string}
                 */
                type?: "video";
                /** @description Upload time of the media file */
                upload_time?: string;
                /** @description Number of frames in the video that match the filter. Only returned when filtering by annotation properties. */
                matched_frames?: number | null;
              }, {
                /**
                 * Format: int32
                 * @description The video frame index
                 */
                id?: number;
                media_information?: {
                  /** @description Display URL of the image or video */
                  display_url?: string;
                  /** @description Duration of the video */
                  duration?: number;
                  /** @description Number of frames in the video */
                  frame_count?: number;
                  /** @description Frame stride of the video */
                  frame_stride?: number;
                  /** @description Frame rate of the video */
                  frame_rate?: number;
                  /** @description Height of the video */
                  height?: number;
                  /** @description Width of the video */
                  width?: number;
                  /** @description Size of the video in bytes */
                  size?: number;
                };
                /** @description Name of the image */
                name?: string;
                /** @description List of per-task states obtained aggregating the annotation state with the revisit information */
                annotation_state_per_task?: ({
                    /**
                     * @description Mongo ID of the object
                     * @example 60d31793d5f1fb7e6e3c1a4c
                     */
                    task_id?: string;
                    /**
                     * @description Annotation state of the media for this task
                     * @enum {string|null}
                     */
                    state?: "annotated" | "partially_annotated" | "none" | "to_revisit" | null;
                  })[];
                /** @description Relative URL to the video frame thumbnail */
                thumbnail?: string;
                /**
                 * @description Type of media. 'image' for images, 'video' for video and 'video_frame' for video frames.
                 * @enum {string}
                 */
                type?: "video_frame";
                /** @description Upload time of the media file */
                upload_time?: string;
                /** @description Optional ID of the annotation scene if filtering in a specific training revision */
                annotation_scene_id?: string;
                /** @description Optional ID of the roi id if filtering in a specific training revision */
                roi_id?: string;
                /** @description Optional ID of the user that last edited the annotation. */
                last_annotator_id?: string;
              }]>)[];
            /** @description URL to the next page of results, if the same parameters are used. */
            next_page?: string;
            /** @description Total images that match the query. */
            total_matched_images?: number;
            /** @description Total videos that match the query. */
            total_matched_videos?: number;
            /** @description Total video frames that match the query. */
            total_matched_video_frames?: number;
            /** @description Total images in the dataset. */
            total_images?: number;
            /** @description Total videos in the dataset. */
            total_videos?: number;
          };
        };
      };
      /** @description Bad request. See the examples for details. */
      400: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 400 | 404 | 405 | 409 | 412 | 413 | 415 | 422 | 423 | 500 | 501 | 503;
            /** @description Message from server */
            message: string;
            /** @description Error code from server */
            error_code: string;
          };
        };
      };
      /** @description Object not found. See the examples for details. */
      404: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 400 | 404 | 405 | 409 | 412 | 413 | 415 | 422 | 423 | 500 | 501 | 503;
            /** @description Message from server */
            message: string;
            /** @description Error code from server */
            error_code: string;
          };
        };
      };
    };
  };
  /**
   * Retrieve specific frames from a video in a training revision by applying a query
   * @description Allows the user to quickly filter through frames in a video in a specific training revision by supplying one or  more filters to match frames against. Currently you can filter on 'label_id',  'annotation_scene_state',  'annotation_creation_date', 'shape_type', 'shape_area_percentage', 'shape_area_pixel' and 'user_name'. The following  operators can be used 'greater', 'less', 'greater_or_equal', 'less_or_equal', 'equal', 'not_equal', 'in' and 'not_in'. Not all combinations of filter and operator can be used. If a combination is not supported, the endpoint will respond  with the possible operators that are allowed for the filter.
   */
  FilterVideoFramesInTrainingRevision: {
    parameters: {
      query?: {
        /** @description Number of items returned in the response. Default is 10 and maximum is 100. */
        limit?: number;
        /**
         * @description Number indicating how many items to skip from the first item that matches the query.
         * This field is used in combination with the limit field for the pagination feature.
         */
        skip?: string;
        /** @description Sorting order, could be `asc` (ascending) or `dsc` (descending). */
        sort_direction?: "asc" | "dsc";
        /** @description Field to sort by. */
        sort_by?: "media_name" | "media_upload_date" | "media_width" | "media_height" | "media_size" | "annotation_creation_date";
      };
      path: {
        /** @description The ID of the organization. */
        organization_id: string;
        /** @description The ID of the workspace. */
        workspace_id: string;
        /** @description The ID of the project. */
        project_id: string;
        /** @description The ID of the dataset in the project. */
        dataset_id: string;
        /** @description The ID of the dataset of interest */
        dataset_revision_id: string;
        /** @description The ID of the video. */
        video_id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": {
          /**
           * @description Condition to apply to group of rules.
           * @enum {string}
           */
          condition?: "and";
          /** @description All the rules to filter a dataset with. */
          rules: ({
              /**
               * @description Field to filter on in the database. Can be one of 'media_upload_date', 'media_height', 'media_width' , 'media_name', 'label_id', 'annotation_creation_date', 'annotation_scene_state', 'shape_type', 'shape_size' or 'user_name'. Note that media related filters do not affect the outcome when using the filter video endpoint as each frame will have the same values.
               * @enum {string}
               */
              field: "media_upload_date" | "media_height" | "media_width" | "media_name" | "label_id" | "annotation_creation_date" | "annotation_scene_state" | "shape_type" | "shape_area_percentage" | "shape_area_pixel" | "user_name";
              /**
               * @description Operator to filter with. Can be one of 'greater', 'less', 'greater_or_equal' , 'less_or_equal', 'equal', 'not_equal', 'in', 'not_in', 'regex'
               * @enum {string}
               */
              operator: "greater" | "less" | "greater_or_equal" | "less_or_equal" | "equal" | "not_equal" | "in" | "not_in" | "regex";
              /** @description Value that the field should match to in combination with the operator */
              value: unknown[] | string | number;
            })[];
        };
      };
    };
    responses: {
      /** @description Frames matching the filter */
      200: {
        content: {
          "application/json": {
            /** @description List of media items */
            media?: (OneOf<[{
                /**
                 * @description Mongo ID of the object
                 * @example 60d31793d5f1fb7e6e3c1a4c
                 */
                id?: string;
                media_information?: {
                  /** @description Display URL of the image or video frame */
                  display_url?: string;
                  /** @description Height of the image or video frame */
                  height?: number;
                  /** @description Width of the image or video frame */
                  width?: number;
                  /** @description Size of the image or video in bytes */
                  size?: number;
                  /** @description Extension of the image or video in lowercase with a dot (e.g. '.jpg') */
                  extension?: string;
                };
                /** @description Name of the image */
                name?: string;
                /** @description List of per-task states obtained aggregating the annotation state with the revisit information */
                annotation_state_per_task?: ({
                    /**
                     * @description Mongo ID of the object
                     * @example 60d31793d5f1fb7e6e3c1a4c
                     */
                    task_id?: string;
                    /**
                     * @description Annotation state of the media for this task
                     * @enum {string|null}
                     */
                    state?: "annotated" | "partially_annotated" | "none" | "to_revisit" | null;
                  })[];
                /** @description Relative URL to the image thumbnail */
                thumbnail?: string;
                /**
                 * @description Type of media. 'image' for images, 'video' for video and 'video_frame' for video frames.
                 * @enum {string}
                 */
                type?: "image";
                /** @description Upload time of the media file */
                upload_time?: string;
                /** @description Optional ID of the annotation scene  if filtering in a specific training revision */
                annotation_scene_id?: string;
                /** @description Optional ID of the roi id if filtering in a specific training revision */
                roi_id?: string;
                /** @description Optional ID of the user that last edited the annotation. */
                last_annotator_id?: string;
              }, {
                /**
                 * @description Mongo ID of the object
                 * @example 60d31793d5f1fb7e6e3c1a4c
                 */
                id?: string;
                media_information?: {
                  /** @description Display URL of the image or video */
                  display_url?: string;
                  /** @description Duration of the video */
                  duration?: number;
                  /** @description Number of frames in the video */
                  frame_count?: number;
                  /** @description Frame stride of the video */
                  frame_stride?: number;
                  /** @description Frame rate of the video */
                  frame_rate?: number;
                  /** @description Height of the video */
                  height?: number;
                  /** @description Width of the video */
                  width?: number;
                  /** @description Size of the video in bytes */
                  size?: number;
                };
                /** @description Name of the image */
                name?: string;
                /** @description List of per-task states obtained aggregating the annotation state with the revisit information */
                annotation_state_per_task?: ({
                    /**
                     * @description Mongo ID of the object
                     * @example 60d31793d5f1fb7e6e3c1a4c
                     */
                    task_id?: string;
                    /**
                     * @description Annotation state of the media for this task
                     * @enum {string|null}
                     */
                    state?: "annotated" | "partially_annotated" | "none" | "to_revisit" | null;
                  })[];
                /** @description Relative URL to the video thumbnail */
                thumbnail?: string;
                /**
                 * @description Type of media. 'image' for images, 'video' for video and 'video_frame' for video frames.
                 * @enum {string}
                 */
                type?: "video";
                /** @description Upload time of the media file */
                upload_time?: string;
                /** @description Number of frames in the video that match the filter. Only returned when filtering by annotation properties. */
                matched_frames?: number | null;
              }, {
                /**
                 * Format: int32
                 * @description The video frame index
                 */
                id?: number;
                media_information?: {
                  /** @description Display URL of the image or video */
                  display_url?: string;
                  /** @description Duration of the video */
                  duration?: number;
                  /** @description Number of frames in the video */
                  frame_count?: number;
                  /** @description Frame stride of the video */
                  frame_stride?: number;
                  /** @description Frame rate of the video */
                  frame_rate?: number;
                  /** @description Height of the video */
                  height?: number;
                  /** @description Width of the video */
                  width?: number;
                  /** @description Size of the video in bytes */
                  size?: number;
                };
                /** @description Name of the image */
                name?: string;
                /** @description List of per-task states obtained aggregating the annotation state with the revisit information */
                annotation_state_per_task?: ({
                    /**
                     * @description Mongo ID of the object
                     * @example 60d31793d5f1fb7e6e3c1a4c
                     */
                    task_id?: string;
                    /**
                     * @description Annotation state of the media for this task
                     * @enum {string|null}
                     */
                    state?: "annotated" | "partially_annotated" | "none" | "to_revisit" | null;
                  })[];
                /** @description Relative URL to the video frame thumbnail */
                thumbnail?: string;
                /**
                 * @description Type of media. 'image' for images, 'video' for video and 'video_frame' for video frames.
                 * @enum {string}
                 */
                type?: "video_frame";
                /** @description Upload time of the media file */
                upload_time?: string;
                /** @description Optional ID of the annotation scene if filtering in a specific training revision */
                annotation_scene_id?: string;
                /** @description Optional ID of the roi id if filtering in a specific training revision */
                roi_id?: string;
                /** @description Optional ID of the user that last edited the annotation. */
                last_annotator_id?: string;
              }]>)[];
            /** @description URL to the next page of results, if the same parameters are used. */
            next_page?: string;
            /** @description Total images that match the query. */
            total_matched_images?: number;
            /** @description Total videos that match the query. */
            total_matched_videos?: number;
            /** @description Total video frames that match the query. */
            total_matched_video_frames?: number;
            /** @description Total images in the dataset. */
            total_images?: number;
            /** @description Total videos in the dataset. */
            total_videos?: number;
          };
        };
      };
      /** @description Bad request. See the examples for details. */
      400: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 400 | 404 | 405 | 409 | 412 | 413 | 415 | 422 | 423 | 500 | 501 | 503;
            /** @description Message from server */
            message: string;
            /** @description Error code from server */
            error_code: string;
          };
        };
      };
      /** @description Object not found. See the examples for details. */
      404: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 400 | 404 | 405 | 409 | 412 | 413 | 415 | 422 | 423 | 500 | 501 | 503;
            /** @description Message from server */
            message: string;
            /** @description Error code from server */
            error_code: string;
          };
        };
      };
    };
  };
  /**
   * Generate or retrieve a prediction for an image or video frame
   * @description Generate or retrieve a prediction for an image or a single video frame.
   */
  GetSinglePrediction: {
    parameters: {
      query?: {
        /**
         * @description The Region of Interest (ROI) of the image or video frame to use for inference.
         * The ROI is a rectangle defined by four zero-index pixel coordinates, separated by comma,
         * with the format: `left,top,width,height`.
         */
        roi?: string;
        /** @description Hyper parameters for the inference */
        hyper_parameters?: string;
        /**
         * @description This parameter defines the origin of the predictions.
         *
         * When `use_cache=always`, the predictions are pulled from the database cache. If no prediction with the desired configuration exists in the
         * cache, a 'not found' respones will be returned.
         *
         * When `use_cache=never`, the predictions are generated on the fly based on the request. Note that, the predictions are generated using
         * the OpenVINO model with FP32 precision with XAI. This model can be found under the [model detail](#Models/GetModelDetail) endpoint.
         *
         * When `use_cache=auto`, the system will first attempt to retrieve an existing prediction for the media item from the
         * cache. If no prediction with the desired configuration exists in the cache, a new prediction will be generated on the
         * fly. By default, `auto` is used.
         */
        use_cache?: "always" | "never" | "auto";
      };
      path: {
        /** @description The ID of the organization. */
        organization_id: string;
        /** @description The ID of the workspace. */
        workspace_id: string;
        /** @description The ID of the project. */
        project_id: string;
        /**
         * @description Set this parameter to `active` request predictions generated using the currently active model(s) in the project.
         * For task chain, this parameter could be set to the task ID within the project to request for inference only for that task.
         * The task ID can be found in the [project detail](#Projects/GetProjectInfo) endpoint.
         * @example active
         */
        pipeline_id: string | "active";
      };
    };
    /** @description Either an image file, or an identifier for an image or single video frame for which a prediction should be returned. */
    requestBody: {
      content: {
        "multipart/form-data": {
          /**
           * Format: binary
           * @description The image file to be uploaded for inference.
           */
          file: string;
        };
        "application/json": OneOf<[{
          /**
           * @description Mongo ID of the object
           * @example 60d31793d5f1fb7e6e3c1a4c
           */
          dataset_id?: string;
          /**
           * @description Mongo ID of the object
           * @example 60d31793d5f1fb7e6e3c1a4c
           */
          image_id?: string;
        }, {
          /**
           * @description Mongo ID of the object
           * @example 60d31793d5f1fb7e6e3c1a4c
           */
          dataset_id?: string;
          /**
           * @description Mongo ID of the object
           * @example 60d31793d5f1fb7e6e3c1a4c
           */
          video_id?: string;
          /**
           * @description This is a 0-based index, meaning to retrieve the first frame of the video, this parameter should be set to `0`.
           * The possible values for this parameter range from `0` to `frame_count-1`. The `frame_count` is the total number of frames contained in the video
           * and it can be retrieved from the response body of [video detail](#Media/GetVideoDetail) endpoint.
           */
          frame_index: number;
        }]>;
      };
    };
    responses: {
      /** @description Prediction successfully retrieved */
      200: {
        content: {
          "application/json": {
            /** @description List of predictions */
            predictions?: {
                shape?: OneOf<[{
                  /**
                   * @description Type of the shape.
                   * @enum {string}
                   */
                  type: "RECTANGLE";
                  /** @description x-coordinate of the left side of the rectangle. Coordinates are pixel values. */
                  x: number;
                  /** @description y-coordinate of the top of the rectangle. Coordinates are pixel values. */
                  y: number;
                  /** @description Width of the rectangle. Coordinates are pixel values. */
                  width: number;
                  /** @description Height of the rectangle. Coordinates are pixel values. */
                  height: number;
                }, {
                  /**
                   * @description Type of the shape.
                   * @enum {string}
                   */
                  type: "POLYGON";
                  /** @description Array of points that define the polygon. */
                  points: {
                      /** @description x-coordinate of the point. Coordinates are pixel values. */
                      x: number;
                      /** @description y-coordinate of the point. Coordinates are pixel values. */
                      y: number;
                    }[];
                }, {
                  /**
                   * @description Type of the shape.
                   * @enum {string}
                   */
                  type: "ELLIPSE";
                  /** @description Lowest x-coordinate of the ellipse. Coordinates are pixel values. */
                  x: number;
                  /** @description Lowest y-coordinate of the ellipse. Coordinates are pixel values. */
                  y: number;
                  /** @description Width of the ellipse. Coordinates are pixel values. */
                  width: number;
                  /** @description Height of the ellipse. Coordinates are pixel values. */
                  height: number;
                }, {
                  /**
                   * @description Type of the shape.
                   * @enum {string}
                   */
                  type: "ROTATED_RECTANGLE";
                  /** @description Center x-coordinate of the rotated rectangle. Coordinates are pixel values. */
                  x: number;
                  /** @description Center y-coordinate of the rotated rectangle. Coordinates are pixel values. */
                  y: number;
                  /** @description Width of the rotated rectangle (not the encapsulating box of the rectangle). Coordinates are pixel values. */
                  width: number;
                  /** @description Height of the rotated rectangle (not the encapsulating box of the rectangle). Coordinates are pixel values. */
                  height: number;
                  /** @description Clockwise angle in degrees for the rectangle. */
                  angle: number;
                }, {
                  /**
                   * @description Type of the shape.
                   * @enum {string}
                   */
                  type: "KEYPOINT";
                  /** @description X-coordinate of the keypoint. Coordinates are pixel values. */
                  x: number;
                  /** @description Y-coordinate of the keypoint. Coordinates are pixel values. */
                  y: number;
                  /** @description Indicates whether the feature the keypoint is describing is visible in the image. */
                  is_visible: boolean;
                }]>;
                /** @description List of labels */
                labels?: {
                    /**
                     * @description Mongo ID of the object
                     * @example 60d31793d5f1fb7e6e3c1a4c
                     */
                    id?: string;
                    /**
                     * Probability
                     * Format: float
                     * @description Estimated probability of a prediction. For annotations, this is set to 1.
                     */
                    probability?: number;
                  }[];
              }[];
            /** @description Creation date */
            created?: string;
            /** @description Optional identifier for the media item on which the prediction was made. Only included for persistent media. */
            media_identifier?: OneOf<[{
              /** @enum {string} */
              type?: "image";
              /**
               * @description Mongo ID of the object
               * @example 60d31793d5f1fb7e6e3c1a4c
               */
              image_id?: string;
            }, {
              /** @enum {string} */
              type?: "video_frame";
              /**
               * @description Mongo ID of the object
               * @example 60d31793d5f1fb7e6e3c1a4c
               */
              video_id?: string;
              frame_index?: number;
            }]>;
          };
        };
      };
      /** @description No prediction available for the requested media. */
      204: {
        content: never;
      };
      /** @description Object not found. See the examples for details. */
      404: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 400 | 404 | 405 | 409 | 412 | 413 | 415 | 422 | 423 | 500 | 501 | 503;
            /** @description Message from server */
            message: string;
            /** @description Error code from server */
            error_code: string;
          };
        };
      };
    };
  };
  /**
   * Generate or retrieve explanations for an image or video frame
   * @description Generate or retrieve explanations of the inference output for an image or a single video frame. The explanation is typically the heatmap
   * highlighting the area which the model finds to be salient. For more info, please refer to [OpenVINO XAI](https://github.com/openvinotoolkit/openvino_xai).
   */
  GetSingleExplanation: {
    parameters: {
      query?: {
        /**
         * @description The Region of Interest (ROI) of the image or video frame to use for inference.
         * The ROI is a rectangle defined by four zero-index pixel coordinates, separated by comma,
         * with the format: `left,top,width,height`.
         */
        roi?: string;
        /** @description Hyper parameters for the inference */
        hyper_parameters?: string;
      };
      path: {
        /** @description The ID of the organization. */
        organization_id: string;
        /** @description The ID of the workspace. */
        workspace_id: string;
        /** @description The ID of the project. */
        project_id: string;
        /**
         * @description Set this parameter to `active` request predictions generated using the currently active model(s) in the project.
         * For task chain, this parameter could be set to the task ID within the project to request for inference only for that task.
         * The task ID can be found in the [project detail](#Projects/GetProjectInfo) endpoint.
         * @example active
         */
        pipeline_id: string | "active";
      };
    };
    /** @description Either an image file, or an identifier for an image or single video frame for which explanations should be returned. */
    requestBody: {
      content: {
        "multipart/form-data": {
          /**
           * Format: binary
           * @description The image file to be uploaded for inference.
           */
          file: string;
        };
        "application/json": OneOf<[{
          /**
           * @description Mongo ID of the object
           * @example 60d31793d5f1fb7e6e3c1a4c
           */
          dataset_id?: string;
          /**
           * @description Mongo ID of the object
           * @example 60d31793d5f1fb7e6e3c1a4c
           */
          image_id?: string;
        }, {
          /**
           * @description Mongo ID of the object
           * @example 60d31793d5f1fb7e6e3c1a4c
           */
          dataset_id?: string;
          /**
           * @description Mongo ID of the object
           * @example 60d31793d5f1fb7e6e3c1a4c
           */
          video_id?: string;
          /**
           * @description This is a 0-based index, meaning to retrieve the first frame of the video, this parameter should be set to `0`.
           * The possible values for this parameter range from `0` to `frame_count-1`. The `frame_count` is the total number of frames contained in the video
           * and it can be retrieved from the response body of [video detail](#Media/GetVideoDetail) endpoint.
           */
          frame_index: number;
        }]>;
      };
    };
    responses: {
      /** @description Explanations successfully retrieved */
      200: {
        content: {
          "application/json": {
            /** @description List of explanations (saliency maps) */
            maps?: {
                /** @description Binary representation of the saliency map */
                data?: string;
                /**
                 * @description Mongo ID of the object
                 * @example 60d31793d5f1fb7e6e3c1a4c
                 */
                label_id?: string;
              }[];
            /** @description Creation date */
            created?: string;
            /** @description Optional identifier for the media item on which the prediction was made. Only included for persistent media. */
            media_identifier?: OneOf<[{
              /** @enum {string} */
              type?: "image";
              /**
               * @description Mongo ID of the object
               * @example 60d31793d5f1fb7e6e3c1a4c
               */
              image_id?: string;
            }, {
              /** @enum {string} */
              type?: "video_frame";
              /**
               * @description Mongo ID of the object
               * @example 60d31793d5f1fb7e6e3c1a4c
               */
              video_id?: string;
              frame_index?: number;
            }]>;
          };
        };
      };
      /** @description No explanation available for the requested media. */
      204: {
        content: never;
      };
      /** @description Object not found. See the examples for details. */
      404: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 400 | 404 | 405 | 409 | 412 | 413 | 415 | 422 | 423 | 500 | 501 | 503;
            /** @description Message from server */
            message: string;
            /** @description Error code from server */
            error_code: string;
          };
        };
      };
    };
  };
  /**
   * Generate or retrieve predictions for a batch of video frames
   * @description Generate or retrieve the predictions for a sequence of video frames.
   */
  GetBatchPrediction: {
    parameters: {
      query?: {
        /**
         * @description The Region of Interest (ROI) of the image or video frame to use for inference.
         * The ROI is a rectangle defined by four zero-index pixel coordinates, separated by comma,
         * with the format: `left,top,width,height`.
         */
        roi?: string;
        /** @description Hyper parameters for the inference */
        hyper_parameters?: string;
      };
      path: {
        /** @description The ID of the organization. */
        organization_id: string;
        /** @description The ID of the workspace. */
        workspace_id: string;
        /** @description The ID of the project. */
        project_id: string;
        /**
         * @description Set this parameter to `active` request predictions generated using the currently active model(s) in the project.
         * For task chain, this parameter could be set to the task ID within the project to request for inference only for that task.
         * The task ID can be found in the [project detail](#Projects/GetProjectInfo) endpoint.
         * @example active
         */
        pipeline_id: string | "active";
      };
    };
    /**
     * @description An identifier for a range of video frames on which to perform inference.
     * The predictions are strating from the `start_frame` of the range, for every frame at `frame_skip` intervals, and all
     * the way up to the `end_frame`.
     *
     * The maximum number of frames to generate predictions for is 20.
     */
    requestBody: {
      content: {
        "application/json": {
          /**
           * @description Mongo ID of the object
           * @example 60d31793d5f1fb7e6e3c1a4c
           */
          dataset_id?: string;
          /**
           * @description Mongo ID of the object
           * @example 60d31793d5f1fb7e6e3c1a4c
           */
          video_id?: string;
          /**
           * @description Index of the first frame in the range.
           * @default 0
           */
          start_frame?: number;
          /** @description Index of the last frame in the range. */
          end_frame: number;
          /**
           * @description Stride (step size), that is the interval between two consecutive frames in the range.
           * If `frame_skip` is 1, all frames are considered to be part of the range.
           */
          frame_skip: number;
        };
      };
    };
    responses: {
      /** @description Predictions successfully retrieved */
      200: {
        content: {
          "application/json": {
            /** @description List of predictions. Each entry corresponds to the prediction for a single media item in the batch. */
            batch_predictions?: {
                /** @description List of predictions */
                predictions?: {
                    shape?: OneOf<[{
                      /**
                       * @description Type of the shape.
                       * @enum {string}
                       */
                      type: "RECTANGLE";
                      /** @description x-coordinate of the left side of the rectangle. Coordinates are pixel values. */
                      x: number;
                      /** @description y-coordinate of the top of the rectangle. Coordinates are pixel values. */
                      y: number;
                      /** @description Width of the rectangle. Coordinates are pixel values. */
                      width: number;
                      /** @description Height of the rectangle. Coordinates are pixel values. */
                      height: number;
                    }, {
                      /**
                       * @description Type of the shape.
                       * @enum {string}
                       */
                      type: "POLYGON";
                      /** @description Array of points that define the polygon. */
                      points: {
                          /** @description x-coordinate of the point. Coordinates are pixel values. */
                          x: number;
                          /** @description y-coordinate of the point. Coordinates are pixel values. */
                          y: number;
                        }[];
                    }, {
                      /**
                       * @description Type of the shape.
                       * @enum {string}
                       */
                      type: "ELLIPSE";
                      /** @description Lowest x-coordinate of the ellipse. Coordinates are pixel values. */
                      x: number;
                      /** @description Lowest y-coordinate of the ellipse. Coordinates are pixel values. */
                      y: number;
                      /** @description Width of the ellipse. Coordinates are pixel values. */
                      width: number;
                      /** @description Height of the ellipse. Coordinates are pixel values. */
                      height: number;
                    }, {
                      /**
                       * @description Type of the shape.
                       * @enum {string}
                       */
                      type: "ROTATED_RECTANGLE";
                      /** @description Center x-coordinate of the rotated rectangle. Coordinates are pixel values. */
                      x: number;
                      /** @description Center y-coordinate of the rotated rectangle. Coordinates are pixel values. */
                      y: number;
                      /** @description Width of the rotated rectangle (not the encapsulating box of the rectangle). Coordinates are pixel values. */
                      width: number;
                      /** @description Height of the rotated rectangle (not the encapsulating box of the rectangle). Coordinates are pixel values. */
                      height: number;
                      /** @description Clockwise angle in degrees for the rectangle. */
                      angle: number;
                    }, {
                      /**
                       * @description Type of the shape.
                       * @enum {string}
                       */
                      type: "KEYPOINT";
                      /** @description X-coordinate of the keypoint. Coordinates are pixel values. */
                      x: number;
                      /** @description Y-coordinate of the keypoint. Coordinates are pixel values. */
                      y: number;
                      /** @description Indicates whether the feature the keypoint is describing is visible in the image. */
                      is_visible: boolean;
                    }]>;
                    /** @description List of labels */
                    labels?: {
                        /**
                         * @description Mongo ID of the object
                         * @example 60d31793d5f1fb7e6e3c1a4c
                         */
                        id?: string;
                        /**
                         * Probability
                         * Format: float
                         * @description Estimated probability of a prediction. For annotations, this is set to 1.
                         */
                        probability?: number;
                      }[];
                  }[];
                /** @description Creation date */
                created?: string;
                /** @description Optional identifier for the media item on which the prediction was made. Only included for persistent media. */
                media_identifier?: OneOf<[{
                  /** @enum {string} */
                  type?: "image";
                  /**
                   * @description Mongo ID of the object
                   * @example 60d31793d5f1fb7e6e3c1a4c
                   */
                  image_id?: string;
                }, {
                  /** @enum {string} */
                  type?: "video_frame";
                  /**
                   * @description Mongo ID of the object
                   * @example 60d31793d5f1fb7e6e3c1a4c
                   */
                  video_id?: string;
                  frame_index?: number;
                }]>;
              }[];
          };
        };
      };
      /** @description No prediction available for the requested media. */
      204: {
        content: never;
      };
      /** @description Too many predictions requested. */
      400: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 400 | 404 | 405 | 409 | 412 | 413 | 415 | 422 | 423 | 500 | 501 | 503;
            /** @description Message from server */
            message: string;
            /** @description Error code from server */
            error_code: string;
          };
        };
      };
      /** @description Object not found. See the examples for details. */
      404: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 400 | 404 | 405 | 409 | 412 | 413 | 415 | 422 | 423 | 500 | 501 | 503;
            /** @description Message from server */
            message: string;
            /** @description Error code from server */
            error_code: string;
          };
        };
      };
    };
  };
  /**
   * Generate or retrieve explanations for a batch of video frames
   * @description Generate or retrieve explanations of the inference output for a sequence of video frames. The explanation is typically the heatmap
   * highlighting the area which the model finds to be salient. For more info, please refer to [OpenVINO XAI](https://github.com/openvinotoolkit/openvino_xai).
   */
  GetBatchExplanation: {
    parameters: {
      query?: {
        /**
         * @description The Region of Interest (ROI) of the image or video frame to use for inference.
         * The ROI is a rectangle defined by four zero-index pixel coordinates, separated by comma,
         * with the format: `left,top,width,height`.
         */
        roi?: string;
        /** @description Hyper parameters for the inference */
        hyper_parameters?: string;
      };
      path: {
        /** @description The ID of the organization. */
        organization_id: string;
        /** @description The ID of the workspace. */
        workspace_id: string;
        /** @description The ID of the project. */
        project_id: string;
        /**
         * @description Set this parameter to `active` request predictions generated using the currently active model(s) in the project.
         * For task chain, this parameter could be set to the task ID within the project to request for inference only for that task.
         * The task ID can be found in the [project detail](#Projects/GetProjectInfo) endpoint.
         * @example active
         */
        pipeline_id: string | "active";
      };
    };
    /**
     * @description An identifier for a range of video frames from which the explanations are generated.
     * The explanations are strating from the `start_frame` of the range, for every frame at `frame_skip` intervals, and all
     * the way up to the `end_frame`.
     *
     * The maximum number of frames to generate explanations for is 20. If the request exceeds this value, the response will contain error code
     * `400`.
     */
    requestBody: {
      content: {
        "application/json": {
          /**
           * @description Mongo ID of the object
           * @example 60d31793d5f1fb7e6e3c1a4c
           */
          dataset_id?: string;
          /**
           * @description Mongo ID of the object
           * @example 60d31793d5f1fb7e6e3c1a4c
           */
          video_id?: string;
          /**
           * @description Index of the first frame in the range.
           * @default 0
           */
          start_frame?: number;
          /** @description Index of the last frame in the range. */
          end_frame: number;
          /**
           * @description Stride (step size), that is the interval between two consecutive frames in the range.
           * If `frame_skip` is 1, all frames are considered to be part of the range.
           */
          frame_skip: number;
        };
      };
    };
    responses: {
      /** @description Explanations successfully retrieved */
      200: {
        content: {
          "application/json": {
            /** @description List of explanations. Each entry corresponds to the explanations for a single media item in the batch. */
            explanations?: {
                /** @description List of explanations (saliency maps) */
                maps?: {
                    /** @description Binary representation of the saliency map */
                    data?: string;
                    /**
                     * @description Mongo ID of the object
                     * @example 60d31793d5f1fb7e6e3c1a4c
                     */
                    label_id?: string;
                  }[];
                /** @description Creation date */
                created?: string;
                /** @description Optional identifier for the media item on which the prediction was made. Only included for persistent media. */
                media_identifier?: OneOf<[{
                  /** @enum {string} */
                  type?: "image";
                  /**
                   * @description Mongo ID of the object
                   * @example 60d31793d5f1fb7e6e3c1a4c
                   */
                  image_id?: string;
                }, {
                  /** @enum {string} */
                  type?: "video_frame";
                  /**
                   * @description Mongo ID of the object
                   * @example 60d31793d5f1fb7e6e3c1a4c
                   */
                  video_id?: string;
                  frame_index?: number;
                }]>;
              }[];
          };
        };
      };
      /** @description No explanations available for the requested media. */
      204: {
        content: never;
      };
      /** @description Too many predictions requested. */
      400: {
        content: never;
      };
      /** @description Object not found. See the examples for details. */
      404: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 400 | 404 | 405 | 409 | 412 | 413 | 415 | 422 | 423 | 500 | 501 | 503;
            /** @description Message from server */
            message: string;
            /** @description Error code from server */
            error_code: string;
          };
        };
      };
    };
  };
  /**
   * Generate prediction using the prompt model
   * @description Generate a prediction for an image or a single video frame using the one-shot learned prompt model.
   */
  GetPromptPrediction: {
    parameters: {
      path: {
        /** @description The ID of the organization. */
        organization_id: string;
        /** @description The ID of the workspace. */
        workspace_id: string;
        /** @description The ID of the project. */
        project_id: string;
        /** @description The ID of the task of interest. */
        task_id: string;
      };
    };
    /** @description Either an image file, or an identifier for an image or single video frame for which a prediction should be returned. */
    requestBody: {
      content: {
        "multipart/form-data": {
          /**
           * Format: binary
           * @description The image file to be uploaded for inference.
           */
          file: string;
        };
        "application/json": OneOf<[{
          /**
           * @description Mongo ID of the object
           * @example 60d31793d5f1fb7e6e3c1a4c
           */
          dataset_id?: string;
          /**
           * @description Mongo ID of the object
           * @example 60d31793d5f1fb7e6e3c1a4c
           */
          image_id?: string;
        }, {
          /**
           * @description Mongo ID of the object
           * @example 60d31793d5f1fb7e6e3c1a4c
           */
          dataset_id?: string;
          /**
           * @description Mongo ID of the object
           * @example 60d31793d5f1fb7e6e3c1a4c
           */
          video_id?: string;
          /**
           * @description This is a 0-based index, meaning to retrieve the first frame of the video, this parameter should be set to `0`.
           * The possible values for this parameter range from `0` to `frame_count-1`. The `frame_count` is the total number of frames contained in the video
           * and it can be retrieved from the response body of [video detail](#Media/GetVideoDetail) endpoint.
           */
          frame_index: number;
        }]>;
      };
    };
    responses: {
      /** @description Prediction successfully generated */
      200: {
        content: {
          "application/json": {
            /** @description List of predictions */
            predictions?: {
                shape?: OneOf<[{
                  /**
                   * @description Type of the shape.
                   * @enum {string}
                   */
                  type: "RECTANGLE";
                  /** @description x-coordinate of the left side of the rectangle. Coordinates are pixel values. */
                  x: number;
                  /** @description y-coordinate of the top of the rectangle. Coordinates are pixel values. */
                  y: number;
                  /** @description Width of the rectangle. Coordinates are pixel values. */
                  width: number;
                  /** @description Height of the rectangle. Coordinates are pixel values. */
                  height: number;
                }, {
                  /**
                   * @description Type of the shape.
                   * @enum {string}
                   */
                  type: "POLYGON";
                  /** @description Array of points that define the polygon. */
                  points: {
                      /** @description x-coordinate of the point. Coordinates are pixel values. */
                      x: number;
                      /** @description y-coordinate of the point. Coordinates are pixel values. */
                      y: number;
                    }[];
                }, {
                  /**
                   * @description Type of the shape.
                   * @enum {string}
                   */
                  type: "ELLIPSE";
                  /** @description Lowest x-coordinate of the ellipse. Coordinates are pixel values. */
                  x: number;
                  /** @description Lowest y-coordinate of the ellipse. Coordinates are pixel values. */
                  y: number;
                  /** @description Width of the ellipse. Coordinates are pixel values. */
                  width: number;
                  /** @description Height of the ellipse. Coordinates are pixel values. */
                  height: number;
                }, {
                  /**
                   * @description Type of the shape.
                   * @enum {string}
                   */
                  type: "ROTATED_RECTANGLE";
                  /** @description Center x-coordinate of the rotated rectangle. Coordinates are pixel values. */
                  x: number;
                  /** @description Center y-coordinate of the rotated rectangle. Coordinates are pixel values. */
                  y: number;
                  /** @description Width of the rotated rectangle (not the encapsulating box of the rectangle). Coordinates are pixel values. */
                  width: number;
                  /** @description Height of the rotated rectangle (not the encapsulating box of the rectangle). Coordinates are pixel values. */
                  height: number;
                  /** @description Clockwise angle in degrees for the rectangle. */
                  angle: number;
                }, {
                  /**
                   * @description Type of the shape.
                   * @enum {string}
                   */
                  type: "KEYPOINT";
                  /** @description X-coordinate of the keypoint. Coordinates are pixel values. */
                  x: number;
                  /** @description Y-coordinate of the keypoint. Coordinates are pixel values. */
                  y: number;
                  /** @description Indicates whether the feature the keypoint is describing is visible in the image. */
                  is_visible: boolean;
                }]>;
                /** @description List of labels */
                labels?: {
                    /**
                     * @description Mongo ID of the object
                     * @example 60d31793d5f1fb7e6e3c1a4c
                     */
                    id?: string;
                    /**
                     * Probability
                     * Format: float
                     * @description Estimated probability of a prediction. For annotations, this is set to 1.
                     */
                    probability?: number;
                  }[];
              }[];
            /** @description Creation date */
            created?: string;
            /** @description Optional identifier for the media item on which the prediction was made. Only included for persistent media. */
            media_identifier?: OneOf<[{
              /** @enum {string} */
              type?: "image";
              /**
               * @description Mongo ID of the object
               * @example 60d31793d5f1fb7e6e3c1a4c
               */
              image_id?: string;
            }, {
              /** @enum {string} */
              type?: "video_frame";
              /**
               * @description Mongo ID of the object
               * @example 60d31793d5f1fb7e6e3c1a4c
               */
              video_id?: string;
              frame_index?: number;
            }]>;
          };
        };
      };
      /** @description Object not found. See the examples for details. */
      404: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 400 | 404 | 405 | 409 | 412 | 413 | 415 | 422 | 423 | 500 | 501 | 503;
            /** @description Message from server */
            message: string;
            /** @description Error code from server */
            error_code: string;
          };
        };
      };
      /** @description Project does not support prompt-based models. */
      405: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 400 | 404 | 405 | 409 | 412 | 413 | 415 | 422 | 423 | 500 | 501 | 503;
            /** @description Message from server */
            message: string;
            /** @description Error code from server */
            error_code: string;
          };
        };
      };
      /** @description One-shot learning is not possible due to missing annotations. */
      409: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 400 | 404 | 405 | 409 | 412 | 413 | 415 | 422 | 423 | 500 | 501 | 503;
            /** @description Message from server */
            message: string;
            /** @description Error code from server */
            error_code: string;
          };
        };
      };
    };
  };
  /**
   * Get info on all jobs
   * @description Get info on all jobs, running and completed.
   */
  GetJobs: {
    parameters: {
      query?: {
        /** @description Select only items related to the given project. */
        project_id?: string;
        /** @description Select only jobs in the given state. */
        state?: "idle" | "running" | "paused" | "finished" | "error" | "failed" | "cancelled";
        /** @description Select only jobs of the given type. */
        job_type?: ("train" | "optimize" | "test")[];
        /** @description Select jobs with matching key. */
        job_key?: string;
        /** @description Filter jobs by the author's unique identifier */
        author_id?: string;
        /** @description Timestamp used to filter jobs which started after the given time (inclusive) */
        start_time_from?: string;
        /** @description Timestamp used to filter jobs which started before the given time (inclusive) */
        start_time_to?: string;
        /**
         * @description Number indicating how many items to skip from the first item that matches the query.
         * This field is used in combination with the limit field for the pagination feature.
         */
        skip?: string;
        /** @description Number of items returned in the response. Default is 10 and maximum is 100. */
        limit?: number;
        /** @description Field to sort by, could be [job_name, start_time, end_time, creation_date, priority] */
        sort_by?: "job_name" | "start_time" | "end_time" | "creation_date" | "priority";
        /** @description Sorting order, could be `asc` (ascending) or `dsc` (descending). */
        sort_direction?: "asc" | "dsc";
      };
      path: {
        /** @description The ID of the organization. */
        organization_id: string;
        /** @description The ID of the workspace. */
        workspace_id: string;
      };
    };
    responses: {
      /** @description Jobs successfully retrieved */
      200: {
        content: {
          "application/json": {
            /** @description Array of jobs */
            jobs?: (({
                /** @description Name of the job */
                name?: string;
                /** @description The time at which the job was created */
                creation_time?: string;
                /**
                 * @description Mongo ID of the object
                 * @example 60d31793d5f1fb7e6e3c1a4c
                 */
                id?: string;
                /** @description Identifier of the user who submitted the job */
                author?: string;
                /** @description Information detailing the cancellation status of the job */
                cancellation_info?: {
                  /** @description whether the job can be cancelled after startup */
                  cancellable?: boolean | null;
                  /** @description whether the job is cancelled */
                  is_cancelled?: boolean | null;
                  /** @description The user UID who requested the cancellation */
                  user_uid?: string | null;
                  /**
                   * Format: date-time
                   * @description The time of cancellation
                   */
                  cancel_time?: string | null;
                };
                /** @description Progress details for each step of the job */
                steps?: ({
                    /** @description Status message */
                    message?: string | null;
                    /** @description The index of the step within the job */
                    index?: number;
                    /**
                     * Format: float
                     * @description Step progress from 0 to 100
                     */
                    progress?: number;
                    /** @description Step state */
                    state?: string;
                    /** @description Step name */
                    step_name?: string;
                    /**
                     * Format: float
                     * @description Step duration in seconds
                     */
                    duration?: number | null;
                    /** @description Step warning message */
                    warning?: string | null;
                  })[];
                /**
                 * Format: date-time
                 * @description Start time of the job
                 */
                start_time?: string | null;
                /**
                 * Format: date-time
                 * @description End time of the job
                 */
                end_time?: string | null;
                /** @description The state of the job */
                state?: string;
                /**
                 * @description Type of the job.
                 * @enum {string}
                 */
                type?: "train";
                /**
                 * Metadata of train job
                 * @description Additional information associated with the train job
                 */
                metadata?: {
                  /** @description Information about the task associated with the job, if any */
                  task?: {
                    /** @description Name of the task */
                    name?: string;
                    /** @description Identifier of the model template used by the task */
                    model_template_id?: string;
                    /** @description Neural network architecture used for the model */
                    model_architecture?: string;
                    /**
                     * @description Mongo ID of the object
                     * @example 60d31793d5f1fb7e6e3c1a4c
                     */
                    dataset_storage_id?: string;
                    /**
                     * @description Mongo ID of the object
                     * @example 60d31793d5f1fb7e6e3c1a4c
                     */
                    task_id?: string;
                  };
                  /** @description Information about the project associated with the job */
                  project?: {
                    /**
                     * @description Mongo ID of the object
                     * @example 60d31793d5f1fb7e6e3c1a4c
                     */
                    id?: string;
                    /** @description Name of the project */
                    name?: string;
                  };
                  /** @description Information about the trained model */
                  trained_model?: {
                    /**
                     * @description Mongo ID of the object
                     * @example 60d31793d5f1fb7e6e3c1a4c
                     */
                    model_storage_id?: string;
                    /**
                     * @description Mongo ID of the object
                     * @example 60d31793d5f1fb7e6e3c1a4c
                     */
                    model_id?: string;
                    /** @description Whether the model became the active one after training */
                    model_activated?: boolean;
                  };
                };
              }) | ({
                /** @description Name of the job */
                name?: string;
                /** @description The time at which the job was created */
                creation_time?: string;
                /**
                 * @description Mongo ID of the object
                 * @example 60d31793d5f1fb7e6e3c1a4c
                 */
                id?: string;
                /** @description Identifier of the user who submitted the job */
                author?: string;
                /** @description Information detailing the cancellation status of the job */
                cancellation_info?: {
                  /** @description whether the job can be cancelled after startup */
                  cancellable?: boolean | null;
                  /** @description whether the job is cancelled */
                  is_cancelled?: boolean | null;
                  /** @description The user UID who requested the cancellation */
                  user_uid?: string | null;
                  /**
                   * Format: date-time
                   * @description The time of cancellation
                   */
                  cancel_time?: string | null;
                };
                /** @description Progress details for each step of the job */
                steps?: ({
                    /** @description Status message */
                    message?: string | null;
                    /** @description The index of the step within the job */
                    index?: number;
                    /**
                     * Format: float
                     * @description Step progress from 0 to 100
                     */
                    progress?: number;
                    /** @description Step state */
                    state?: string;
                    /** @description Step name */
                    step_name?: string;
                    /**
                     * Format: float
                     * @description Step duration in seconds
                     */
                    duration?: number | null;
                    /** @description Step warning message */
                    warning?: string | null;
                  })[];
                /**
                 * Format: date-time
                 * @description Start time of the job
                 */
                start_time?: string | null;
                /**
                 * Format: date-time
                 * @description End time of the job
                 */
                end_time?: string | null;
                /** @description The state of the job */
                state?: string;
                /**
                 * @description Type of the job.
                 * @enum {string}
                 */
                type?: "test";
                /**
                 * Metadata of train/optimize/test job
                 * @description Additional information associated with the train/optimize/test job
                 */
                metadata?: {
                  /** @description Information about the task associated with the job, if any */
                  task?: {
                    /** @description Name of the task */
                    name?: string;
                    /** @description Identifier of the model template used by the task */
                    model_template_id?: string;
                    /** @description Neural network architecture used for the model */
                    model_architecture?: string;
                    /**
                     * @description Mongo ID of the object
                     * @example 60d31793d5f1fb7e6e3c1a4c
                     */
                    dataset_storage_id?: string;
                    /**
                     * @description Mongo ID of the object
                     * @example 60d31793d5f1fb7e6e3c1a4c
                     */
                    task_id?: string;
                  };
                  /** @description Information about the test associated with the job, if any */
                  test?: {
                    /** @description Identifier of the model template used by the task */
                    model_template_id?: string;
                    /** @description Neural network architecture used for the model */
                    model_architecture?: string;
                    model?: unknown;
                    /** @description Array of datasets */
                    datasets?: {
                        /**
                         * @description Mongo ID of the object
                         * @example 60d31793d5f1fb7e6e3c1a4c
                         */
                        id?: string;
                        /** @description boolean showing whether the dataset is deleted */
                        is_deleted?: boolean;
                        /** @description Name of the dataset */
                        name?: string;
                        /**
                         * Format: int32
                         * @description Number of images in the dataset
                         */
                        n_images?: number;
                        /**
                         * Format: int32
                         * @description Number of frames in the dataset
                         */
                        n_frames?: number;
                        /**
                         * Format: int32
                         * @description Number of samples in the dataset
                         */
                        n_samples?: number;
                      }[];
                  };
                  /** @description Information about the project associated with the job */
                  project?: {
                    /**
                     * @description Mongo ID of the object
                     * @example 60d31793d5f1fb7e6e3c1a4c
                     */
                    id?: string;
                    /** @description Name of the project */
                    name?: string;
                  };
                };
              }) | ({
                /** @description Name of the job */
                name?: string;
                /** @description The time at which the job was created */
                creation_time?: string;
                /**
                 * @description Mongo ID of the object
                 * @example 60d31793d5f1fb7e6e3c1a4c
                 */
                id?: string;
                /** @description Identifier of the user who submitted the job */
                author?: string;
                /** @description Information detailing the cancellation status of the job */
                cancellation_info?: {
                  /** @description whether the job can be cancelled after startup */
                  cancellable?: boolean | null;
                  /** @description whether the job is cancelled */
                  is_cancelled?: boolean | null;
                  /** @description The user UID who requested the cancellation */
                  user_uid?: string | null;
                  /**
                   * Format: date-time
                   * @description The time of cancellation
                   */
                  cancel_time?: string | null;
                };
                /** @description Progress details for each step of the job */
                steps?: ({
                    /** @description Status message */
                    message?: string | null;
                    /** @description The index of the step within the job */
                    index?: number;
                    /**
                     * Format: float
                     * @description Step progress from 0 to 100
                     */
                    progress?: number;
                    /** @description Step state */
                    state?: string;
                    /** @description Step name */
                    step_name?: string;
                    /**
                     * Format: float
                     * @description Step duration in seconds
                     */
                    duration?: number | null;
                    /** @description Step warning message */
                    warning?: string | null;
                  })[];
                /**
                 * Format: date-time
                 * @description Start time of the job
                 */
                start_time?: string | null;
                /**
                 * Format: date-time
                 * @description End time of the job
                 */
                end_time?: string | null;
                /** @description The state of the job */
                state?: string;
                /**
                 * @description Type of the job.
                 * @enum {string}
                 */
                type?: "optimize";
                /**
                 * Metadata of optimize job
                 * @description Additional information associated with the optimize job
                 */
                metadata?: {
                  /** @description Information about the task associated with the job, if any */
                  task?: {
                    /** @description Name of the task */
                    name?: string;
                    /** @description Identifier of the model template used by the task */
                    model_template_id?: string;
                    /** @description Neural network architecture used for the model */
                    model_architecture?: string;
                    /**
                     * @description Mongo ID of the object
                     * @example 60d31793d5f1fb7e6e3c1a4c
                     */
                    dataset_storage_id?: string;
                    /**
                     * @description Mongo ID of the object
                     * @example 60d31793d5f1fb7e6e3c1a4c
                     */
                    task_id?: string;
                  };
                  /** @description Information about the project associated with the job */
                  project?: {
                    /**
                     * @description Mongo ID of the object
                     * @example 60d31793d5f1fb7e6e3c1a4c
                     */
                    id?: string;
                    /** @description Name of the project */
                    name?: string;
                  };
                  /**
                   * @description Mongo ID of the object
                   * @example 60d31793d5f1fb7e6e3c1a4c
                   */
                  model_storage_id?: string;
                  /**
                   * @description Type of optimization
                   * @enum {string}
                   */
                  optimization_type?: "POT";
                  /**
                   * @description Mongo ID of the object
                   * @example 60d31793d5f1fb7e6e3c1a4c
                   */
                  base_model_id?: string;
                  /**
                   * @description Mongo ID of the object
                   * @example 60d31793d5f1fb7e6e3c1a4c
                   */
                  optimized_model_id?: string;
                };
              }) | ({
                /** @description Name of the job */
                name?: string;
                /** @description The time at which the job was created */
                creation_time?: string;
                /**
                 * @description Mongo ID of the object
                 * @example 60d31793d5f1fb7e6e3c1a4c
                 */
                id?: string;
                /** @description Identifier of the user who submitted the job */
                author?: string;
                /** @description Information detailing the cancellation status of the job */
                cancellation_info?: {
                  /** @description whether the job can be cancelled after startup */
                  cancellable?: boolean | null;
                  /** @description whether the job is cancelled */
                  is_cancelled?: boolean | null;
                  /** @description The user UID who requested the cancellation */
                  user_uid?: string | null;
                  /**
                   * Format: date-time
                   * @description The time of cancellation
                   */
                  cancel_time?: string | null;
                };
                /** @description Progress details for each step of the job */
                steps?: ({
                    /** @description Status message */
                    message?: string | null;
                    /** @description The index of the step within the job */
                    index?: number;
                    /**
                     * Format: float
                     * @description Step progress from 0 to 100
                     */
                    progress?: number;
                    /** @description Step state */
                    state?: string;
                    /** @description Step name */
                    step_name?: string;
                    /**
                     * Format: float
                     * @description Step duration in seconds
                     */
                    duration?: number | null;
                    /** @description Step warning message */
                    warning?: string | null;
                  })[];
                /**
                 * Format: date-time
                 * @description Start time of the job
                 */
                start_time?: string | null;
                /**
                 * Format: date-time
                 * @description End time of the job
                 */
                end_time?: string | null;
                /** @description The state of the job */
                state?: string;
                /**
                 * @description Type of the job.
                 * @enum {string}
                 */
                type?: "prepare_import_to_new_project";
                /**
                 * Metadata of `prepare_import_to_new_project` job
                 * @description Supported project types and warnings
                 */
                metadata?: {
                  /** @description ID of the uploaded dataset file to be imported */
                  file_id?: string;
                  /** @description Warnings to import dataset to specific domain */
                  warnings?: ({
                      /**
                       * @description Type of the warning
                       * @enum {string}
                       */
                      type: "error" | "warning";
                      /**
                       * @description Name of the warning
                       * @example Missing expected annotation type for classification domain
                       */
                      name: string;
                      /** @description Detailed description of the warning */
                      description: string;
                      /** @description How to handle the warning */
                      resolve_strategy?: string;
                      /**
                       * Format: int32
                       * @description Number of affected images
                       */
                      affected_images?: number;
                    })[];
                  /** @description Supported project types and corresponding labels */
                  supported_project_types?: ({
                      /**
                       * @description Project type name
                       * @enum {string}
                       */
                      project_type: "classification" | "classification_hierarchical" | "detection" | "segmentation" | "instance_segmentation" | "anomaly" | "detection_oriented" | "detection_classification" | "detection_segmentation" | "keypoint_detection";
                      pipeline: {
                        connections: {
                            /** @description Source task name */
                            from: string;
                            /** @description Target task name */
                            to: string;
                          }[];
                        tasks: ({
                            /** @description Task name */
                            title: string;
                            /**
                             * @description OTX Task type name in lowercase
                             * @enum {string}
                             */
                            task_type: "dataset" | "classification" | "segmentation" | "detection" | "crop" | "instance_segmentation" | "keypoint_detection" | "anomaly" | "rotated_detection";
                            labels: {
                                /** @description Label name */
                                name: string;
                                /** @description Label group name */
                                group?: string;
                                /** @description Label parent name */
                                parent?: string;
                              }[];
                          })[];
                      };
                    })[];
                };
              }) | ({
                /** @description Name of the job */
                name?: string;
                /** @description The time at which the job was created */
                creation_time?: string;
                /**
                 * @description Mongo ID of the object
                 * @example 60d31793d5f1fb7e6e3c1a4c
                 */
                id?: string;
                /** @description Identifier of the user who submitted the job */
                author?: string;
                /** @description Information detailing the cancellation status of the job */
                cancellation_info?: {
                  /** @description whether the job can be cancelled after startup */
                  cancellable?: boolean | null;
                  /** @description whether the job is cancelled */
                  is_cancelled?: boolean | null;
                  /** @description The user UID who requested the cancellation */
                  user_uid?: string | null;
                  /**
                   * Format: date-time
                   * @description The time of cancellation
                   */
                  cancel_time?: string | null;
                };
                /** @description Progress details for each step of the job */
                steps?: ({
                    /** @description Status message */
                    message?: string | null;
                    /** @description The index of the step within the job */
                    index?: number;
                    /**
                     * Format: float
                     * @description Step progress from 0 to 100
                     */
                    progress?: number;
                    /** @description Step state */
                    state?: string;
                    /** @description Step name */
                    step_name?: string;
                    /**
                     * Format: float
                     * @description Step duration in seconds
                     */
                    duration?: number | null;
                    /** @description Step warning message */
                    warning?: string | null;
                  })[];
                /**
                 * Format: date-time
                 * @description Start time of the job
                 */
                start_time?: string | null;
                /**
                 * Format: date-time
                 * @description End time of the job
                 */
                end_time?: string | null;
                /** @description The state of the job */
                state?: string;
                /**
                 * @description Type of the job.
                 * @enum {string}
                 */
                type?: "perform_import_to_new_project";
                /**
                 * Metadata of `perform_import_to_new_project` job
                 * @description Created project ID
                 */
                metadata?: {
                  /** @description ID of the uploaded dataset file to be imported */
                  file_id?: string;
                  /** @description Information about the project to create */
                  project?: {
                    id?: string;
                    name?: string;
                  };
                  /**
                   * @description Mongo ID of the object
                   * @example 60d31793d5f1fb7e6e3c1a4c
                   */
                  project_id?: string;
                };
              }) | ({
                /** @description Name of the job */
                name?: string;
                /** @description The time at which the job was created */
                creation_time?: string;
                /**
                 * @description Mongo ID of the object
                 * @example 60d31793d5f1fb7e6e3c1a4c
                 */
                id?: string;
                /** @description Identifier of the user who submitted the job */
                author?: string;
                /** @description Information detailing the cancellation status of the job */
                cancellation_info?: {
                  /** @description whether the job can be cancelled after startup */
                  cancellable?: boolean | null;
                  /** @description whether the job is cancelled */
                  is_cancelled?: boolean | null;
                  /** @description The user UID who requested the cancellation */
                  user_uid?: string | null;
                  /**
                   * Format: date-time
                   * @description The time of cancellation
                   */
                  cancel_time?: string | null;
                };
                /** @description Progress details for each step of the job */
                steps?: ({
                    /** @description Status message */
                    message?: string | null;
                    /** @description The index of the step within the job */
                    index?: number;
                    /**
                     * Format: float
                     * @description Step progress from 0 to 100
                     */
                    progress?: number;
                    /** @description Step state */
                    state?: string;
                    /** @description Step name */
                    step_name?: string;
                    /**
                     * Format: float
                     * @description Step duration in seconds
                     */
                    duration?: number | null;
                    /** @description Step warning message */
                    warning?: string | null;
                  })[];
                /**
                 * Format: date-time
                 * @description Start time of the job
                 */
                start_time?: string | null;
                /**
                 * Format: date-time
                 * @description End time of the job
                 */
                end_time?: string | null;
                /** @description The state of the job */
                state?: string;
                /**
                 * @description Type of the job.
                 * @enum {string}
                 */
                type?: "prepare_import_to_existing_project";
                /**
                 * Metadata of `prepare_import_to_existing_project` job
                 * @description Labels in the dataset and warnings
                 */
                metadata?: {
                  /** @description ID of the uploaded dataset file to be imported */
                  file_id?: string;
                  /** @description Information about the project where the dataset is imported */
                  project?: {
                    /** @description ID of the project */
                    id?: string;
                    /** @description Name of the project */
                    name?: string;
                    /**
                     * @description Type name of the project
                     * @enum {string}
                     */
                    type?: "classification" | "classification_hierarchical" | "detection" | "segmentation" | "instance_segmentation" | "anomaly" | "detection_oriented" | "detection_classification" | "detection_segmentation" | "keypoint_detection";
                  };
                  /** @description Warnings to import dataset to specific domain */
                  warnings?: ({
                      /**
                       * @description Type of the warning
                       * @enum {string}
                       */
                      type: "error" | "warning";
                      /**
                       * @description Name of the warning
                       * @example Missing expected annotation type for classification domain
                       */
                      name: string;
                      /** @description Detailed description of the warning */
                      description: string;
                      /** @description How to handle the warning */
                      resolve_strategy?: string;
                      /**
                       * Format: int32
                       * @description Number of affected images
                       */
                      affected_images?: number;
                    })[];
                  /** @description Label names in the dataset */
                  labels?: string[];
                };
              }) | ({
                /** @description Name of the job */
                name?: string;
                /** @description The time at which the job was created */
                creation_time?: string;
                /**
                 * @description Mongo ID of the object
                 * @example 60d31793d5f1fb7e6e3c1a4c
                 */
                id?: string;
                /** @description Identifier of the user who submitted the job */
                author?: string;
                /** @description Information detailing the cancellation status of the job */
                cancellation_info?: {
                  /** @description whether the job can be cancelled after startup */
                  cancellable?: boolean | null;
                  /** @description whether the job is cancelled */
                  is_cancelled?: boolean | null;
                  /** @description The user UID who requested the cancellation */
                  user_uid?: string | null;
                  /**
                   * Format: date-time
                   * @description The time of cancellation
                   */
                  cancel_time?: string | null;
                };
                /** @description Progress details for each step of the job */
                steps?: ({
                    /** @description Status message */
                    message?: string | null;
                    /** @description The index of the step within the job */
                    index?: number;
                    /**
                     * Format: float
                     * @description Step progress from 0 to 100
                     */
                    progress?: number;
                    /** @description Step state */
                    state?: string;
                    /** @description Step name */
                    step_name?: string;
                    /**
                     * Format: float
                     * @description Step duration in seconds
                     */
                    duration?: number | null;
                    /** @description Step warning message */
                    warning?: string | null;
                  })[];
                /**
                 * Format: date-time
                 * @description Start time of the job
                 */
                start_time?: string | null;
                /**
                 * Format: date-time
                 * @description End time of the job
                 */
                end_time?: string | null;
                /** @description The state of the job */
                state?: string;
                /**
                 * @description Type of the job.
                 * @enum {string}
                 */
                type?: "perform_import_to_existing_project";
                /**
                 * Metadata of `perform_import_to_existing_project` job
                 * @description Imported dataset information
                 */
                metadata?: {
                  /** @description ID of the uploaded dataset file to be imported */
                  file_id?: string;
                  /** @description Information about the project where the dataset is imported */
                  project?: {
                    /** @description ID of the project */
                    id?: string;
                    /** @description Name of the project */
                    name?: string;
                    /**
                     * @description Type name of the project
                     * @enum {string}
                     */
                    type?: "classification" | "classification_hierarchical" | "detection" | "segmentation" | "instance_segmentation" | "anomaly" | "detection_oriented" | "detection_classification" | "detection_segmentation" | "keypoint_detection";
                  };
                  /** @description The dataset information for importing the uploaded dataset file */
                  dataset?: {
                    /**
                     * @description Mongo ID of the object
                     * @example 60d31793d5f1fb7e6e3c1a4c
                     */
                    id?: string;
                    /** @description Name of the dataset storage */
                    name?: string;
                    /** @description Whether the dataset will be used for training or not */
                    use_for_training?: boolean;
                    /**
                     * @description The time at which the dataset was created
                     * @example 2024-03-05T06:34:32.332000+00:00
                     */
                    creation_time?: string;
                  };
                };
              }) | ({
                /** @description Name of the job */
                name?: string;
                /** @description The time at which the job was created */
                creation_time?: string;
                /**
                 * @description Mongo ID of the object
                 * @example 60d31793d5f1fb7e6e3c1a4c
                 */
                id?: string;
                /** @description Identifier of the user who submitted the job */
                author?: string;
                /** @description Information detailing the cancellation status of the job */
                cancellation_info?: {
                  /** @description whether the job can be cancelled after startup */
                  cancellable?: boolean | null;
                  /** @description whether the job is cancelled */
                  is_cancelled?: boolean | null;
                  /** @description The user UID who requested the cancellation */
                  user_uid?: string | null;
                  /**
                   * Format: date-time
                   * @description The time of cancellation
                   */
                  cancel_time?: string | null;
                };
                /** @description Progress details for each step of the job */
                steps?: ({
                    /** @description Status message */
                    message?: string | null;
                    /** @description The index of the step within the job */
                    index?: number;
                    /**
                     * Format: float
                     * @description Step progress from 0 to 100
                     */
                    progress?: number;
                    /** @description Step state */
                    state?: string;
                    /** @description Step name */
                    step_name?: string;
                    /**
                     * Format: float
                     * @description Step duration in seconds
                     */
                    duration?: number | null;
                    /** @description Step warning message */
                    warning?: string | null;
                  })[];
                /**
                 * Format: date-time
                 * @description Start time of the job
                 */
                start_time?: string | null;
                /**
                 * Format: date-time
                 * @description End time of the job
                 */
                end_time?: string | null;
                /** @description The state of the job */
                state?: string;
                /**
                 * @description Type of the job.
                 * @enum {string}
                 */
                type?: "export_dataset";
                /**
                 * Metadata of `export_dataset` job
                 * @description Information about the exported dataset
                 */
                metadata?: {
                  /** @description Information about the project to export */
                  project?: {
                    /** @description ID of the project */
                    id?: string;
                    /** @description Name of the project */
                    name?: string;
                    /**
                     * @description Type name of the project
                     * @enum {string}
                     */
                    type?: "classification" | "classification_hierarchical" | "detection" | "segmentation" | "instance_segmentation" | "anomaly" | "detection_oriented" | "detection_classification" | "detection_segmentation" | "keypoint_detection";
                  };
                  /** @description Thd dataset information to be exported */
                  dataset?: {
                    /** @description ID of the dataset storage */
                    id?: string;
                    /** @description Name of the dataset storage */
                    name?: string;
                  };
                  /**
                   * @description Format of the dataset to be exported
                   * @enum {string}
                   */
                  export_format?: "voc" | "coco" | "yolo" | "datumaro";
                  /** @description URL to download the prepared dataset */
                  download_url?: string;
                };
              }))[];
            /** @description Jobs count information for each job state */
            jobs_count?: {
              /** @description Number of scheduled jobs */
              n_scheduled_jobs?: number;
              /** @description Number of running jobs */
              n_running_jobs?: number;
              /** @description Number of finished jobs */
              n_finished_jobs?: number;
              /** @description Number of failed jobs */
              n_failed_jobs?: number;
              /** @description Number of cancelled jobs */
              n_cancelled_jobs?: number;
            };
            /** @description URL to the next jobs page */
            next_page?: string;
          };
        };
      };
      /** @description Object not found. See the examples for details. */
      404: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 400 | 404 | 405 | 409 | 412 | 413 | 415 | 422 | 423 | 500 | 501 | 503;
            /** @description Message from server */
            message: string;
            /** @description Error code from server */
            error_code: string;
          };
        };
      };
    };
  };
  /**
   * Get info on a job
   * @description Get information on a running or completed job.
   */
  GetJob: {
    parameters: {
      path: {
        /** @description The ID of the organization. */
        organization_id: string;
        /** @description The ID of the workspace. */
        workspace_id: string;
        /** @description The ID of the job of interest */
        job_id: string;
      };
    };
    responses: {
      /** @description Information successfully retrieved */
      200: {
        content: {
          "application/json": ({
            /** @description Name of the job */
            name?: string;
            /** @description The time at which the job was created */
            creation_time?: string;
            /**
             * @description Mongo ID of the object
             * @example 60d31793d5f1fb7e6e3c1a4c
             */
            id?: string;
            /** @description Identifier of the user who submitted the job */
            author?: string;
            /** @description Information detailing the cancellation status of the job */
            cancellation_info?: {
              /** @description whether the job can be cancelled after startup */
              cancellable?: boolean | null;
              /** @description whether the job is cancelled */
              is_cancelled?: boolean | null;
              /** @description The user UID who requested the cancellation */
              user_uid?: string | null;
              /**
               * Format: date-time
               * @description The time of cancellation
               */
              cancel_time?: string | null;
            };
            /** @description Progress details for each step of the job */
            steps?: ({
                /** @description Status message */
                message?: string | null;
                /** @description The index of the step within the job */
                index?: number;
                /**
                 * Format: float
                 * @description Step progress from 0 to 100
                 */
                progress?: number;
                /** @description Step state */
                state?: string;
                /** @description Step name */
                step_name?: string;
                /**
                 * Format: float
                 * @description Step duration in seconds
                 */
                duration?: number | null;
                /** @description Step warning message */
                warning?: string | null;
              })[];
            /**
             * Format: date-time
             * @description Start time of the job
             */
            start_time?: string | null;
            /**
             * Format: date-time
             * @description End time of the job
             */
            end_time?: string | null;
            /** @description The state of the job */
            state?: string;
            /**
             * @description Type of the job.
             * @enum {string}
             */
            type?: "train";
            /**
             * Metadata of train job
             * @description Additional information associated with the train job
             */
            metadata?: {
              /** @description Information about the task associated with the job, if any */
              task?: {
                /** @description Name of the task */
                name?: string;
                /** @description Identifier of the model template used by the task */
                model_template_id?: string;
                /** @description Neural network architecture used for the model */
                model_architecture?: string;
                /**
                 * @description Mongo ID of the object
                 * @example 60d31793d5f1fb7e6e3c1a4c
                 */
                dataset_storage_id?: string;
                /**
                 * @description Mongo ID of the object
                 * @example 60d31793d5f1fb7e6e3c1a4c
                 */
                task_id?: string;
              };
              /** @description Information about the project associated with the job */
              project?: {
                /**
                 * @description Mongo ID of the object
                 * @example 60d31793d5f1fb7e6e3c1a4c
                 */
                id?: string;
                /** @description Name of the project */
                name?: string;
              };
              /** @description Information about the trained model */
              trained_model?: {
                /**
                 * @description Mongo ID of the object
                 * @example 60d31793d5f1fb7e6e3c1a4c
                 */
                model_storage_id?: string;
                /**
                 * @description Mongo ID of the object
                 * @example 60d31793d5f1fb7e6e3c1a4c
                 */
                model_id?: string;
                /** @description Whether the model became the active one after training */
                model_activated?: boolean;
              };
            };
          }) | ({
            /** @description Name of the job */
            name?: string;
            /** @description The time at which the job was created */
            creation_time?: string;
            /**
             * @description Mongo ID of the object
             * @example 60d31793d5f1fb7e6e3c1a4c
             */
            id?: string;
            /** @description Identifier of the user who submitted the job */
            author?: string;
            /** @description Information detailing the cancellation status of the job */
            cancellation_info?: {
              /** @description whether the job can be cancelled after startup */
              cancellable?: boolean | null;
              /** @description whether the job is cancelled */
              is_cancelled?: boolean | null;
              /** @description The user UID who requested the cancellation */
              user_uid?: string | null;
              /**
               * Format: date-time
               * @description The time of cancellation
               */
              cancel_time?: string | null;
            };
            /** @description Progress details for each step of the job */
            steps?: ({
                /** @description Status message */
                message?: string | null;
                /** @description The index of the step within the job */
                index?: number;
                /**
                 * Format: float
                 * @description Step progress from 0 to 100
                 */
                progress?: number;
                /** @description Step state */
                state?: string;
                /** @description Step name */
                step_name?: string;
                /**
                 * Format: float
                 * @description Step duration in seconds
                 */
                duration?: number | null;
                /** @description Step warning message */
                warning?: string | null;
              })[];
            /**
             * Format: date-time
             * @description Start time of the job
             */
            start_time?: string | null;
            /**
             * Format: date-time
             * @description End time of the job
             */
            end_time?: string | null;
            /** @description The state of the job */
            state?: string;
            /**
             * @description Type of the job.
             * @enum {string}
             */
            type?: "optimize";
            /**
             * Metadata of optimize job
             * @description Additional information associated with the optimize job
             */
            metadata?: {
              /** @description Information about the task associated with the job, if any */
              task?: {
                /** @description Name of the task */
                name?: string;
                /** @description Identifier of the model template used by the task */
                model_template_id?: string;
                /** @description Neural network architecture used for the model */
                model_architecture?: string;
                /**
                 * @description Mongo ID of the object
                 * @example 60d31793d5f1fb7e6e3c1a4c
                 */
                dataset_storage_id?: string;
                /**
                 * @description Mongo ID of the object
                 * @example 60d31793d5f1fb7e6e3c1a4c
                 */
                task_id?: string;
              };
              /** @description Information about the project associated with the job */
              project?: {
                /**
                 * @description Mongo ID of the object
                 * @example 60d31793d5f1fb7e6e3c1a4c
                 */
                id?: string;
                /** @description Name of the project */
                name?: string;
              };
              /**
               * @description Mongo ID of the object
               * @example 60d31793d5f1fb7e6e3c1a4c
               */
              model_storage_id?: string;
              /**
               * @description Type of optimization
               * @enum {string}
               */
              optimization_type?: "POT";
              /**
               * @description Mongo ID of the object
               * @example 60d31793d5f1fb7e6e3c1a4c
               */
              base_model_id?: string;
              /**
               * @description Mongo ID of the object
               * @example 60d31793d5f1fb7e6e3c1a4c
               */
              optimized_model_id?: string;
            };
          }) | ({
            /** @description Name of the job */
            name?: string;
            /** @description The time at which the job was created */
            creation_time?: string;
            /**
             * @description Mongo ID of the object
             * @example 60d31793d5f1fb7e6e3c1a4c
             */
            id?: string;
            /** @description Identifier of the user who submitted the job */
            author?: string;
            /** @description Information detailing the cancellation status of the job */
            cancellation_info?: {
              /** @description whether the job can be cancelled after startup */
              cancellable?: boolean | null;
              /** @description whether the job is cancelled */
              is_cancelled?: boolean | null;
              /** @description The user UID who requested the cancellation */
              user_uid?: string | null;
              /**
               * Format: date-time
               * @description The time of cancellation
               */
              cancel_time?: string | null;
            };
            /** @description Progress details for each step of the job */
            steps?: ({
                /** @description Status message */
                message?: string | null;
                /** @description The index of the step within the job */
                index?: number;
                /**
                 * Format: float
                 * @description Step progress from 0 to 100
                 */
                progress?: number;
                /** @description Step state */
                state?: string;
                /** @description Step name */
                step_name?: string;
                /**
                 * Format: float
                 * @description Step duration in seconds
                 */
                duration?: number | null;
                /** @description Step warning message */
                warning?: string | null;
              })[];
            /**
             * Format: date-time
             * @description Start time of the job
             */
            start_time?: string | null;
            /**
             * Format: date-time
             * @description End time of the job
             */
            end_time?: string | null;
            /** @description The state of the job */
            state?: string;
            /**
             * @description Type of the job.
             * @enum {string}
             */
            type?: "test";
            /**
             * Metadata of train/optimize/test job
             * @description Additional information associated with the train/optimize/test job
             */
            metadata?: {
              /** @description Information about the task associated with the job, if any */
              task?: {
                /** @description Name of the task */
                name?: string;
                /** @description Identifier of the model template used by the task */
                model_template_id?: string;
                /** @description Neural network architecture used for the model */
                model_architecture?: string;
                /**
                 * @description Mongo ID of the object
                 * @example 60d31793d5f1fb7e6e3c1a4c
                 */
                dataset_storage_id?: string;
                /**
                 * @description Mongo ID of the object
                 * @example 60d31793d5f1fb7e6e3c1a4c
                 */
                task_id?: string;
              };
              /** @description Information about the test associated with the job, if any */
              test?: {
                /** @description Identifier of the model template used by the task */
                model_template_id?: string;
                /** @description Neural network architecture used for the model */
                model_architecture?: string;
                model?: unknown;
                /** @description Array of datasets */
                datasets?: {
                    /**
                     * @description Mongo ID of the object
                     * @example 60d31793d5f1fb7e6e3c1a4c
                     */
                    id?: string;
                    /** @description boolean showing whether the dataset is deleted */
                    is_deleted?: boolean;
                    /** @description Name of the dataset */
                    name?: string;
                    /**
                     * Format: int32
                     * @description Number of images in the dataset
                     */
                    n_images?: number;
                    /**
                     * Format: int32
                     * @description Number of frames in the dataset
                     */
                    n_frames?: number;
                    /**
                     * Format: int32
                     * @description Number of samples in the dataset
                     */
                    n_samples?: number;
                  }[];
              };
              /** @description Information about the project associated with the job */
              project?: {
                /**
                 * @description Mongo ID of the object
                 * @example 60d31793d5f1fb7e6e3c1a4c
                 */
                id?: string;
                /** @description Name of the project */
                name?: string;
              };
            };
          }) | ({
            /** @description Name of the job */
            name?: string;
            /** @description The time at which the job was created */
            creation_time?: string;
            /**
             * @description Mongo ID of the object
             * @example 60d31793d5f1fb7e6e3c1a4c
             */
            id?: string;
            /** @description Identifier of the user who submitted the job */
            author?: string;
            /** @description Information detailing the cancellation status of the job */
            cancellation_info?: {
              /** @description whether the job can be cancelled after startup */
              cancellable?: boolean | null;
              /** @description whether the job is cancelled */
              is_cancelled?: boolean | null;
              /** @description The user UID who requested the cancellation */
              user_uid?: string | null;
              /**
               * Format: date-time
               * @description The time of cancellation
               */
              cancel_time?: string | null;
            };
            /** @description Progress details for each step of the job */
            steps?: ({
                /** @description Status message */
                message?: string | null;
                /** @description The index of the step within the job */
                index?: number;
                /**
                 * Format: float
                 * @description Step progress from 0 to 100
                 */
                progress?: number;
                /** @description Step state */
                state?: string;
                /** @description Step name */
                step_name?: string;
                /**
                 * Format: float
                 * @description Step duration in seconds
                 */
                duration?: number | null;
                /** @description Step warning message */
                warning?: string | null;
              })[];
            /**
             * Format: date-time
             * @description Start time of the job
             */
            start_time?: string | null;
            /**
             * Format: date-time
             * @description End time of the job
             */
            end_time?: string | null;
            /** @description The state of the job */
            state?: string;
            /**
             * @description Type of the job.
             * @enum {string}
             */
            type?: "export_dataset";
            /**
             * Metadata of `export_dataset` job
             * @description Information about the exported dataset
             */
            metadata?: {
              /** @description Information about the project to export */
              project?: {
                /** @description ID of the project */
                id?: string;
                /** @description Name of the project */
                name?: string;
                /**
                 * @description Type name of the project
                 * @enum {string}
                 */
                type?: "classification" | "classification_hierarchical" | "detection" | "segmentation" | "instance_segmentation" | "anomaly" | "detection_oriented" | "detection_classification" | "detection_segmentation" | "keypoint_detection";
              };
              /** @description Thd dataset information to be exported */
              dataset?: {
                /** @description ID of the dataset storage */
                id?: string;
                /** @description Name of the dataset storage */
                name?: string;
              };
              /**
               * @description Format of the dataset to be exported
               * @enum {string}
               */
              export_format?: "voc" | "coco" | "yolo" | "datumaro";
              /** @description URL to download the prepared dataset */
              download_url?: string;
            };
          }) | ({
            /** @description Name of the job */
            name?: string;
            /** @description The time at which the job was created */
            creation_time?: string;
            /**
             * @description Mongo ID of the object
             * @example 60d31793d5f1fb7e6e3c1a4c
             */
            id?: string;
            /** @description Identifier of the user who submitted the job */
            author?: string;
            /** @description Information detailing the cancellation status of the job */
            cancellation_info?: {
              /** @description whether the job can be cancelled after startup */
              cancellable?: boolean | null;
              /** @description whether the job is cancelled */
              is_cancelled?: boolean | null;
              /** @description The user UID who requested the cancellation */
              user_uid?: string | null;
              /**
               * Format: date-time
               * @description The time of cancellation
               */
              cancel_time?: string | null;
            };
            /** @description Progress details for each step of the job */
            steps?: ({
                /** @description Status message */
                message?: string | null;
                /** @description The index of the step within the job */
                index?: number;
                /**
                 * Format: float
                 * @description Step progress from 0 to 100
                 */
                progress?: number;
                /** @description Step state */
                state?: string;
                /** @description Step name */
                step_name?: string;
                /**
                 * Format: float
                 * @description Step duration in seconds
                 */
                duration?: number | null;
                /** @description Step warning message */
                warning?: string | null;
              })[];
            /**
             * Format: date-time
             * @description Start time of the job
             */
            start_time?: string | null;
            /**
             * Format: date-time
             * @description End time of the job
             */
            end_time?: string | null;
            /** @description The state of the job */
            state?: string;
            /**
             * @description Type of the job.
             * @enum {string}
             */
            type?: "prepare_import_to_new_project";
            /**
             * Metadata of `prepare_import_to_new_project` job
             * @description Supported project types and warnings
             */
            metadata?: {
              /** @description ID of the uploaded dataset file to be imported */
              file_id?: string;
              /** @description Warnings to import dataset to specific domain */
              warnings?: ({
                  /**
                   * @description Type of the warning
                   * @enum {string}
                   */
                  type: "error" | "warning";
                  /**
                   * @description Name of the warning
                   * @example Missing expected annotation type for classification domain
                   */
                  name: string;
                  /** @description Detailed description of the warning */
                  description: string;
                  /** @description How to handle the warning */
                  resolve_strategy?: string;
                  /**
                   * Format: int32
                   * @description Number of affected images
                   */
                  affected_images?: number;
                })[];
              /** @description Supported project types and corresponding labels */
              supported_project_types?: ({
                  /**
                   * @description Project type name
                   * @enum {string}
                   */
                  project_type: "classification" | "classification_hierarchical" | "detection" | "segmentation" | "instance_segmentation" | "anomaly" | "detection_oriented" | "detection_classification" | "detection_segmentation" | "keypoint_detection";
                  pipeline: {
                    connections: {
                        /** @description Source task name */
                        from: string;
                        /** @description Target task name */
                        to: string;
                      }[];
                    tasks: ({
                        /** @description Task name */
                        title: string;
                        /**
                         * @description OTX Task type name in lowercase
                         * @enum {string}
                         */
                        task_type: "dataset" | "classification" | "segmentation" | "detection" | "crop" | "instance_segmentation" | "keypoint_detection" | "anomaly" | "rotated_detection";
                        labels: {
                            /** @description Label name */
                            name: string;
                            /** @description Label group name */
                            group?: string;
                            /** @description Label parent name */
                            parent?: string;
                          }[];
                      })[];
                  };
                })[];
            };
          }) | ({
            /** @description Name of the job */
            name?: string;
            /** @description The time at which the job was created */
            creation_time?: string;
            /**
             * @description Mongo ID of the object
             * @example 60d31793d5f1fb7e6e3c1a4c
             */
            id?: string;
            /** @description Identifier of the user who submitted the job */
            author?: string;
            /** @description Information detailing the cancellation status of the job */
            cancellation_info?: {
              /** @description whether the job can be cancelled after startup */
              cancellable?: boolean | null;
              /** @description whether the job is cancelled */
              is_cancelled?: boolean | null;
              /** @description The user UID who requested the cancellation */
              user_uid?: string | null;
              /**
               * Format: date-time
               * @description The time of cancellation
               */
              cancel_time?: string | null;
            };
            /** @description Progress details for each step of the job */
            steps?: ({
                /** @description Status message */
                message?: string | null;
                /** @description The index of the step within the job */
                index?: number;
                /**
                 * Format: float
                 * @description Step progress from 0 to 100
                 */
                progress?: number;
                /** @description Step state */
                state?: string;
                /** @description Step name */
                step_name?: string;
                /**
                 * Format: float
                 * @description Step duration in seconds
                 */
                duration?: number | null;
                /** @description Step warning message */
                warning?: string | null;
              })[];
            /**
             * Format: date-time
             * @description Start time of the job
             */
            start_time?: string | null;
            /**
             * Format: date-time
             * @description End time of the job
             */
            end_time?: string | null;
            /** @description The state of the job */
            state?: string;
            /**
             * @description Type of the job.
             * @enum {string}
             */
            type?: "perform_import_to_new_project";
            /**
             * Metadata of `perform_import_to_new_project` job
             * @description Created project ID
             */
            metadata?: {
              /** @description ID of the uploaded dataset file to be imported */
              file_id?: string;
              /** @description Information about the project to create */
              project?: {
                id?: string;
                name?: string;
              };
              /**
               * @description Mongo ID of the object
               * @example 60d31793d5f1fb7e6e3c1a4c
               */
              project_id?: string;
            };
          }) | ({
            /** @description Name of the job */
            name?: string;
            /** @description The time at which the job was created */
            creation_time?: string;
            /**
             * @description Mongo ID of the object
             * @example 60d31793d5f1fb7e6e3c1a4c
             */
            id?: string;
            /** @description Identifier of the user who submitted the job */
            author?: string;
            /** @description Information detailing the cancellation status of the job */
            cancellation_info?: {
              /** @description whether the job can be cancelled after startup */
              cancellable?: boolean | null;
              /** @description whether the job is cancelled */
              is_cancelled?: boolean | null;
              /** @description The user UID who requested the cancellation */
              user_uid?: string | null;
              /**
               * Format: date-time
               * @description The time of cancellation
               */
              cancel_time?: string | null;
            };
            /** @description Progress details for each step of the job */
            steps?: ({
                /** @description Status message */
                message?: string | null;
                /** @description The index of the step within the job */
                index?: number;
                /**
                 * Format: float
                 * @description Step progress from 0 to 100
                 */
                progress?: number;
                /** @description Step state */
                state?: string;
                /** @description Step name */
                step_name?: string;
                /**
                 * Format: float
                 * @description Step duration in seconds
                 */
                duration?: number | null;
                /** @description Step warning message */
                warning?: string | null;
              })[];
            /**
             * Format: date-time
             * @description Start time of the job
             */
            start_time?: string | null;
            /**
             * Format: date-time
             * @description End time of the job
             */
            end_time?: string | null;
            /** @description The state of the job */
            state?: string;
            /**
             * @description Type of the job.
             * @enum {string}
             */
            type?: "prepare_import_to_existing_project";
            /**
             * Metadata of `prepare_import_to_existing_project` job
             * @description Labels in the dataset and warnings
             */
            metadata?: {
              /** @description ID of the uploaded dataset file to be imported */
              file_id?: string;
              /** @description Information about the project where the dataset is imported */
              project?: {
                /** @description ID of the project */
                id?: string;
                /** @description Name of the project */
                name?: string;
                /**
                 * @description Type name of the project
                 * @enum {string}
                 */
                type?: "classification" | "classification_hierarchical" | "detection" | "segmentation" | "instance_segmentation" | "anomaly" | "detection_oriented" | "detection_classification" | "detection_segmentation" | "keypoint_detection";
              };
              /** @description Warnings to import dataset to specific domain */
              warnings?: ({
                  /**
                   * @description Type of the warning
                   * @enum {string}
                   */
                  type: "error" | "warning";
                  /**
                   * @description Name of the warning
                   * @example Missing expected annotation type for classification domain
                   */
                  name: string;
                  /** @description Detailed description of the warning */
                  description: string;
                  /** @description How to handle the warning */
                  resolve_strategy?: string;
                  /**
                   * Format: int32
                   * @description Number of affected images
                   */
                  affected_images?: number;
                })[];
              /** @description Label names in the dataset */
              labels?: string[];
            };
          }) | ({
            /** @description Name of the job */
            name?: string;
            /** @description The time at which the job was created */
            creation_time?: string;
            /**
             * @description Mongo ID of the object
             * @example 60d31793d5f1fb7e6e3c1a4c
             */
            id?: string;
            /** @description Identifier of the user who submitted the job */
            author?: string;
            /** @description Information detailing the cancellation status of the job */
            cancellation_info?: {
              /** @description whether the job can be cancelled after startup */
              cancellable?: boolean | null;
              /** @description whether the job is cancelled */
              is_cancelled?: boolean | null;
              /** @description The user UID who requested the cancellation */
              user_uid?: string | null;
              /**
               * Format: date-time
               * @description The time of cancellation
               */
              cancel_time?: string | null;
            };
            /** @description Progress details for each step of the job */
            steps?: ({
                /** @description Status message */
                message?: string | null;
                /** @description The index of the step within the job */
                index?: number;
                /**
                 * Format: float
                 * @description Step progress from 0 to 100
                 */
                progress?: number;
                /** @description Step state */
                state?: string;
                /** @description Step name */
                step_name?: string;
                /**
                 * Format: float
                 * @description Step duration in seconds
                 */
                duration?: number | null;
                /** @description Step warning message */
                warning?: string | null;
              })[];
            /**
             * Format: date-time
             * @description Start time of the job
             */
            start_time?: string | null;
            /**
             * Format: date-time
             * @description End time of the job
             */
            end_time?: string | null;
            /** @description The state of the job */
            state?: string;
            /**
             * @description Type of the job.
             * @enum {string}
             */
            type?: "perform_import_to_existing_project";
            /**
             * Metadata of `perform_import_to_existing_project` job
             * @description Imported dataset information
             */
            metadata?: {
              /** @description ID of the uploaded dataset file to be imported */
              file_id?: string;
              /** @description Information about the project where the dataset is imported */
              project?: {
                /** @description ID of the project */
                id?: string;
                /** @description Name of the project */
                name?: string;
                /**
                 * @description Type name of the project
                 * @enum {string}
                 */
                type?: "classification" | "classification_hierarchical" | "detection" | "segmentation" | "instance_segmentation" | "anomaly" | "detection_oriented" | "detection_classification" | "detection_segmentation" | "keypoint_detection";
              };
              /** @description The dataset information for importing the uploaded dataset file */
              dataset?: {
                /**
                 * @description Mongo ID of the object
                 * @example 60d31793d5f1fb7e6e3c1a4c
                 */
                id?: string;
                /** @description Name of the dataset storage */
                name?: string;
                /** @description Whether the dataset will be used for training or not */
                use_for_training?: boolean;
                /**
                 * @description The time at which the dataset was created
                 * @example 2024-03-05T06:34:32.332000+00:00
                 */
                creation_time?: string;
              };
            };
          }) | ({
            /** @description Name of the job */
            name?: string;
            /** @description The time at which the job was created */
            creation_time?: string;
            /**
             * @description Mongo ID of the object
             * @example 60d31793d5f1fb7e6e3c1a4c
             */
            id?: string;
            /** @description Identifier of the user who submitted the job */
            author?: string;
            /** @description Information detailing the cancellation status of the job */
            cancellation_info?: {
              /** @description whether the job can be cancelled after startup */
              cancellable?: boolean | null;
              /** @description whether the job is cancelled */
              is_cancelled?: boolean | null;
              /** @description The user UID who requested the cancellation */
              user_uid?: string | null;
              /**
               * Format: date-time
               * @description The time of cancellation
               */
              cancel_time?: string | null;
            };
            /** @description Progress details for each step of the job */
            steps?: ({
                /** @description Status message */
                message?: string | null;
                /** @description The index of the step within the job */
                index?: number;
                /**
                 * Format: float
                 * @description Step progress from 0 to 100
                 */
                progress?: number;
                /** @description Step state */
                state?: string;
                /** @description Step name */
                step_name?: string;
                /**
                 * Format: float
                 * @description Step duration in seconds
                 */
                duration?: number | null;
                /** @description Step warning message */
                warning?: string | null;
              })[];
            /**
             * Format: date-time
             * @description Start time of the job
             */
            start_time?: string | null;
            /**
             * Format: date-time
             * @description End time of the job
             */
            end_time?: string | null;
            /** @description The state of the job */
            state?: string;
            /**
             * @description Type of the job.
             * @enum {string}
             */
            type?: "export_project";
            /**
             * Metadata of `export_project` job
             * @description Information about the project export operation
             */
            metadata?: {
              /** @description Information about the project being export */
              project?: {
                /** @description ID of the project */
                id?: string;
                /** @description Name of the project */
                name?: string;
              };
              /** @description URL to download the exported project archive */
              download_url?: string;
            };
          }) | ({
            /** @description Name of the job */
            name?: string;
            /** @description The time at which the job was created */
            creation_time?: string;
            /**
             * @description Mongo ID of the object
             * @example 60d31793d5f1fb7e6e3c1a4c
             */
            id?: string;
            /** @description Identifier of the user who submitted the job */
            author?: string;
            /** @description Information detailing the cancellation status of the job */
            cancellation_info?: {
              /** @description whether the job can be cancelled after startup */
              cancellable?: boolean | null;
              /** @description whether the job is cancelled */
              is_cancelled?: boolean | null;
              /** @description The user UID who requested the cancellation */
              user_uid?: string | null;
              /**
               * Format: date-time
               * @description The time of cancellation
               */
              cancel_time?: string | null;
            };
            /** @description Progress details for each step of the job */
            steps?: ({
                /** @description Status message */
                message?: string | null;
                /** @description The index of the step within the job */
                index?: number;
                /**
                 * Format: float
                 * @description Step progress from 0 to 100
                 */
                progress?: number;
                /** @description Step state */
                state?: string;
                /** @description Step name */
                step_name?: string;
                /**
                 * Format: float
                 * @description Step duration in seconds
                 */
                duration?: number | null;
                /** @description Step warning message */
                warning?: string | null;
              })[];
            /**
             * Format: date-time
             * @description Start time of the job
             */
            start_time?: string | null;
            /**
             * Format: date-time
             * @description End time of the job
             */
            end_time?: string | null;
            /** @description The state of the job */
            state?: string;
            /**
             * @description Type of the job.
             * @enum {string}
             */
            type?: "import_project";
            /**
             * Metadata of `import_project` job
             * @description Information about the project import operation
             */
            metadata?: {
              /** @description Information about the imported project */
              project?: {
                /** @description ID of the project */
                id?: string;
                /** @description Name of the project */
                name?: string;
              };
              /**
               * Import project parameters
               * @description Parameters of the import request
               */
              parameters?: {
                /** @description ID of the uploaded project zip archive */
                file_id?: string;
              };
            };
          });
        };
      };
      /** @description Object not found. See the examples for details. */
      404: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 400 | 404 | 405 | 409 | 412 | 413 | 415 | 422 | 423 | 500 | 501 | 503;
            /** @description Message from server */
            message: string;
            /** @description Error code from server */
            error_code: string;
          };
        };
      };
    };
  };
  /**
   * Delete a job
   * @description Mark a job as cancelled with a deletion flag
   */
  DeleteJob: {
    parameters: {
      path: {
        /** @description The ID of the organization. */
        organization_id: string;
        /** @description The ID of the workspace. */
        workspace_id: string;
        /** @description The ID of the job of interest */
        job_id: string;
      };
    };
    responses: {
      /** @description Job marked as cancelled with a deletion flag */
      202: {
        content: {
          "application/json": unknown;
        };
      };
      /** @description Object not found. See the examples for details. */
      404: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 400 | 404 | 405 | 409 | 412 | 413 | 415 | 422 | 423 | 500 | 501 | 503;
            /** @description Message from server */
            message: string;
            /** @description Error code from server */
            error_code: string;
          };
        };
      };
    };
  };
  /** Cancel a job */
  CancelJob: {
    parameters: {
      path: {
        /** @description The ID of the organization. */
        organization_id: string;
        /** @description The ID of the workspace. */
        workspace_id: string;
        /** @description The ID of the job of interest */
        job_id: string;
      };
    };
    responses: {
      /** @description Job marked as cancelled */
      202: {
        content: {
          "application/json": unknown;
        };
      };
      /** @description Object not found. See the examples for details. */
      404: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 400 | 404 | 405 | 409 | 412 | 413 | 415 | 422 | 423 | 500 | 501 | 503;
            /** @description Message from server */
            message: string;
            /** @description Error code from server */
            error_code: string;
          };
        };
      };
      /** @description Job cannot be cancelled */
      412: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 400 | 404 | 405 | 409 | 412 | 413 | 415 | 422 | 423 | 500 | 501 | 503;
            /** @description Message from server */
            message: string;
            /** @description Error code from server */
            error_code: string;
          };
        };
      };
    };
  };
  /**
   * Get server status
   * @description Get the server status. Contains running jobs count, free disk space and used disk space in bytes.
   */
  GetServerStatus: {
    responses: {
      /** @description The server status */
      200: {
        content: {
          "application/json": {
            /** @description Number of running jobs */
            n_running_jobs?: number;
            /** @description Displays a warning message if the server is running low on memory */
            warning?: string;
            storage?: {
              /** @description Total disk space in bytes */
              total_space?: number;
              /** @description Total disk space in bytes */
              free_space?: number;
            };
          };
        };
      };
    };
  };
  /**
   * Get project status
   * @description Get the status of a project. Includes project score, number of required annotations and current state, for the project and on a per-task basis.
   */
  GetProjectStatus: {
    parameters: {
      path: {
        /** @description The ID of the organization. */
        organization_id: string;
        /** @description The ID of the workspace. */
        workspace_id: string;
        /** @description The ID of the project. */
        project_id: string;
      };
    };
    responses: {
      /** @description The current status of the project */
      200: {
        content: {
          "application/json": {
            /** @description Boolean that indicates whether a model is currently training */
            is_training?: boolean;
            /** @description Required number of annotations before training is allowed */
            n_required_annotations?: number;
            /** @description Number of new annotations that have been added after the last training round */
            n_new_annotations?: number;
            /** @description Number of running jobs across whole system */
            n_running_jobs?: number;
            /** @description Number of running jobs for given project */
            n_running_jobs_project?: number;
            project_performance?: {
              /**
               * Format: float
               * @description Average score of task scores of a project, null if no model is trained.
               */
              score?: number | null;
              task_performances?: ({
                  /**
                   * @description Mongo ID of the object
                   * @example 60d31793d5f1fb7e6e3c1a4c
                   */
                  task_id: string;
                  /** @description Model score for the task, null if no model is trained. */
                  score: null | {
                    /**
                     * Format: float
                     * @description Value of the score.
                     */
                    value: number;
                    /** @description Name of the algorithm that is used to calculate the metric value, eg dice average, f-measure, etc. */
                    metric_type: string;
                  };
                })[];
            };
            status?: {
              /**
               * Format: float
               * @description Training progress, if a model is being trained
               */
              progress?: number;
            };
            /** @description Array that contains the status of every task */
            tasks?: {
                /**
                 * @description Mongo ID of the object
                 * @example 60d31793d5f1fb7e6e3c1a4c
                 */
                id?: string;
                /** @description Boolean that indicates whether the task is currently training */
                is_training?: boolean;
                /** @description Number of new annotations for the task that have been added after the last training round */
                n_new_annotations?: number;
                /** @description Boolean indicating whether the project is ready to be manually trained. */
                ready_to_train?: boolean;
                required_annotations?: {
                  /** @description Required annotations per label */
                  details?: {
                      /**
                       * @description Mongo ID of the object
                       * @example 60d31793d5f1fb7e6e3c1a4c
                       */
                      id?: string;
                      /** @description Name of the label */
                      label_name?: string;
                      /** @description Color of the label */
                      label_color?: string;
                      /** @description Number of required annotations for this label */
                      value?: number;
                    }[];
                  /** @description Total number of required annotations */
                  value?: number;
                };
                status?: {
                  /**
                   * Format: float
                   * @description Current progress of the task
                   */
                  progress?: number;
                };
                /** @description Title of the task */
                title?: string;
              }[];
          };
        };
      };
      /** @description Object not found. See the examples for details. */
      404: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 400 | 404 | 405 | 409 | 412 | 413 | 415 | 422 | 423 | 500 | 501 | 503;
            /** @description Message from server */
            message: string;
            /** @description Error code from server */
            error_code: string;
          };
        };
      };
    };
  };
  /**
   * Get incremental learning status
   * @description Get the incremental learning status of a project. This contains information on the number of annotations that need to be added before training will be started, on a per-label and per-task basis.
   */
  GetIncrementalLearningStatus: {
    parameters: {
      path: {
        /** @description The ID of the organization. */
        organization_id: string;
        /** @description The ID of the workspace. */
        workspace_id: string;
        /** @description The ID of the project. */
        project_id: string;
      };
    };
    responses: {
      /** @description The current incremental learning status of the project */
      200: {
        content: {
          "application/json": {
            /** @description Required number of annotations before training is allowed */
            n_required_annotations?: number;
            /** @description Number of new annotations that have been added after the last training round */
            n_new_annotations?: number;
            /** @description Array that contains the status of every task */
            status_per_task?: {
                /**
                 * @description Mongo ID of the object
                 * @example 60d31793d5f1fb7e6e3c1a4c
                 */
                task_id?: string;
                /** @description Number of new annotations for the task that have been added after the last training round */
                n_new_annotations?: number;
                /** @description Boolean indicating whether the project is ready to be manually trained. */
                ready_to_train?: boolean;
                /** @description Total number of annotations required for this task before training can be started */
                required_total?: number;
                /** @description Required annotations per label */
                required_per_label?: {
                    /**
                     * @description Mongo ID of the object
                     * @example 60d31793d5f1fb7e6e3c1a4c
                     */
                    id?: string;
                    /** @description Name of the label */
                    label_name?: string;
                    /** @description Color of the label */
                    label_color?: string;
                    /** @description Number of required annotations for this label */
                    value?: number;
                  }[];
              }[];
          };
        };
      };
      /** @description Object not found. See the examples for details. */
      404: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 400 | 404 | 405 | 409 | 412 | 413 | 415 | 422 | 423 | 500 | 501 | 503;
            /** @description Message from server */
            message: string;
            /** @description Error code from server */
            error_code: string;
          };
        };
      };
    };
  };
  /**
   * Get server status for organization
   * @description Get the server status for a given organization. Contains running jobs count, free disk space and used disk space in bytes.
   */
  GetOrganizationStatus: {
    parameters: {
      path: {
        /** @description The ID of the organization. */
        organization_id: string;
      };
    };
    responses: {
      /** @description The server status for organization */
      200: {
        content: {
          "application/json": {
            /** @description Number of running jobs */
            n_running_jobs?: number;
            /** @description Displays a warning message if the server is running low on memory */
            warning?: string;
            storage?: {
              /** @description Total disk space in bytes */
              total_space?: number;
              /** @description Total disk space in bytes */
              free_space?: number;
            };
          };
        };
      };
      /** @description Object not found. See the examples for details. */
      404: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 400 | 404 | 405 | 409 | 412 | 413 | 415 | 422 | 423 | 500 | 501 | 503;
            /** @description Message from server */
            message: string;
            /** @description Error code from server */
            error_code: string;
          };
        };
      };
    };
  };
  /**
   * Get the current configuration for all components in the project.
   * @description This endpoint gets the configuration for all components in the project, as well as the current algorithms used in the task chain. The configuration is subdivided into components. Examples of configuration components are the deep learning parameters, postprocessing parameters or subset-related parameters. Some components are further divided into parameter groups.
   */
  GetFullConfiguration: {
    parameters: {
      path: {
        /** @description The ID of the organization. */
        organization_id: string;
        /** @description The ID of the workspace. */
        workspace_id: string;
        /** @description The ID of the project. */
        project_id: string;
      };
    };
    responses: {
      /** @description Get full configuration response */
      200: {
        content: {
          "application/json": {
            /** @description Array of configurable parameter objects for the different global (i.e. project-wide) components in the project */
            global?: ({
                /**
                 * @description Mongo ID of the object
                 * @example 60d31793d5f1fb7e6e3c1a4c
                 */
                id?: string;
                /**
                 * @description Type of the configurable parameters. For component parameters the type is always 'CONFIGURABLE_PARAMETERS'.
                 * @enum {string}
                 */
                type?: "CONFIGURABLE_PARAMETERS" | "PARAMETER_GROUP";
                entity_identifier?: OneOf<[{
                  workspace_id?: string;
                  /**
                   * @description Mongo ID of the object
                   * @example 60d31793d5f1fb7e6e3c1a4c
                   */
                  project_id?: string;
                  /**
                   * @description Mongo ID of the object
                   * @example 60d31793d5f1fb7e6e3c1a4c
                   */
                  task_id?: string;
                  /** @description Describes the component to which the configurable parameters apply */
                  component?: string;
                  /**
                   * @description Describes the type of the configuration. Set to COMPONENT_PARAMETERS for a configuration that relates to a component.
                   * @enum {string}
                   */
                  type?: "COMPONENT_PARAMETERS";
                }, {
                  workspace_id?: string;
                  /**
                   * @description Mongo ID of the object
                   * @example 60d31793d5f1fb7e6e3c1a4c
                   */
                  model_storage_id?: string;
                  /**
                   * @description Describes the type of the configurable parameters. For hyper parameters, type is set to HYPER_PARAMETERS.
                   * @enum {string}
                   */
                  type?: "HYPER_PARAMETERS";
                }, {
                  workspace_id?: string;
                  /**
                   * @description Mongo ID of the object
                   * @example 60d31793d5f1fb7e6e3c1a4c
                   */
                  model_storage_id?: string;
                  /** @description Name of the hyper parameter group */
                  group_name?: string;
                  /**
                   * @description Describes the type of the component. For hyper parameter groups, type is always set to HYPER_PARAMETER_GROUP
                   * @enum {string}
                   */
                  type?: "HYPER_PARAMETER_GROUP";
                }]>;
                /**
                 * @description Name of the configuration
                 * @example Subset splitting
                 */
                header?: string;
                /**
                 * @description Description of the configuration, indicating which part of the system it controls.
                 * @example These parameters control the splitting of the dataset into training, validation and test set.
                 */
                description?: string;
                groups?: ({
                    /**
                     * @description Defines the parameter group
                     * @example Learning Parameters
                     */
                    header?: string;
                    /**
                     * @description Description of the parameter group
                     * @example Configuration to control training behaviour
                     */
                    description?: string;
                    /** @enum {string} */
                    type?: "PARAMETER_GROUP";
                    /** @description Name of the parameter group */
                    name?: string;
                    parameters?: ({
                        /** @description User friendly title for the parameter. */
                        header?: string;
                        /** @description User friendly description for what the parameter does. */
                        description?: string;
                        /** @description Warning message (if any) that explains the user to use caution when changing this parameter, and why. */
                        warning?: unknown;
                        /** @description Value that this parameter currently takes. */
                        value?: string | number | boolean;
                        /** @description Default value that should be set for this parameter. */
                        default_value?: string | number | boolean;
                        /** @description Name to identify the parameter by in the system. */
                        name?: string;
                        /**
                         * @description Describes the template type of the parameter. 'selectable' is used for parameters with a fixed set of possible values. 'input' is used for parameters that allow free input, possibly restricted to a certain range.
                         * @enum {string}
                         */
                        template_type?: "selectable" | "input";
                        /**
                         * @description Describes the type of parameter. Parameters can be integers, floats, boolean or string.
                         * @enum {string}
                         */
                        data_type?: "float" | "integer" | "boolean" | "string";
                        /** @description List of values that this parameter can take. Only used for selectable string and selectable float parameters */
                        options?: (number | string)[];
                        /**
                         * Format: float
                         * @description Minimum value that can be set for this parameter. Only used for numeric parameters.
                         */
                        min_value?: number;
                        /**
                         * Format: float
                         * @description Minimum value that can be set for this parameter. Only used for numeric parameters.
                         */
                        max_value?: number;
                        /** @description Not implemented at this moment */
                        ui_rules?: Record<string, never>;
                        /** @description Not implemented at this moment. */
                        editable?: boolean;
                      })[];
                  })[];
                /** @description Array of configurable parameters */
                parameters?: ({
                    /** @description User friendly title for the configurable boolean. */
                    header?: string;
                    /** @description User friendly description for what the boolean does. */
                    description?: string;
                    /** @description Warning message (if any) that explains the user to use caution when changing this parameter, and why. */
                    warning?: unknown;
                    /** @description Value that this boolean currently takes. */
                    value?: boolean;
                    /** @description Default value that should be set for this boolean. */
                    default_value?: boolean;
                    /** @description Name to identify the configurable boolean by in the system. */
                    name?: string;
                    /**
                     * @description Describes the template type of the parameter. 'selectable' is used for parameters with a fixed set of possible values. 'input' is used for parameters that allow free input, possibly restricted to a certain range. Template_type is always 'input' for a configurable boolean.
                     * @enum {string}
                     */
                    template_type?: "input";
                    /**
                     * @description Describes the type of parameter. Parameters can be integers, floats, boolean or string. Data_type is always 'boolean' for a configurable boolean.
                     * @enum {string}
                     */
                    data_type?: "boolean";
                    /** @description Not implemented at this moment */
                    ui_rules?: Record<string, never>;
                    /** @description Not implemented at this moment. */
                    editable?: boolean;
                  } | {
                    /** @description User friendly title for the float. */
                    header?: string;
                    /** @description User friendly description for what the float does. */
                    description?: string;
                    /** @description Warning message (if any) that explains the user to use caution when changing this parameter, and why. */
                    warning?: unknown;
                    /**
                     * Format: float
                     * @description Value that this configurable float currently takes.
                     */
                    value?: number;
                    /**
                     * Format: float
                     * @description Default value that should be set for this float.
                     */
                    default_value?: number;
                    /** @description Name to identify the configurable float by in the system. */
                    name?: string;
                    /**
                     * @description Describes the template type of the parameter. 'selectable' is used for parameters with a fixed set of possible values. 'input' is used for parameters that allow free input, possibly restricted to a certain range. Template_type is always 'input' for a configurable float.
                     * @enum {string}
                     */
                    template_type?: "input";
                    /**
                     * @description Describes the type of parameter. Parameters can be integers, floats, boolean or string. Data_type is always 'float' for a configurable float.
                     * @enum {string}
                     */
                    data_type?: "float";
                    /**
                     * Format: float
                     * @description Minimum value that can be set for this parameter.
                     */
                    min_value?: number;
                    /**
                     * Format: float
                     * @description Minimum value that can be set for this parameter.
                     */
                    max_value?: number;
                    /** @description Not implemented at this moment */
                    ui_rules?: Record<string, never>;
                    /** @description Not implemented at this moment. */
                    editable?: boolean;
                  } | {
                    /** @description User friendly title for the integer. */
                    header?: string;
                    /** @description User friendly description for what the integer does. */
                    description?: string;
                    /** @description Warning message (if any) that explains the user to use caution when changing this parameter, and why. */
                    warning?: unknown;
                    /** @description Value that this configurable integer currently takes. */
                    value?: number;
                    /** @description Default value that should be set for this integer. */
                    default_value?: number;
                    /** @description Name to identify the configurable integer by in the system. */
                    name?: string;
                    /**
                     * @description Describes the template type of the parameter. 'selectable' is used for parameters with a fixed set of possible values. 'input' is used for parameters that allow free input, possibly restricted to a certain range. Template_type is always 'input' for a configurable integer.
                     * @enum {string}
                     */
                    template_type?: "input";
                    /**
                     * @description Describes the type of parameter. Parameters can be integers, floats, boolean or string. Data_type is always 'integer' for a configurable integer.
                     * @enum {string}
                     */
                    data_type?: "integer";
                    /** @description Minimum value that can be set for this parameter. */
                    min_value?: number;
                    /** @description Minimum value that can be set for this parameter. */
                    max_value?: number;
                    /** @description Not implemented at this moment */
                    ui_rules?: Record<string, never>;
                    /** @description Not implemented at this moment. */
                    editable?: boolean;
                  } | {
                    /** @description User friendly title for the selectable string. */
                    header?: string;
                    /** @description User friendly description for what the selectable string parameter does. */
                    description?: string;
                    /** @description Warning message (if any) that explains the user to use caution when changing this parameter, and why. */
                    warning?: unknown;
                    /** @description Value that this selectable string currently takes. */
                    value?: string;
                    /** @description Default value that should be set for this selectable string. */
                    default_value?: string;
                    /** @description Name to identify the selectable string parameter by in the system. */
                    name?: string;
                    /**
                     * @description Describes the template type of the parameter. 'selectable' is used for parameters with a fixed set of possible values. 'input' is used for parameters that allow free input, possibly restricted to a certain range. Template_type is always 'selectable' for a selectable string parameter.
                     * @enum {string}
                     */
                    template_type?: "selectable";
                    /**
                     * @description Describes the type of parameter. Parameters can be integers, floats, boolean or string. Data_type is always 'string' for a selectable string parameter.
                     * @enum {string}
                     */
                    data_type?: "string";
                    /** @description List of values that this selectable string can take. */
                    options?: string[];
                    /** @description Not implemented at this moment */
                    ui_rules?: Record<string, never>;
                    /** @description Not implemented at this moment. */
                    editable?: boolean;
                  } | {
                    /** @description User friendly title for the selectable. */
                    header?: string;
                    /** @description User friendly description for what the selectable parameter does. */
                    description?: string;
                    /** @description Warning message (if any) that explains the user to use caution when changing this parameter, and why. */
                    warning?: unknown;
                    /** @description Value that this selectable currently takes. */
                    value?: string;
                    /** @description Default value that should be set for this selectable. */
                    default_value?: string;
                    /** @description Name to identify the selectable parameter by in the system. */
                    name?: string;
                    /**
                     * @description Describes the template type of the parameter. 'selectable' is used for parameters with a fixed set of possible values. 'input' is used for parameters that allow free input, possibly restricted to a certain range. Template_type is always 'selectable' for a selectable parameter.
                     * @enum {string}
                     */
                    template_type?: "selectable";
                    /**
                     * @description Describes the type of parameter. Parameters can be integers, floats, boolean or string. Data_type is always 'float' for a selectable float.
                     * @enum {string}
                     */
                    data_type?: "float";
                    /** @description List of values that this float selectable can take. */
                    options?: number[];
                    /** @description Not implemented at this moment */
                    ui_rules?: Record<string, never>;
                    /** @description Not implemented at this moment. */
                    editable?: boolean;
                  })[];
              })[];
            /** @description Array of task configurations */
            task_chain?: ({
                /** @description Array of configurable parameter objects for the different components in the task, as well as the hyper parameters for the current algorithm in the task */
                components?: (({
                    /** @description Name of the hyper parameter group */
                    name?: string;
                    /**
                     * @description ID of the hyper parameter group. The first 24 characters refer to the ID of the underlying HyperParameter object. This is followed by a dash ('-') and the group number (0 to 99) of this particular hyper parameter group.
                     * @example 60d31793d5f1fb7e6e3c1a4c-1
                     */
                    id?: string;
                    /**
                     * @description Type of the configurable parameters. For a hyper parameter group the type is always 'PARAMETER_GROUP'.
                     * @enum {string}
                     */
                    type?: "CONFIGURABLE_PARAMETERS" | "PARAMETER_GROUP";
                    entity_identifier?: OneOf<[{
                      workspace_id?: string;
                      /**
                       * @description Mongo ID of the object
                       * @example 60d31793d5f1fb7e6e3c1a4c
                       */
                      project_id?: string;
                      /**
                       * @description Mongo ID of the object
                       * @example 60d31793d5f1fb7e6e3c1a4c
                       */
                      task_id?: string;
                      /** @description Describes the component to which the configurable parameters apply */
                      component?: string;
                      /**
                       * @description Describes the type of the configuration. Set to COMPONENT_PARAMETERS for a configuration that relates to a component.
                       * @enum {string}
                       */
                      type?: "COMPONENT_PARAMETERS";
                    }, {
                      workspace_id?: string;
                      /**
                       * @description Mongo ID of the object
                       * @example 60d31793d5f1fb7e6e3c1a4c
                       */
                      model_storage_id?: string;
                      /**
                       * @description Describes the type of the configurable parameters. For hyper parameters, type is set to HYPER_PARAMETERS.
                       * @enum {string}
                       */
                      type?: "HYPER_PARAMETERS";
                    }, {
                      workspace_id?: string;
                      /**
                       * @description Mongo ID of the object
                       * @example 60d31793d5f1fb7e6e3c1a4c
                       */
                      model_storage_id?: string;
                      /** @description Name of the hyper parameter group */
                      group_name?: string;
                      /**
                       * @description Describes the type of the component. For hyper parameter groups, type is always set to HYPER_PARAMETER_GROUP
                       * @enum {string}
                       */
                      type?: "HYPER_PARAMETER_GROUP";
                    }]>;
                    /**
                     * @description The name of the hyper parameter group
                     * @example Learning parameters
                     */
                    header?: string;
                    /**
                     * @description Description of the hyper parameter group.
                     * @example A set of parameters that control the training process.
                     */
                    description?: string;
                    groups?: ({
                        /**
                         * @description Defines the parameter group
                         * @example Learning Parameters
                         */
                        header?: string;
                        /**
                         * @description Description of the parameter group
                         * @example Configuration to control training behaviour
                         */
                        description?: string;
                        /** @enum {string} */
                        type?: "PARAMETER_GROUP";
                        /** @description Name of the parameter group */
                        name?: string;
                        parameters?: ({
                            /** @description User friendly title for the parameter. */
                            header?: string;
                            /** @description User friendly description for what the parameter does. */
                            description?: string;
                            /** @description Warning message (if any) that explains the user to use caution when changing this parameter, and why. */
                            warning?: unknown;
                            /** @description Value that this parameter currently takes. */
                            value?: string | number | boolean;
                            /** @description Default value that should be set for this parameter. */
                            default_value?: string | number | boolean;
                            /** @description Name to identify the parameter by in the system. */
                            name?: string;
                            /**
                             * @description Describes the template type of the parameter. 'selectable' is used for parameters with a fixed set of possible values. 'input' is used for parameters that allow free input, possibly restricted to a certain range.
                             * @enum {string}
                             */
                            template_type?: "selectable" | "input";
                            /**
                             * @description Describes the type of parameter. Parameters can be integers, floats, boolean or string.
                             * @enum {string}
                             */
                            data_type?: "float" | "integer" | "boolean" | "string";
                            /** @description List of values that this parameter can take. Only used for selectable string and selectable float parameters */
                            options?: (number | string)[];
                            /**
                             * Format: float
                             * @description Minimum value that can be set for this parameter. Only used for numeric parameters.
                             */
                            min_value?: number;
                            /**
                             * Format: float
                             * @description Minimum value that can be set for this parameter. Only used for numeric parameters.
                             */
                            max_value?: number;
                            /** @description Not implemented at this moment */
                            ui_rules?: Record<string, never>;
                            /** @description Not implemented at this moment. */
                            editable?: boolean;
                          })[];
                      })[];
                    /** @description Array of configurable parameters */
                    parameters?: ({
                        /** @description User friendly title for the configurable boolean. */
                        header?: string;
                        /** @description User friendly description for what the boolean does. */
                        description?: string;
                        /** @description Warning message (if any) that explains the user to use caution when changing this parameter, and why. */
                        warning?: unknown;
                        /** @description Value that this boolean currently takes. */
                        value?: boolean;
                        /** @description Default value that should be set for this boolean. */
                        default_value?: boolean;
                        /** @description Name to identify the configurable boolean by in the system. */
                        name?: string;
                        /**
                         * @description Describes the template type of the parameter. 'selectable' is used for parameters with a fixed set of possible values. 'input' is used for parameters that allow free input, possibly restricted to a certain range. Template_type is always 'input' for a configurable boolean.
                         * @enum {string}
                         */
                        template_type?: "input";
                        /**
                         * @description Describes the type of parameter. Parameters can be integers, floats, boolean or string. Data_type is always 'boolean' for a configurable boolean.
                         * @enum {string}
                         */
                        data_type?: "boolean";
                        /** @description Not implemented at this moment */
                        ui_rules?: Record<string, never>;
                        /** @description Not implemented at this moment. */
                        editable?: boolean;
                      } | {
                        /** @description User friendly title for the float. */
                        header?: string;
                        /** @description User friendly description for what the float does. */
                        description?: string;
                        /** @description Warning message (if any) that explains the user to use caution when changing this parameter, and why. */
                        warning?: unknown;
                        /**
                         * Format: float
                         * @description Value that this configurable float currently takes.
                         */
                        value?: number;
                        /**
                         * Format: float
                         * @description Default value that should be set for this float.
                         */
                        default_value?: number;
                        /** @description Name to identify the configurable float by in the system. */
                        name?: string;
                        /**
                         * @description Describes the template type of the parameter. 'selectable' is used for parameters with a fixed set of possible values. 'input' is used for parameters that allow free input, possibly restricted to a certain range. Template_type is always 'input' for a configurable float.
                         * @enum {string}
                         */
                        template_type?: "input";
                        /**
                         * @description Describes the type of parameter. Parameters can be integers, floats, boolean or string. Data_type is always 'float' for a configurable float.
                         * @enum {string}
                         */
                        data_type?: "float";
                        /**
                         * Format: float
                         * @description Minimum value that can be set for this parameter.
                         */
                        min_value?: number;
                        /**
                         * Format: float
                         * @description Minimum value that can be set for this parameter.
                         */
                        max_value?: number;
                        /** @description Not implemented at this moment */
                        ui_rules?: Record<string, never>;
                        /** @description Not implemented at this moment. */
                        editable?: boolean;
                      } | {
                        /** @description User friendly title for the integer. */
                        header?: string;
                        /** @description User friendly description for what the integer does. */
                        description?: string;
                        /** @description Warning message (if any) that explains the user to use caution when changing this parameter, and why. */
                        warning?: unknown;
                        /** @description Value that this configurable integer currently takes. */
                        value?: number;
                        /** @description Default value that should be set for this integer. */
                        default_value?: number;
                        /** @description Name to identify the configurable integer by in the system. */
                        name?: string;
                        /**
                         * @description Describes the template type of the parameter. 'selectable' is used for parameters with a fixed set of possible values. 'input' is used for parameters that allow free input, possibly restricted to a certain range. Template_type is always 'input' for a configurable integer.
                         * @enum {string}
                         */
                        template_type?: "input";
                        /**
                         * @description Describes the type of parameter. Parameters can be integers, floats, boolean or string. Data_type is always 'integer' for a configurable integer.
                         * @enum {string}
                         */
                        data_type?: "integer";
                        /** @description Minimum value that can be set for this parameter. */
                        min_value?: number;
                        /** @description Minimum value that can be set for this parameter. */
                        max_value?: number;
                        /** @description Not implemented at this moment */
                        ui_rules?: Record<string, never>;
                        /** @description Not implemented at this moment. */
                        editable?: boolean;
                      } | {
                        /** @description User friendly title for the selectable string. */
                        header?: string;
                        /** @description User friendly description for what the selectable string parameter does. */
                        description?: string;
                        /** @description Warning message (if any) that explains the user to use caution when changing this parameter, and why. */
                        warning?: unknown;
                        /** @description Value that this selectable string currently takes. */
                        value?: string;
                        /** @description Default value that should be set for this selectable string. */
                        default_value?: string;
                        /** @description Name to identify the selectable string parameter by in the system. */
                        name?: string;
                        /**
                         * @description Describes the template type of the parameter. 'selectable' is used for parameters with a fixed set of possible values. 'input' is used for parameters that allow free input, possibly restricted to a certain range. Template_type is always 'selectable' for a selectable string parameter.
                         * @enum {string}
                         */
                        template_type?: "selectable";
                        /**
                         * @description Describes the type of parameter. Parameters can be integers, floats, boolean or string. Data_type is always 'string' for a selectable string parameter.
                         * @enum {string}
                         */
                        data_type?: "string";
                        /** @description List of values that this selectable string can take. */
                        options?: string[];
                        /** @description Not implemented at this moment */
                        ui_rules?: Record<string, never>;
                        /** @description Not implemented at this moment. */
                        editable?: boolean;
                      } | {
                        /** @description User friendly title for the selectable. */
                        header?: string;
                        /** @description User friendly description for what the selectable parameter does. */
                        description?: string;
                        /** @description Warning message (if any) that explains the user to use caution when changing this parameter, and why. */
                        warning?: unknown;
                        /** @description Value that this selectable currently takes. */
                        value?: string;
                        /** @description Default value that should be set for this selectable. */
                        default_value?: string;
                        /** @description Name to identify the selectable parameter by in the system. */
                        name?: string;
                        /**
                         * @description Describes the template type of the parameter. 'selectable' is used for parameters with a fixed set of possible values. 'input' is used for parameters that allow free input, possibly restricted to a certain range. Template_type is always 'selectable' for a selectable parameter.
                         * @enum {string}
                         */
                        template_type?: "selectable";
                        /**
                         * @description Describes the type of parameter. Parameters can be integers, floats, boolean or string. Data_type is always 'float' for a selectable float.
                         * @enum {string}
                         */
                        data_type?: "float";
                        /** @description List of values that this float selectable can take. */
                        options?: number[];
                        /** @description Not implemented at this moment */
                        ui_rules?: Record<string, never>;
                        /** @description Not implemented at this moment. */
                        editable?: boolean;
                      })[];
                  }) | ({
                    /**
                     * @description Mongo ID of the object
                     * @example 60d31793d5f1fb7e6e3c1a4c
                     */
                    id?: string;
                    /**
                     * @description Type of the configurable parameters. For component parameters the type is always 'CONFIGURABLE_PARAMETERS'.
                     * @enum {string}
                     */
                    type?: "CONFIGURABLE_PARAMETERS" | "PARAMETER_GROUP";
                    entity_identifier?: OneOf<[{
                      workspace_id?: string;
                      /**
                       * @description Mongo ID of the object
                       * @example 60d31793d5f1fb7e6e3c1a4c
                       */
                      project_id?: string;
                      /**
                       * @description Mongo ID of the object
                       * @example 60d31793d5f1fb7e6e3c1a4c
                       */
                      task_id?: string;
                      /** @description Describes the component to which the configurable parameters apply */
                      component?: string;
                      /**
                       * @description Describes the type of the configuration. Set to COMPONENT_PARAMETERS for a configuration that relates to a component.
                       * @enum {string}
                       */
                      type?: "COMPONENT_PARAMETERS";
                    }, {
                      workspace_id?: string;
                      /**
                       * @description Mongo ID of the object
                       * @example 60d31793d5f1fb7e6e3c1a4c
                       */
                      model_storage_id?: string;
                      /**
                       * @description Describes the type of the configurable parameters. For hyper parameters, type is set to HYPER_PARAMETERS.
                       * @enum {string}
                       */
                      type?: "HYPER_PARAMETERS";
                    }, {
                      workspace_id?: string;
                      /**
                       * @description Mongo ID of the object
                       * @example 60d31793d5f1fb7e6e3c1a4c
                       */
                      model_storage_id?: string;
                      /** @description Name of the hyper parameter group */
                      group_name?: string;
                      /**
                       * @description Describes the type of the component. For hyper parameter groups, type is always set to HYPER_PARAMETER_GROUP
                       * @enum {string}
                       */
                      type?: "HYPER_PARAMETER_GROUP";
                    }]>;
                    /**
                     * @description Name of the configuration
                     * @example Subset splitting
                     */
                    header?: string;
                    /**
                     * @description Description of the configuration, indicating which part of the system it controls.
                     * @example These parameters control the splitting of the dataset into training, validation and test set.
                     */
                    description?: string;
                    groups?: ({
                        /**
                         * @description Defines the parameter group
                         * @example Learning Parameters
                         */
                        header?: string;
                        /**
                         * @description Description of the parameter group
                         * @example Configuration to control training behaviour
                         */
                        description?: string;
                        /** @enum {string} */
                        type?: "PARAMETER_GROUP";
                        /** @description Name of the parameter group */
                        name?: string;
                        parameters?: ({
                            /** @description User friendly title for the parameter. */
                            header?: string;
                            /** @description User friendly description for what the parameter does. */
                            description?: string;
                            /** @description Warning message (if any) that explains the user to use caution when changing this parameter, and why. */
                            warning?: unknown;
                            /** @description Value that this parameter currently takes. */
                            value?: string | number | boolean;
                            /** @description Default value that should be set for this parameter. */
                            default_value?: string | number | boolean;
                            /** @description Name to identify the parameter by in the system. */
                            name?: string;
                            /**
                             * @description Describes the template type of the parameter. 'selectable' is used for parameters with a fixed set of possible values. 'input' is used for parameters that allow free input, possibly restricted to a certain range.
                             * @enum {string}
                             */
                            template_type?: "selectable" | "input";
                            /**
                             * @description Describes the type of parameter. Parameters can be integers, floats, boolean or string.
                             * @enum {string}
                             */
                            data_type?: "float" | "integer" | "boolean" | "string";
                            /** @description List of values that this parameter can take. Only used for selectable string and selectable float parameters */
                            options?: (number | string)[];
                            /**
                             * Format: float
                             * @description Minimum value that can be set for this parameter. Only used for numeric parameters.
                             */
                            min_value?: number;
                            /**
                             * Format: float
                             * @description Minimum value that can be set for this parameter. Only used for numeric parameters.
                             */
                            max_value?: number;
                            /** @description Not implemented at this moment */
                            ui_rules?: Record<string, never>;
                            /** @description Not implemented at this moment. */
                            editable?: boolean;
                          })[];
                      })[];
                    /** @description Array of configurable parameters */
                    parameters?: ({
                        /** @description User friendly title for the configurable boolean. */
                        header?: string;
                        /** @description User friendly description for what the boolean does. */
                        description?: string;
                        /** @description Warning message (if any) that explains the user to use caution when changing this parameter, and why. */
                        warning?: unknown;
                        /** @description Value that this boolean currently takes. */
                        value?: boolean;
                        /** @description Default value that should be set for this boolean. */
                        default_value?: boolean;
                        /** @description Name to identify the configurable boolean by in the system. */
                        name?: string;
                        /**
                         * @description Describes the template type of the parameter. 'selectable' is used for parameters with a fixed set of possible values. 'input' is used for parameters that allow free input, possibly restricted to a certain range. Template_type is always 'input' for a configurable boolean.
                         * @enum {string}
                         */
                        template_type?: "input";
                        /**
                         * @description Describes the type of parameter. Parameters can be integers, floats, boolean or string. Data_type is always 'boolean' for a configurable boolean.
                         * @enum {string}
                         */
                        data_type?: "boolean";
                        /** @description Not implemented at this moment */
                        ui_rules?: Record<string, never>;
                        /** @description Not implemented at this moment. */
                        editable?: boolean;
                      } | {
                        /** @description User friendly title for the float. */
                        header?: string;
                        /** @description User friendly description for what the float does. */
                        description?: string;
                        /** @description Warning message (if any) that explains the user to use caution when changing this parameter, and why. */
                        warning?: unknown;
                        /**
                         * Format: float
                         * @description Value that this configurable float currently takes.
                         */
                        value?: number;
                        /**
                         * Format: float
                         * @description Default value that should be set for this float.
                         */
                        default_value?: number;
                        /** @description Name to identify the configurable float by in the system. */
                        name?: string;
                        /**
                         * @description Describes the template type of the parameter. 'selectable' is used for parameters with a fixed set of possible values. 'input' is used for parameters that allow free input, possibly restricted to a certain range. Template_type is always 'input' for a configurable float.
                         * @enum {string}
                         */
                        template_type?: "input";
                        /**
                         * @description Describes the type of parameter. Parameters can be integers, floats, boolean or string. Data_type is always 'float' for a configurable float.
                         * @enum {string}
                         */
                        data_type?: "float";
                        /**
                         * Format: float
                         * @description Minimum value that can be set for this parameter.
                         */
                        min_value?: number;
                        /**
                         * Format: float
                         * @description Minimum value that can be set for this parameter.
                         */
                        max_value?: number;
                        /** @description Not implemented at this moment */
                        ui_rules?: Record<string, never>;
                        /** @description Not implemented at this moment. */
                        editable?: boolean;
                      } | {
                        /** @description User friendly title for the integer. */
                        header?: string;
                        /** @description User friendly description for what the integer does. */
                        description?: string;
                        /** @description Warning message (if any) that explains the user to use caution when changing this parameter, and why. */
                        warning?: unknown;
                        /** @description Value that this configurable integer currently takes. */
                        value?: number;
                        /** @description Default value that should be set for this integer. */
                        default_value?: number;
                        /** @description Name to identify the configurable integer by in the system. */
                        name?: string;
                        /**
                         * @description Describes the template type of the parameter. 'selectable' is used for parameters with a fixed set of possible values. 'input' is used for parameters that allow free input, possibly restricted to a certain range. Template_type is always 'input' for a configurable integer.
                         * @enum {string}
                         */
                        template_type?: "input";
                        /**
                         * @description Describes the type of parameter. Parameters can be integers, floats, boolean or string. Data_type is always 'integer' for a configurable integer.
                         * @enum {string}
                         */
                        data_type?: "integer";
                        /** @description Minimum value that can be set for this parameter. */
                        min_value?: number;
                        /** @description Minimum value that can be set for this parameter. */
                        max_value?: number;
                        /** @description Not implemented at this moment */
                        ui_rules?: Record<string, never>;
                        /** @description Not implemented at this moment. */
                        editable?: boolean;
                      } | {
                        /** @description User friendly title for the selectable string. */
                        header?: string;
                        /** @description User friendly description for what the selectable string parameter does. */
                        description?: string;
                        /** @description Warning message (if any) that explains the user to use caution when changing this parameter, and why. */
                        warning?: unknown;
                        /** @description Value that this selectable string currently takes. */
                        value?: string;
                        /** @description Default value that should be set for this selectable string. */
                        default_value?: string;
                        /** @description Name to identify the selectable string parameter by in the system. */
                        name?: string;
                        /**
                         * @description Describes the template type of the parameter. 'selectable' is used for parameters with a fixed set of possible values. 'input' is used for parameters that allow free input, possibly restricted to a certain range. Template_type is always 'selectable' for a selectable string parameter.
                         * @enum {string}
                         */
                        template_type?: "selectable";
                        /**
                         * @description Describes the type of parameter. Parameters can be integers, floats, boolean or string. Data_type is always 'string' for a selectable string parameter.
                         * @enum {string}
                         */
                        data_type?: "string";
                        /** @description List of values that this selectable string can take. */
                        options?: string[];
                        /** @description Not implemented at this moment */
                        ui_rules?: Record<string, never>;
                        /** @description Not implemented at this moment. */
                        editable?: boolean;
                      } | {
                        /** @description User friendly title for the selectable. */
                        header?: string;
                        /** @description User friendly description for what the selectable parameter does. */
                        description?: string;
                        /** @description Warning message (if any) that explains the user to use caution when changing this parameter, and why. */
                        warning?: unknown;
                        /** @description Value that this selectable currently takes. */
                        value?: string;
                        /** @description Default value that should be set for this selectable. */
                        default_value?: string;
                        /** @description Name to identify the selectable parameter by in the system. */
                        name?: string;
                        /**
                         * @description Describes the template type of the parameter. 'selectable' is used for parameters with a fixed set of possible values. 'input' is used for parameters that allow free input, possibly restricted to a certain range. Template_type is always 'selectable' for a selectable parameter.
                         * @enum {string}
                         */
                        template_type?: "selectable";
                        /**
                         * @description Describes the type of parameter. Parameters can be integers, floats, boolean or string. Data_type is always 'float' for a selectable float.
                         * @enum {string}
                         */
                        data_type?: "float";
                        /** @description List of values that this float selectable can take. */
                        options?: number[];
                        /** @description Not implemented at this moment */
                        ui_rules?: Record<string, never>;
                        /** @description Not implemented at this moment. */
                        editable?: boolean;
                      })[];
                  }) | ({
                    /**
                     * @description Mongo ID of the object
                     * @example 60d31793d5f1fb7e6e3c1a4c
                     */
                    id?: string;
                    entity_identifier?: OneOf<[{
                      workspace_id?: string;
                      /**
                       * @description Mongo ID of the object
                       * @example 60d31793d5f1fb7e6e3c1a4c
                       */
                      project_id?: string;
                      /**
                       * @description Mongo ID of the object
                       * @example 60d31793d5f1fb7e6e3c1a4c
                       */
                      task_id?: string;
                      /** @description Describes the component to which the configurable parameters apply */
                      component?: string;
                      /**
                       * @description Describes the type of the configuration. Set to COMPONENT_PARAMETERS for a configuration that relates to a component.
                       * @enum {string}
                       */
                      type?: "COMPONENT_PARAMETERS";
                    }, {
                      workspace_id?: string;
                      /**
                       * @description Mongo ID of the object
                       * @example 60d31793d5f1fb7e6e3c1a4c
                       */
                      model_storage_id?: string;
                      /**
                       * @description Describes the type of the configurable parameters. For hyper parameters, type is set to HYPER_PARAMETERS.
                       * @enum {string}
                       */
                      type?: "HYPER_PARAMETERS";
                    }, {
                      workspace_id?: string;
                      /**
                       * @description Mongo ID of the object
                       * @example 60d31793d5f1fb7e6e3c1a4c
                       */
                      model_storage_id?: string;
                      /** @description Name of the hyper parameter group */
                      group_name?: string;
                      /**
                       * @description Describes the type of the component. For hyper parameter groups, type is always set to HYPER_PARAMETER_GROUP
                       * @enum {string}
                       */
                      type?: "HYPER_PARAMETER_GROUP";
                    }]>;
                    /**
                     * @description Type of the configurable parameters. For hyper parameters the type is always 'CONFIGURABLE_PARAMETERS'.
                     * @enum {string}
                     */
                    type?: "CONFIGURABLE_PARAMETERS" | "PARAMETER_GROUP";
                    /**
                     * @description The name of the configuration
                     * @example Hyper parameters for a segmentation task
                     */
                    header?: string;
                    /**
                     * @description Description of model to which this configuration belongs
                     * @example Hyper parameters for a segmentation task
                     */
                    description?: string;
                    groups?: ({
                        /**
                         * @description Defines the parameter group
                         * @example Learning Parameters
                         */
                        header?: string;
                        /**
                         * @description Description of the parameter group
                         * @example Configuration to control training behaviour
                         */
                        description?: string;
                        /** @enum {string} */
                        type?: "PARAMETER_GROUP";
                        /** @description Name of the parameter group */
                        name?: string;
                        parameters?: ({
                            /** @description User friendly title for the parameter. */
                            header?: string;
                            /** @description User friendly description for what the parameter does. */
                            description?: string;
                            /** @description Warning message (if any) that explains the user to use caution when changing this parameter, and why. */
                            warning?: unknown;
                            /** @description Value that this parameter currently takes. */
                            value?: string | number | boolean;
                            /** @description Default value that should be set for this parameter. */
                            default_value?: string | number | boolean;
                            /** @description Name to identify the parameter by in the system. */
                            name?: string;
                            /**
                             * @description Describes the template type of the parameter. 'selectable' is used for parameters with a fixed set of possible values. 'input' is used for parameters that allow free input, possibly restricted to a certain range.
                             * @enum {string}
                             */
                            template_type?: "selectable" | "input";
                            /**
                             * @description Describes the type of parameter. Parameters can be integers, floats, boolean or string.
                             * @enum {string}
                             */
                            data_type?: "float" | "integer" | "boolean" | "string";
                            /** @description List of values that this parameter can take. Only used for selectable string and selectable float parameters */
                            options?: (number | string)[];
                            /**
                             * Format: float
                             * @description Minimum value that can be set for this parameter. Only used for numeric parameters.
                             */
                            min_value?: number;
                            /**
                             * Format: float
                             * @description Minimum value that can be set for this parameter. Only used for numeric parameters.
                             */
                            max_value?: number;
                            /** @description Not implemented at this moment */
                            ui_rules?: Record<string, never>;
                            /** @description Not implemented at this moment. */
                            editable?: boolean;
                          })[];
                      })[];
                    /** @description Array of configurable parameters */
                    parameters?: ({
                        /** @description User friendly title for the configurable boolean. */
                        header?: string;
                        /** @description User friendly description for what the boolean does. */
                        description?: string;
                        /** @description Warning message (if any) that explains the user to use caution when changing this parameter, and why. */
                        warning?: unknown;
                        /** @description Value that this boolean currently takes. */
                        value?: boolean;
                        /** @description Default value that should be set for this boolean. */
                        default_value?: boolean;
                        /** @description Name to identify the configurable boolean by in the system. */
                        name?: string;
                        /**
                         * @description Describes the template type of the parameter. 'selectable' is used for parameters with a fixed set of possible values. 'input' is used for parameters that allow free input, possibly restricted to a certain range. Template_type is always 'input' for a configurable boolean.
                         * @enum {string}
                         */
                        template_type?: "input";
                        /**
                         * @description Describes the type of parameter. Parameters can be integers, floats, boolean or string. Data_type is always 'boolean' for a configurable boolean.
                         * @enum {string}
                         */
                        data_type?: "boolean";
                        /** @description Not implemented at this moment */
                        ui_rules?: Record<string, never>;
                        /** @description Not implemented at this moment. */
                        editable?: boolean;
                      } | {
                        /** @description User friendly title for the float. */
                        header?: string;
                        /** @description User friendly description for what the float does. */
                        description?: string;
                        /** @description Warning message (if any) that explains the user to use caution when changing this parameter, and why. */
                        warning?: unknown;
                        /**
                         * Format: float
                         * @description Value that this configurable float currently takes.
                         */
                        value?: number;
                        /**
                         * Format: float
                         * @description Default value that should be set for this float.
                         */
                        default_value?: number;
                        /** @description Name to identify the configurable float by in the system. */
                        name?: string;
                        /**
                         * @description Describes the template type of the parameter. 'selectable' is used for parameters with a fixed set of possible values. 'input' is used for parameters that allow free input, possibly restricted to a certain range. Template_type is always 'input' for a configurable float.
                         * @enum {string}
                         */
                        template_type?: "input";
                        /**
                         * @description Describes the type of parameter. Parameters can be integers, floats, boolean or string. Data_type is always 'float' for a configurable float.
                         * @enum {string}
                         */
                        data_type?: "float";
                        /**
                         * Format: float
                         * @description Minimum value that can be set for this parameter.
                         */
                        min_value?: number;
                        /**
                         * Format: float
                         * @description Minimum value that can be set for this parameter.
                         */
                        max_value?: number;
                        /** @description Not implemented at this moment */
                        ui_rules?: Record<string, never>;
                        /** @description Not implemented at this moment. */
                        editable?: boolean;
                      } | {
                        /** @description User friendly title for the integer. */
                        header?: string;
                        /** @description User friendly description for what the integer does. */
                        description?: string;
                        /** @description Warning message (if any) that explains the user to use caution when changing this parameter, and why. */
                        warning?: unknown;
                        /** @description Value that this configurable integer currently takes. */
                        value?: number;
                        /** @description Default value that should be set for this integer. */
                        default_value?: number;
                        /** @description Name to identify the configurable integer by in the system. */
                        name?: string;
                        /**
                         * @description Describes the template type of the parameter. 'selectable' is used for parameters with a fixed set of possible values. 'input' is used for parameters that allow free input, possibly restricted to a certain range. Template_type is always 'input' for a configurable integer.
                         * @enum {string}
                         */
                        template_type?: "input";
                        /**
                         * @description Describes the type of parameter. Parameters can be integers, floats, boolean or string. Data_type is always 'integer' for a configurable integer.
                         * @enum {string}
                         */
                        data_type?: "integer";
                        /** @description Minimum value that can be set for this parameter. */
                        min_value?: number;
                        /** @description Minimum value that can be set for this parameter. */
                        max_value?: number;
                        /** @description Not implemented at this moment */
                        ui_rules?: Record<string, never>;
                        /** @description Not implemented at this moment. */
                        editable?: boolean;
                      } | {
                        /** @description User friendly title for the selectable string. */
                        header?: string;
                        /** @description User friendly description for what the selectable string parameter does. */
                        description?: string;
                        /** @description Warning message (if any) that explains the user to use caution when changing this parameter, and why. */
                        warning?: unknown;
                        /** @description Value that this selectable string currently takes. */
                        value?: string;
                        /** @description Default value that should be set for this selectable string. */
                        default_value?: string;
                        /** @description Name to identify the selectable string parameter by in the system. */
                        name?: string;
                        /**
                         * @description Describes the template type of the parameter. 'selectable' is used for parameters with a fixed set of possible values. 'input' is used for parameters that allow free input, possibly restricted to a certain range. Template_type is always 'selectable' for a selectable string parameter.
                         * @enum {string}
                         */
                        template_type?: "selectable";
                        /**
                         * @description Describes the type of parameter. Parameters can be integers, floats, boolean or string. Data_type is always 'string' for a selectable string parameter.
                         * @enum {string}
                         */
                        data_type?: "string";
                        /** @description List of values that this selectable string can take. */
                        options?: string[];
                        /** @description Not implemented at this moment */
                        ui_rules?: Record<string, never>;
                        /** @description Not implemented at this moment. */
                        editable?: boolean;
                      } | {
                        /** @description User friendly title for the selectable. */
                        header?: string;
                        /** @description User friendly description for what the selectable parameter does. */
                        description?: string;
                        /** @description Warning message (if any) that explains the user to use caution when changing this parameter, and why. */
                        warning?: unknown;
                        /** @description Value that this selectable currently takes. */
                        value?: string;
                        /** @description Default value that should be set for this selectable. */
                        default_value?: string;
                        /** @description Name to identify the selectable parameter by in the system. */
                        name?: string;
                        /**
                         * @description Describes the template type of the parameter. 'selectable' is used for parameters with a fixed set of possible values. 'input' is used for parameters that allow free input, possibly restricted to a certain range. Template_type is always 'selectable' for a selectable parameter.
                         * @enum {string}
                         */
                        template_type?: "selectable";
                        /**
                         * @description Describes the type of parameter. Parameters can be integers, floats, boolean or string. Data_type is always 'float' for a selectable float.
                         * @enum {string}
                         */
                        data_type?: "float";
                        /** @description List of values that this float selectable can take. */
                        options?: number[];
                        /** @description Not implemented at this moment */
                        ui_rules?: Record<string, never>;
                        /** @description Not implemented at this moment. */
                        editable?: boolean;
                      })[];
                  }))[];
                /**
                 * @description Mongo ID of the object
                 * @example 60d31793d5f1fb7e6e3c1a4c
                 */
                task_id?: string;
                /** @description Title of the task the configuration is connected to */
                task_title?: string;
              })[];
          };
        };
      };
      /** @description Object not found. See the examples for details. */
      404: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 400 | 404 | 405 | 409 | 412 | 413 | 415 | 422 | 423 | 500 | 501 | 503;
            /** @description Message from server */
            message: string;
            /** @description Error code from server */
            error_code: string;
          };
        };
      };
    };
  };
  /**
   * Set the full configuration for the project.
   * @description This endpoint sets the configuration for all components in the project, as well as the current algorithms used in the task chain. The configuration is subdivided into components, and every component is divided into parameter groups.
   */
  SetFullConfiguration: {
    parameters: {
      path: {
        /** @description The ID of the organization. */
        organization_id: string;
        /** @description The ID of the workspace. */
        workspace_id: string;
        /** @description The ID of the project. */
        project_id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": {
          /** @description Array of configurable parameter objects for the different global (i.e. project-wide) components in the project */
          global: ({
              /** Component entity identifier */
              entity_identifier: {
                workspace_id?: string;
                /**
                 * @description Mongo ID of the object
                 * @example 60d31793d5f1fb7e6e3c1a4c
                 */
                project_id?: string;
                /**
                 * @description Mongo ID of the task
                 * @example 60d31793d5f1fb7e6e3c1a4c
                 */
                task_id?: string;
                /**
                 * @description If the configuration is a component configuration, describes the component.
                 * @enum {string}
                 */
                component: "NULL_COMPONENT" | "SUBSET_MANAGER" | "DATASET_COUNTER" | "PROJECT_ACTIVE_LEARNING" | "TASK_ACTIVE_LEARNING" | "TASK_NODE" | "PIPELINE_DATASET_MANAGER";
                /**
                 * @description Describes the type of the configuration. Set to COMPONENT_PARAMETERS for a configuration that relates to a component.
                 * @enum {string}
                 */
                type: "COMPONENT_PARAMETERS";
              };
              groups?: ({
                  /** @description Name of the parameter group */
                  name: string;
                  /** @description Array of parameters */
                  parameters: ({
                      /** @description Value to set the parameter to. */
                      value: string | number | boolean;
                      /** @description Name to identify the parameter by in the system. */
                      name: string;
                    })[];
                })[];
              parameters?: ({
                  /** @description Value to set the parameter to. */
                  value: string | number | boolean;
                  /** @description Name to identify the parameter by in the system. */
                  name: string;
                })[];
            })[];
          /** @description Array of task configurations */
          task_chain: ({
              /** @description Array of configurable parameter objects for the different components in the task, as well as the hyper parameters for the current algorithm in the task */
              components: ({
                  entity_identifier: OneOf<[{
                    workspace_id?: string;
                    /**
                     * @description Mongo ID of the object
                     * @example 60d31793d5f1fb7e6e3c1a4c
                     */
                    project_id?: string;
                    /**
                     * @description Mongo ID of the task
                     * @example 60d31793d5f1fb7e6e3c1a4c
                     */
                    task_id?: string;
                    /**
                     * @description If the configuration is a component configuration, describes the component.
                     * @enum {string}
                     */
                    component: "NULL_COMPONENT" | "SUBSET_MANAGER" | "DATASET_COUNTER" | "PROJECT_ACTIVE_LEARNING" | "TASK_ACTIVE_LEARNING" | "TASK_NODE" | "PIPELINE_DATASET_MANAGER";
                    /**
                     * @description Describes the type of the configuration. Set to COMPONENT_PARAMETERS for a configuration that relates to a component.
                     * @enum {string}
                     */
                    type: "COMPONENT_PARAMETERS";
                  }, {
                    workspace_id?: string;
                    /**
                     * @description Mongo ID of the object
                     * @example 60d31793d5f1fb7e6e3c1a4c
                     */
                    model_storage_id: string;
                    /**
                     * @description Describes the type of the configurable parameters. For hyper parameters, type is set to HYPER_PARAMETERS.
                     * @enum {string}
                     */
                    type: "HYPER_PARAMETERS";
                  }, {
                    workspace_id?: string;
                    /**
                     * @description Mongo ID of the object
                     * @example 60d31793d5f1fb7e6e3c1a4c
                     */
                    model_storage_id: string;
                    /** @description The name of the hyper parameter group */
                    group_name: string;
                    /**
                     * @description Describes the type of the component. For hyper parameter groups, type is always set to HYPER_PARAMETER_GROUP
                     * @enum {string}
                     */
                    type: "HYPER_PARAMETER_GROUP";
                  }]>;
                  groups?: ({
                      /** @description Name of the parameter group */
                      name: string;
                      /** @description Array of parameters */
                      parameters: ({
                          /** @description Value to set the parameter to. */
                          value: string | number | boolean;
                          /** @description Name to identify the parameter by in the system. */
                          name: string;
                        })[];
                    })[];
                  parameters?: ({
                      /** @description Value to set the parameter to. */
                      value: string | number | boolean;
                      /** @description Name to identify the parameter by in the system. */
                      name: string;
                    })[];
                })[];
            })[];
        };
      };
    };
    responses: {
      /** @description Configuration updated successfully */
      200: {
        content: {
          "application/json": unknown;
        };
      };
      /** @description Object not found. See the examples for details. */
      404: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 400 | 404 | 405 | 409 | 412 | 413 | 415 | 422 | 423 | 500 | 501 | 503;
            /** @description Message from server */
            message: string;
            /** @description Error code from server */
            error_code: string;
          };
        };
      };
      /** @description Configuration cannot be saved to the server */
      500: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 400 | 404 | 405 | 409 | 412 | 413 | 415 | 422 | 423 | 500 | 501 | 503;
            /** @description Message from server */
            message: string;
            /** @description Error code from server */
            error_code: string;
          };
        };
      };
    };
  };
  /**
   * Get the current configuration for all components in the project.
   * @description This endpoint gets the configuration for all components in the project that are acting project-wide. The configuration is subdivided into components. Examples of configuration components are the active learning parameters or dataset management related parameters. Some components are further divided into parameter groups.
   */
  GetGlobalConfiguration: {
    parameters: {
      path: {
        /** @description The ID of the organization. */
        organization_id: string;
        /** @description The ID of the workspace. */
        workspace_id: string;
        /** @description The ID of the project. */
        project_id: string;
      };
    };
    responses: {
      /** @description Get global configuration response */
      200: {
        content: {
          "application/json": {
            /** @description Array of configurable parameter objects for the different global (i.e. project-wide) components in the project */
            global?: ({
                /**
                 * @description Mongo ID of the object
                 * @example 60d31793d5f1fb7e6e3c1a4c
                 */
                id?: string;
                /**
                 * @description Type of the configurable parameters. For component parameters the type is always 'CONFIGURABLE_PARAMETERS'.
                 * @enum {string}
                 */
                type?: "CONFIGURABLE_PARAMETERS" | "PARAMETER_GROUP";
                entity_identifier?: OneOf<[{
                  workspace_id?: string;
                  /**
                   * @description Mongo ID of the object
                   * @example 60d31793d5f1fb7e6e3c1a4c
                   */
                  project_id?: string;
                  /**
                   * @description Mongo ID of the object
                   * @example 60d31793d5f1fb7e6e3c1a4c
                   */
                  task_id?: string;
                  /** @description Describes the component to which the configurable parameters apply */
                  component?: string;
                  /**
                   * @description Describes the type of the configuration. Set to COMPONENT_PARAMETERS for a configuration that relates to a component.
                   * @enum {string}
                   */
                  type?: "COMPONENT_PARAMETERS";
                }, {
                  workspace_id?: string;
                  /**
                   * @description Mongo ID of the object
                   * @example 60d31793d5f1fb7e6e3c1a4c
                   */
                  model_storage_id?: string;
                  /**
                   * @description Describes the type of the configurable parameters. For hyper parameters, type is set to HYPER_PARAMETERS.
                   * @enum {string}
                   */
                  type?: "HYPER_PARAMETERS";
                }, {
                  workspace_id?: string;
                  /**
                   * @description Mongo ID of the object
                   * @example 60d31793d5f1fb7e6e3c1a4c
                   */
                  model_storage_id?: string;
                  /** @description Name of the hyper parameter group */
                  group_name?: string;
                  /**
                   * @description Describes the type of the component. For hyper parameter groups, type is always set to HYPER_PARAMETER_GROUP
                   * @enum {string}
                   */
                  type?: "HYPER_PARAMETER_GROUP";
                }]>;
                /**
                 * @description Name of the configuration
                 * @example Subset splitting
                 */
                header?: string;
                /**
                 * @description Description of the configuration, indicating which part of the system it controls.
                 * @example These parameters control the splitting of the dataset into training, validation and test set.
                 */
                description?: string;
                groups?: ({
                    /**
                     * @description Defines the parameter group
                     * @example Learning Parameters
                     */
                    header?: string;
                    /**
                     * @description Description of the parameter group
                     * @example Configuration to control training behaviour
                     */
                    description?: string;
                    /** @enum {string} */
                    type?: "PARAMETER_GROUP";
                    /** @description Name of the parameter group */
                    name?: string;
                    parameters?: ({
                        /** @description User friendly title for the parameter. */
                        header?: string;
                        /** @description User friendly description for what the parameter does. */
                        description?: string;
                        /** @description Warning message (if any) that explains the user to use caution when changing this parameter, and why. */
                        warning?: unknown;
                        /** @description Value that this parameter currently takes. */
                        value?: string | number | boolean;
                        /** @description Default value that should be set for this parameter. */
                        default_value?: string | number | boolean;
                        /** @description Name to identify the parameter by in the system. */
                        name?: string;
                        /**
                         * @description Describes the template type of the parameter. 'selectable' is used for parameters with a fixed set of possible values. 'input' is used for parameters that allow free input, possibly restricted to a certain range.
                         * @enum {string}
                         */
                        template_type?: "selectable" | "input";
                        /**
                         * @description Describes the type of parameter. Parameters can be integers, floats, boolean or string.
                         * @enum {string}
                         */
                        data_type?: "float" | "integer" | "boolean" | "string";
                        /** @description List of values that this parameter can take. Only used for selectable string and selectable float parameters */
                        options?: (number | string)[];
                        /**
                         * Format: float
                         * @description Minimum value that can be set for this parameter. Only used for numeric parameters.
                         */
                        min_value?: number;
                        /**
                         * Format: float
                         * @description Minimum value that can be set for this parameter. Only used for numeric parameters.
                         */
                        max_value?: number;
                        /** @description Not implemented at this moment */
                        ui_rules?: Record<string, never>;
                        /** @description Not implemented at this moment. */
                        editable?: boolean;
                      })[];
                  })[];
                /** @description Array of configurable parameters */
                parameters?: ({
                    /** @description User friendly title for the configurable boolean. */
                    header?: string;
                    /** @description User friendly description for what the boolean does. */
                    description?: string;
                    /** @description Warning message (if any) that explains the user to use caution when changing this parameter, and why. */
                    warning?: unknown;
                    /** @description Value that this boolean currently takes. */
                    value?: boolean;
                    /** @description Default value that should be set for this boolean. */
                    default_value?: boolean;
                    /** @description Name to identify the configurable boolean by in the system. */
                    name?: string;
                    /**
                     * @description Describes the template type of the parameter. 'selectable' is used for parameters with a fixed set of possible values. 'input' is used for parameters that allow free input, possibly restricted to a certain range. Template_type is always 'input' for a configurable boolean.
                     * @enum {string}
                     */
                    template_type?: "input";
                    /**
                     * @description Describes the type of parameter. Parameters can be integers, floats, boolean or string. Data_type is always 'boolean' for a configurable boolean.
                     * @enum {string}
                     */
                    data_type?: "boolean";
                    /** @description Not implemented at this moment */
                    ui_rules?: Record<string, never>;
                    /** @description Not implemented at this moment. */
                    editable?: boolean;
                  } | {
                    /** @description User friendly title for the float. */
                    header?: string;
                    /** @description User friendly description for what the float does. */
                    description?: string;
                    /** @description Warning message (if any) that explains the user to use caution when changing this parameter, and why. */
                    warning?: unknown;
                    /**
                     * Format: float
                     * @description Value that this configurable float currently takes.
                     */
                    value?: number;
                    /**
                     * Format: float
                     * @description Default value that should be set for this float.
                     */
                    default_value?: number;
                    /** @description Name to identify the configurable float by in the system. */
                    name?: string;
                    /**
                     * @description Describes the template type of the parameter. 'selectable' is used for parameters with a fixed set of possible values. 'input' is used for parameters that allow free input, possibly restricted to a certain range. Template_type is always 'input' for a configurable float.
                     * @enum {string}
                     */
                    template_type?: "input";
                    /**
                     * @description Describes the type of parameter. Parameters can be integers, floats, boolean or string. Data_type is always 'float' for a configurable float.
                     * @enum {string}
                     */
                    data_type?: "float";
                    /**
                     * Format: float
                     * @description Minimum value that can be set for this parameter.
                     */
                    min_value?: number;
                    /**
                     * Format: float
                     * @description Minimum value that can be set for this parameter.
                     */
                    max_value?: number;
                    /** @description Not implemented at this moment */
                    ui_rules?: Record<string, never>;
                    /** @description Not implemented at this moment. */
                    editable?: boolean;
                  } | {
                    /** @description User friendly title for the integer. */
                    header?: string;
                    /** @description User friendly description for what the integer does. */
                    description?: string;
                    /** @description Warning message (if any) that explains the user to use caution when changing this parameter, and why. */
                    warning?: unknown;
                    /** @description Value that this configurable integer currently takes. */
                    value?: number;
                    /** @description Default value that should be set for this integer. */
                    default_value?: number;
                    /** @description Name to identify the configurable integer by in the system. */
                    name?: string;
                    /**
                     * @description Describes the template type of the parameter. 'selectable' is used for parameters with a fixed set of possible values. 'input' is used for parameters that allow free input, possibly restricted to a certain range. Template_type is always 'input' for a configurable integer.
                     * @enum {string}
                     */
                    template_type?: "input";
                    /**
                     * @description Describes the type of parameter. Parameters can be integers, floats, boolean or string. Data_type is always 'integer' for a configurable integer.
                     * @enum {string}
                     */
                    data_type?: "integer";
                    /** @description Minimum value that can be set for this parameter. */
                    min_value?: number;
                    /** @description Minimum value that can be set for this parameter. */
                    max_value?: number;
                    /** @description Not implemented at this moment */
                    ui_rules?: Record<string, never>;
                    /** @description Not implemented at this moment. */
                    editable?: boolean;
                  } | {
                    /** @description User friendly title for the selectable string. */
                    header?: string;
                    /** @description User friendly description for what the selectable string parameter does. */
                    description?: string;
                    /** @description Warning message (if any) that explains the user to use caution when changing this parameter, and why. */
                    warning?: unknown;
                    /** @description Value that this selectable string currently takes. */
                    value?: string;
                    /** @description Default value that should be set for this selectable string. */
                    default_value?: string;
                    /** @description Name to identify the selectable string parameter by in the system. */
                    name?: string;
                    /**
                     * @description Describes the template type of the parameter. 'selectable' is used for parameters with a fixed set of possible values. 'input' is used for parameters that allow free input, possibly restricted to a certain range. Template_type is always 'selectable' for a selectable string parameter.
                     * @enum {string}
                     */
                    template_type?: "selectable";
                    /**
                     * @description Describes the type of parameter. Parameters can be integers, floats, boolean or string. Data_type is always 'string' for a selectable string parameter.
                     * @enum {string}
                     */
                    data_type?: "string";
                    /** @description List of values that this selectable string can take. */
                    options?: string[];
                    /** @description Not implemented at this moment */
                    ui_rules?: Record<string, never>;
                    /** @description Not implemented at this moment. */
                    editable?: boolean;
                  } | {
                    /** @description User friendly title for the selectable. */
                    header?: string;
                    /** @description User friendly description for what the selectable parameter does. */
                    description?: string;
                    /** @description Warning message (if any) that explains the user to use caution when changing this parameter, and why. */
                    warning?: unknown;
                    /** @description Value that this selectable currently takes. */
                    value?: string;
                    /** @description Default value that should be set for this selectable. */
                    default_value?: string;
                    /** @description Name to identify the selectable parameter by in the system. */
                    name?: string;
                    /**
                     * @description Describes the template type of the parameter. 'selectable' is used for parameters with a fixed set of possible values. 'input' is used for parameters that allow free input, possibly restricted to a certain range. Template_type is always 'selectable' for a selectable parameter.
                     * @enum {string}
                     */
                    template_type?: "selectable";
                    /**
                     * @description Describes the type of parameter. Parameters can be integers, floats, boolean or string. Data_type is always 'float' for a selectable float.
                     * @enum {string}
                     */
                    data_type?: "float";
                    /** @description List of values that this float selectable can take. */
                    options?: number[];
                    /** @description Not implemented at this moment */
                    ui_rules?: Record<string, never>;
                    /** @description Not implemented at this moment. */
                    editable?: boolean;
                  })[];
              })[];
          };
        };
      };
      /** @description Object not found. See the examples for details. */
      404: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 400 | 404 | 405 | 409 | 412 | 413 | 415 | 422 | 423 | 500 | 501 | 503;
            /** @description Message from server */
            message: string;
            /** @description Error code from server */
            error_code: string;
          };
        };
      };
    };
  };
  /**
   * Set the configuration for all components in the project.
   * @description This endpoint sets the configuration for all components in the project that are acting globally, i.e. project-wide. The configuration is subdivided into components, and every component is divided into parameter groups.
   */
  SetGlobalConfiguration: {
    parameters: {
      path: {
        /** @description The ID of the organization. */
        organization_id: string;
        /** @description The ID of the workspace. */
        workspace_id: string;
        /** @description The ID of the project. */
        project_id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": {
          /** @description Array of configurable parameter objects for the different global (i.e. project-wide) components in the project */
          global: ({
              /** Component entity identifier */
              entity_identifier: {
                workspace_id?: string;
                /**
                 * @description Mongo ID of the object
                 * @example 60d31793d5f1fb7e6e3c1a4c
                 */
                project_id?: string;
                /**
                 * @description Mongo ID of the task
                 * @example 60d31793d5f1fb7e6e3c1a4c
                 */
                task_id?: string;
                /**
                 * @description If the configuration is a component configuration, describes the component.
                 * @enum {string}
                 */
                component: "NULL_COMPONENT" | "SUBSET_MANAGER" | "DATASET_COUNTER" | "PROJECT_ACTIVE_LEARNING" | "TASK_ACTIVE_LEARNING" | "TASK_NODE" | "PIPELINE_DATASET_MANAGER";
                /**
                 * @description Describes the type of the configuration. Set to COMPONENT_PARAMETERS for a configuration that relates to a component.
                 * @enum {string}
                 */
                type: "COMPONENT_PARAMETERS";
              };
              groups?: ({
                  /** @description Name of the parameter group */
                  name: string;
                  /** @description Array of parameters */
                  parameters: ({
                      /** @description Value to set the parameter to. */
                      value: string | number | boolean;
                      /** @description Name to identify the parameter by in the system. */
                      name: string;
                    })[];
                })[];
              parameters?: ({
                  /** @description Value to set the parameter to. */
                  value: string | number | boolean;
                  /** @description Name to identify the parameter by in the system. */
                  name: string;
                })[];
            })[];
        };
      };
    };
    responses: {
      /** @description Configuration updated successfully */
      200: {
        content: {
          "application/json": unknown;
        };
      };
      /** @description Object not found. See the examples for details. */
      404: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 400 | 404 | 405 | 409 | 412 | 413 | 415 | 422 | 423 | 500 | 501 | 503;
            /** @description Message from server */
            message: string;
            /** @description Error code from server */
            error_code: string;
          };
        };
      };
      /** @description Configuration cannot be saved to the server */
      500: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 400 | 404 | 405 | 409 | 412 | 413 | 415 | 422 | 423 | 500 | 501 | 503;
            /** @description Message from server */
            message: string;
            /** @description Error code from server */
            error_code: string;
          };
        };
      };
    };
  };
  /**
   * Get the current configuration for all tasks in the project's task chain.
   * @description This endpoint pulls the configuration for all tasks in the project. For every task in the project, the configuration is subdivided into components. Examples of configuration components are the deep learning parameters, postprocessing parameters or subset-related parameters. Some components are further divided into parameter groups.
   */
  GetTaskChainConfiguration: {
    parameters: {
      path: {
        /** @description The ID of the organization. */
        organization_id: string;
        /** @description The ID of the workspace. */
        workspace_id: string;
        /** @description The ID of the project. */
        project_id: string;
      };
    };
    responses: {
      /** @description Get configuration response */
      200: {
        content: {
          "application/json": {
            /** @description Array of task configurations */
            task_chain?: ({
                /** @description Array of configurable parameter objects for the different components in the task, as well as the hyper parameters for the current algorithm in the task */
                components?: (({
                    /** @description Name of the hyper parameter group */
                    name?: string;
                    /**
                     * @description ID of the hyper parameter group. The first 24 characters refer to the ID of the underlying HyperParameter object. This is followed by a dash ('-') and the group number (0 to 99) of this particular hyper parameter group.
                     * @example 60d31793d5f1fb7e6e3c1a4c-1
                     */
                    id?: string;
                    /**
                     * @description Type of the configurable parameters. For a hyper parameter group the type is always 'PARAMETER_GROUP'.
                     * @enum {string}
                     */
                    type?: "CONFIGURABLE_PARAMETERS" | "PARAMETER_GROUP";
                    entity_identifier?: OneOf<[{
                      workspace_id?: string;
                      /**
                       * @description Mongo ID of the object
                       * @example 60d31793d5f1fb7e6e3c1a4c
                       */
                      project_id?: string;
                      /**
                       * @description Mongo ID of the object
                       * @example 60d31793d5f1fb7e6e3c1a4c
                       */
                      task_id?: string;
                      /** @description Describes the component to which the configurable parameters apply */
                      component?: string;
                      /**
                       * @description Describes the type of the configuration. Set to COMPONENT_PARAMETERS for a configuration that relates to a component.
                       * @enum {string}
                       */
                      type?: "COMPONENT_PARAMETERS";
                    }, {
                      workspace_id?: string;
                      /**
                       * @description Mongo ID of the object
                       * @example 60d31793d5f1fb7e6e3c1a4c
                       */
                      model_storage_id?: string;
                      /**
                       * @description Describes the type of the configurable parameters. For hyper parameters, type is set to HYPER_PARAMETERS.
                       * @enum {string}
                       */
                      type?: "HYPER_PARAMETERS";
                    }, {
                      workspace_id?: string;
                      /**
                       * @description Mongo ID of the object
                       * @example 60d31793d5f1fb7e6e3c1a4c
                       */
                      model_storage_id?: string;
                      /** @description Name of the hyper parameter group */
                      group_name?: string;
                      /**
                       * @description Describes the type of the component. For hyper parameter groups, type is always set to HYPER_PARAMETER_GROUP
                       * @enum {string}
                       */
                      type?: "HYPER_PARAMETER_GROUP";
                    }]>;
                    /**
                     * @description The name of the hyper parameter group
                     * @example Learning parameters
                     */
                    header?: string;
                    /**
                     * @description Description of the hyper parameter group.
                     * @example A set of parameters that control the training process.
                     */
                    description?: string;
                    groups?: ({
                        /**
                         * @description Defines the parameter group
                         * @example Learning Parameters
                         */
                        header?: string;
                        /**
                         * @description Description of the parameter group
                         * @example Configuration to control training behaviour
                         */
                        description?: string;
                        /** @enum {string} */
                        type?: "PARAMETER_GROUP";
                        /** @description Name of the parameter group */
                        name?: string;
                        parameters?: ({
                            /** @description User friendly title for the parameter. */
                            header?: string;
                            /** @description User friendly description for what the parameter does. */
                            description?: string;
                            /** @description Warning message (if any) that explains the user to use caution when changing this parameter, and why. */
                            warning?: unknown;
                            /** @description Value that this parameter currently takes. */
                            value?: string | number | boolean;
                            /** @description Default value that should be set for this parameter. */
                            default_value?: string | number | boolean;
                            /** @description Name to identify the parameter by in the system. */
                            name?: string;
                            /**
                             * @description Describes the template type of the parameter. 'selectable' is used for parameters with a fixed set of possible values. 'input' is used for parameters that allow free input, possibly restricted to a certain range.
                             * @enum {string}
                             */
                            template_type?: "selectable" | "input";
                            /**
                             * @description Describes the type of parameter. Parameters can be integers, floats, boolean or string.
                             * @enum {string}
                             */
                            data_type?: "float" | "integer" | "boolean" | "string";
                            /** @description List of values that this parameter can take. Only used for selectable string and selectable float parameters */
                            options?: (number | string)[];
                            /**
                             * Format: float
                             * @description Minimum value that can be set for this parameter. Only used for numeric parameters.
                             */
                            min_value?: number;
                            /**
                             * Format: float
                             * @description Minimum value that can be set for this parameter. Only used for numeric parameters.
                             */
                            max_value?: number;
                            /** @description Not implemented at this moment */
                            ui_rules?: Record<string, never>;
                            /** @description Not implemented at this moment. */
                            editable?: boolean;
                          })[];
                      })[];
                    /** @description Array of configurable parameters */
                    parameters?: ({
                        /** @description User friendly title for the configurable boolean. */
                        header?: string;
                        /** @description User friendly description for what the boolean does. */
                        description?: string;
                        /** @description Warning message (if any) that explains the user to use caution when changing this parameter, and why. */
                        warning?: unknown;
                        /** @description Value that this boolean currently takes. */
                        value?: boolean;
                        /** @description Default value that should be set for this boolean. */
                        default_value?: boolean;
                        /** @description Name to identify the configurable boolean by in the system. */
                        name?: string;
                        /**
                         * @description Describes the template type of the parameter. 'selectable' is used for parameters with a fixed set of possible values. 'input' is used for parameters that allow free input, possibly restricted to a certain range. Template_type is always 'input' for a configurable boolean.
                         * @enum {string}
                         */
                        template_type?: "input";
                        /**
                         * @description Describes the type of parameter. Parameters can be integers, floats, boolean or string. Data_type is always 'boolean' for a configurable boolean.
                         * @enum {string}
                         */
                        data_type?: "boolean";
                        /** @description Not implemented at this moment */
                        ui_rules?: Record<string, never>;
                        /** @description Not implemented at this moment. */
                        editable?: boolean;
                      } | {
                        /** @description User friendly title for the float. */
                        header?: string;
                        /** @description User friendly description for what the float does. */
                        description?: string;
                        /** @description Warning message (if any) that explains the user to use caution when changing this parameter, and why. */
                        warning?: unknown;
                        /**
                         * Format: float
                         * @description Value that this configurable float currently takes.
                         */
                        value?: number;
                        /**
                         * Format: float
                         * @description Default value that should be set for this float.
                         */
                        default_value?: number;
                        /** @description Name to identify the configurable float by in the system. */
                        name?: string;
                        /**
                         * @description Describes the template type of the parameter. 'selectable' is used for parameters with a fixed set of possible values. 'input' is used for parameters that allow free input, possibly restricted to a certain range. Template_type is always 'input' for a configurable float.
                         * @enum {string}
                         */
                        template_type?: "input";
                        /**
                         * @description Describes the type of parameter. Parameters can be integers, floats, boolean or string. Data_type is always 'float' for a configurable float.
                         * @enum {string}
                         */
                        data_type?: "float";
                        /**
                         * Format: float
                         * @description Minimum value that can be set for this parameter.
                         */
                        min_value?: number;
                        /**
                         * Format: float
                         * @description Minimum value that can be set for this parameter.
                         */
                        max_value?: number;
                        /** @description Not implemented at this moment */
                        ui_rules?: Record<string, never>;
                        /** @description Not implemented at this moment. */
                        editable?: boolean;
                      } | {
                        /** @description User friendly title for the integer. */
                        header?: string;
                        /** @description User friendly description for what the integer does. */
                        description?: string;
                        /** @description Warning message (if any) that explains the user to use caution when changing this parameter, and why. */
                        warning?: unknown;
                        /** @description Value that this configurable integer currently takes. */
                        value?: number;
                        /** @description Default value that should be set for this integer. */
                        default_value?: number;
                        /** @description Name to identify the configurable integer by in the system. */
                        name?: string;
                        /**
                         * @description Describes the template type of the parameter. 'selectable' is used for parameters with a fixed set of possible values. 'input' is used for parameters that allow free input, possibly restricted to a certain range. Template_type is always 'input' for a configurable integer.
                         * @enum {string}
                         */
                        template_type?: "input";
                        /**
                         * @description Describes the type of parameter. Parameters can be integers, floats, boolean or string. Data_type is always 'integer' for a configurable integer.
                         * @enum {string}
                         */
                        data_type?: "integer";
                        /** @description Minimum value that can be set for this parameter. */
                        min_value?: number;
                        /** @description Minimum value that can be set for this parameter. */
                        max_value?: number;
                        /** @description Not implemented at this moment */
                        ui_rules?: Record<string, never>;
                        /** @description Not implemented at this moment. */
                        editable?: boolean;
                      } | {
                        /** @description User friendly title for the selectable string. */
                        header?: string;
                        /** @description User friendly description for what the selectable string parameter does. */
                        description?: string;
                        /** @description Warning message (if any) that explains the user to use caution when changing this parameter, and why. */
                        warning?: unknown;
                        /** @description Value that this selectable string currently takes. */
                        value?: string;
                        /** @description Default value that should be set for this selectable string. */
                        default_value?: string;
                        /** @description Name to identify the selectable string parameter by in the system. */
                        name?: string;
                        /**
                         * @description Describes the template type of the parameter. 'selectable' is used for parameters with a fixed set of possible values. 'input' is used for parameters that allow free input, possibly restricted to a certain range. Template_type is always 'selectable' for a selectable string parameter.
                         * @enum {string}
                         */
                        template_type?: "selectable";
                        /**
                         * @description Describes the type of parameter. Parameters can be integers, floats, boolean or string. Data_type is always 'string' for a selectable string parameter.
                         * @enum {string}
                         */
                        data_type?: "string";
                        /** @description List of values that this selectable string can take. */
                        options?: string[];
                        /** @description Not implemented at this moment */
                        ui_rules?: Record<string, never>;
                        /** @description Not implemented at this moment. */
                        editable?: boolean;
                      } | {
                        /** @description User friendly title for the selectable. */
                        header?: string;
                        /** @description User friendly description for what the selectable parameter does. */
                        description?: string;
                        /** @description Warning message (if any) that explains the user to use caution when changing this parameter, and why. */
                        warning?: unknown;
                        /** @description Value that this selectable currently takes. */
                        value?: string;
                        /** @description Default value that should be set for this selectable. */
                        default_value?: string;
                        /** @description Name to identify the selectable parameter by in the system. */
                        name?: string;
                        /**
                         * @description Describes the template type of the parameter. 'selectable' is used for parameters with a fixed set of possible values. 'input' is used for parameters that allow free input, possibly restricted to a certain range. Template_type is always 'selectable' for a selectable parameter.
                         * @enum {string}
                         */
                        template_type?: "selectable";
                        /**
                         * @description Describes the type of parameter. Parameters can be integers, floats, boolean or string. Data_type is always 'float' for a selectable float.
                         * @enum {string}
                         */
                        data_type?: "float";
                        /** @description List of values that this float selectable can take. */
                        options?: number[];
                        /** @description Not implemented at this moment */
                        ui_rules?: Record<string, never>;
                        /** @description Not implemented at this moment. */
                        editable?: boolean;
                      })[];
                  }) | ({
                    /**
                     * @description Mongo ID of the object
                     * @example 60d31793d5f1fb7e6e3c1a4c
                     */
                    id?: string;
                    /**
                     * @description Type of the configurable parameters. For component parameters the type is always 'CONFIGURABLE_PARAMETERS'.
                     * @enum {string}
                     */
                    type?: "CONFIGURABLE_PARAMETERS" | "PARAMETER_GROUP";
                    entity_identifier?: OneOf<[{
                      workspace_id?: string;
                      /**
                       * @description Mongo ID of the object
                       * @example 60d31793d5f1fb7e6e3c1a4c
                       */
                      project_id?: string;
                      /**
                       * @description Mongo ID of the object
                       * @example 60d31793d5f1fb7e6e3c1a4c
                       */
                      task_id?: string;
                      /** @description Describes the component to which the configurable parameters apply */
                      component?: string;
                      /**
                       * @description Describes the type of the configuration. Set to COMPONENT_PARAMETERS for a configuration that relates to a component.
                       * @enum {string}
                       */
                      type?: "COMPONENT_PARAMETERS";
                    }, {
                      workspace_id?: string;
                      /**
                       * @description Mongo ID of the object
                       * @example 60d31793d5f1fb7e6e3c1a4c
                       */
                      model_storage_id?: string;
                      /**
                       * @description Describes the type of the configurable parameters. For hyper parameters, type is set to HYPER_PARAMETERS.
                       * @enum {string}
                       */
                      type?: "HYPER_PARAMETERS";
                    }, {
                      workspace_id?: string;
                      /**
                       * @description Mongo ID of the object
                       * @example 60d31793d5f1fb7e6e3c1a4c
                       */
                      model_storage_id?: string;
                      /** @description Name of the hyper parameter group */
                      group_name?: string;
                      /**
                       * @description Describes the type of the component. For hyper parameter groups, type is always set to HYPER_PARAMETER_GROUP
                       * @enum {string}
                       */
                      type?: "HYPER_PARAMETER_GROUP";
                    }]>;
                    /**
                     * @description Name of the configuration
                     * @example Subset splitting
                     */
                    header?: string;
                    /**
                     * @description Description of the configuration, indicating which part of the system it controls.
                     * @example These parameters control the splitting of the dataset into training, validation and test set.
                     */
                    description?: string;
                    groups?: ({
                        /**
                         * @description Defines the parameter group
                         * @example Learning Parameters
                         */
                        header?: string;
                        /**
                         * @description Description of the parameter group
                         * @example Configuration to control training behaviour
                         */
                        description?: string;
                        /** @enum {string} */
                        type?: "PARAMETER_GROUP";
                        /** @description Name of the parameter group */
                        name?: string;
                        parameters?: ({
                            /** @description User friendly title for the parameter. */
                            header?: string;
                            /** @description User friendly description for what the parameter does. */
                            description?: string;
                            /** @description Warning message (if any) that explains the user to use caution when changing this parameter, and why. */
                            warning?: unknown;
                            /** @description Value that this parameter currently takes. */
                            value?: string | number | boolean;
                            /** @description Default value that should be set for this parameter. */
                            default_value?: string | number | boolean;
                            /** @description Name to identify the parameter by in the system. */
                            name?: string;
                            /**
                             * @description Describes the template type of the parameter. 'selectable' is used for parameters with a fixed set of possible values. 'input' is used for parameters that allow free input, possibly restricted to a certain range.
                             * @enum {string}
                             */
                            template_type?: "selectable" | "input";
                            /**
                             * @description Describes the type of parameter. Parameters can be integers, floats, boolean or string.
                             * @enum {string}
                             */
                            data_type?: "float" | "integer" | "boolean" | "string";
                            /** @description List of values that this parameter can take. Only used for selectable string and selectable float parameters */
                            options?: (number | string)[];
                            /**
                             * Format: float
                             * @description Minimum value that can be set for this parameter. Only used for numeric parameters.
                             */
                            min_value?: number;
                            /**
                             * Format: float
                             * @description Minimum value that can be set for this parameter. Only used for numeric parameters.
                             */
                            max_value?: number;
                            /** @description Not implemented at this moment */
                            ui_rules?: Record<string, never>;
                            /** @description Not implemented at this moment. */
                            editable?: boolean;
                          })[];
                      })[];
                    /** @description Array of configurable parameters */
                    parameters?: ({
                        /** @description User friendly title for the configurable boolean. */
                        header?: string;
                        /** @description User friendly description for what the boolean does. */
                        description?: string;
                        /** @description Warning message (if any) that explains the user to use caution when changing this parameter, and why. */
                        warning?: unknown;
                        /** @description Value that this boolean currently takes. */
                        value?: boolean;
                        /** @description Default value that should be set for this boolean. */
                        default_value?: boolean;
                        /** @description Name to identify the configurable boolean by in the system. */
                        name?: string;
                        /**
                         * @description Describes the template type of the parameter. 'selectable' is used for parameters with a fixed set of possible values. 'input' is used for parameters that allow free input, possibly restricted to a certain range. Template_type is always 'input' for a configurable boolean.
                         * @enum {string}
                         */
                        template_type?: "input";
                        /**
                         * @description Describes the type of parameter. Parameters can be integers, floats, boolean or string. Data_type is always 'boolean' for a configurable boolean.
                         * @enum {string}
                         */
                        data_type?: "boolean";
                        /** @description Not implemented at this moment */
                        ui_rules?: Record<string, never>;
                        /** @description Not implemented at this moment. */
                        editable?: boolean;
                      } | {
                        /** @description User friendly title for the float. */
                        header?: string;
                        /** @description User friendly description for what the float does. */
                        description?: string;
                        /** @description Warning message (if any) that explains the user to use caution when changing this parameter, and why. */
                        warning?: unknown;
                        /**
                         * Format: float
                         * @description Value that this configurable float currently takes.
                         */
                        value?: number;
                        /**
                         * Format: float
                         * @description Default value that should be set for this float.
                         */
                        default_value?: number;
                        /** @description Name to identify the configurable float by in the system. */
                        name?: string;
                        /**
                         * @description Describes the template type of the parameter. 'selectable' is used for parameters with a fixed set of possible values. 'input' is used for parameters that allow free input, possibly restricted to a certain range. Template_type is always 'input' for a configurable float.
                         * @enum {string}
                         */
                        template_type?: "input";
                        /**
                         * @description Describes the type of parameter. Parameters can be integers, floats, boolean or string. Data_type is always 'float' for a configurable float.
                         * @enum {string}
                         */
                        data_type?: "float";
                        /**
                         * Format: float
                         * @description Minimum value that can be set for this parameter.
                         */
                        min_value?: number;
                        /**
                         * Format: float
                         * @description Minimum value that can be set for this parameter.
                         */
                        max_value?: number;
                        /** @description Not implemented at this moment */
                        ui_rules?: Record<string, never>;
                        /** @description Not implemented at this moment. */
                        editable?: boolean;
                      } | {
                        /** @description User friendly title for the integer. */
                        header?: string;
                        /** @description User friendly description for what the integer does. */
                        description?: string;
                        /** @description Warning message (if any) that explains the user to use caution when changing this parameter, and why. */
                        warning?: unknown;
                        /** @description Value that this configurable integer currently takes. */
                        value?: number;
                        /** @description Default value that should be set for this integer. */
                        default_value?: number;
                        /** @description Name to identify the configurable integer by in the system. */
                        name?: string;
                        /**
                         * @description Describes the template type of the parameter. 'selectable' is used for parameters with a fixed set of possible values. 'input' is used for parameters that allow free input, possibly restricted to a certain range. Template_type is always 'input' for a configurable integer.
                         * @enum {string}
                         */
                        template_type?: "input";
                        /**
                         * @description Describes the type of parameter. Parameters can be integers, floats, boolean or string. Data_type is always 'integer' for a configurable integer.
                         * @enum {string}
                         */
                        data_type?: "integer";
                        /** @description Minimum value that can be set for this parameter. */
                        min_value?: number;
                        /** @description Minimum value that can be set for this parameter. */
                        max_value?: number;
                        /** @description Not implemented at this moment */
                        ui_rules?: Record<string, never>;
                        /** @description Not implemented at this moment. */
                        editable?: boolean;
                      } | {
                        /** @description User friendly title for the selectable string. */
                        header?: string;
                        /** @description User friendly description for what the selectable string parameter does. */
                        description?: string;
                        /** @description Warning message (if any) that explains the user to use caution when changing this parameter, and why. */
                        warning?: unknown;
                        /** @description Value that this selectable string currently takes. */
                        value?: string;
                        /** @description Default value that should be set for this selectable string. */
                        default_value?: string;
                        /** @description Name to identify the selectable string parameter by in the system. */
                        name?: string;
                        /**
                         * @description Describes the template type of the parameter. 'selectable' is used for parameters with a fixed set of possible values. 'input' is used for parameters that allow free input, possibly restricted to a certain range. Template_type is always 'selectable' for a selectable string parameter.
                         * @enum {string}
                         */
                        template_type?: "selectable";
                        /**
                         * @description Describes the type of parameter. Parameters can be integers, floats, boolean or string. Data_type is always 'string' for a selectable string parameter.
                         * @enum {string}
                         */
                        data_type?: "string";
                        /** @description List of values that this selectable string can take. */
                        options?: string[];
                        /** @description Not implemented at this moment */
                        ui_rules?: Record<string, never>;
                        /** @description Not implemented at this moment. */
                        editable?: boolean;
                      } | {
                        /** @description User friendly title for the selectable. */
                        header?: string;
                        /** @description User friendly description for what the selectable parameter does. */
                        description?: string;
                        /** @description Warning message (if any) that explains the user to use caution when changing this parameter, and why. */
                        warning?: unknown;
                        /** @description Value that this selectable currently takes. */
                        value?: string;
                        /** @description Default value that should be set for this selectable. */
                        default_value?: string;
                        /** @description Name to identify the selectable parameter by in the system. */
                        name?: string;
                        /**
                         * @description Describes the template type of the parameter. 'selectable' is used for parameters with a fixed set of possible values. 'input' is used for parameters that allow free input, possibly restricted to a certain range. Template_type is always 'selectable' for a selectable parameter.
                         * @enum {string}
                         */
                        template_type?: "selectable";
                        /**
                         * @description Describes the type of parameter. Parameters can be integers, floats, boolean or string. Data_type is always 'float' for a selectable float.
                         * @enum {string}
                         */
                        data_type?: "float";
                        /** @description List of values that this float selectable can take. */
                        options?: number[];
                        /** @description Not implemented at this moment */
                        ui_rules?: Record<string, never>;
                        /** @description Not implemented at this moment. */
                        editable?: boolean;
                      })[];
                  }) | ({
                    /**
                     * @description Mongo ID of the object
                     * @example 60d31793d5f1fb7e6e3c1a4c
                     */
                    id?: string;
                    entity_identifier?: OneOf<[{
                      workspace_id?: string;
                      /**
                       * @description Mongo ID of the object
                       * @example 60d31793d5f1fb7e6e3c1a4c
                       */
                      project_id?: string;
                      /**
                       * @description Mongo ID of the object
                       * @example 60d31793d5f1fb7e6e3c1a4c
                       */
                      task_id?: string;
                      /** @description Describes the component to which the configurable parameters apply */
                      component?: string;
                      /**
                       * @description Describes the type of the configuration. Set to COMPONENT_PARAMETERS for a configuration that relates to a component.
                       * @enum {string}
                       */
                      type?: "COMPONENT_PARAMETERS";
                    }, {
                      workspace_id?: string;
                      /**
                       * @description Mongo ID of the object
                       * @example 60d31793d5f1fb7e6e3c1a4c
                       */
                      model_storage_id?: string;
                      /**
                       * @description Describes the type of the configurable parameters. For hyper parameters, type is set to HYPER_PARAMETERS.
                       * @enum {string}
                       */
                      type?: "HYPER_PARAMETERS";
                    }, {
                      workspace_id?: string;
                      /**
                       * @description Mongo ID of the object
                       * @example 60d31793d5f1fb7e6e3c1a4c
                       */
                      model_storage_id?: string;
                      /** @description Name of the hyper parameter group */
                      group_name?: string;
                      /**
                       * @description Describes the type of the component. For hyper parameter groups, type is always set to HYPER_PARAMETER_GROUP
                       * @enum {string}
                       */
                      type?: "HYPER_PARAMETER_GROUP";
                    }]>;
                    /**
                     * @description Type of the configurable parameters. For hyper parameters the type is always 'CONFIGURABLE_PARAMETERS'.
                     * @enum {string}
                     */
                    type?: "CONFIGURABLE_PARAMETERS" | "PARAMETER_GROUP";
                    /**
                     * @description The name of the configuration
                     * @example Hyper parameters for a segmentation task
                     */
                    header?: string;
                    /**
                     * @description Description of model to which this configuration belongs
                     * @example Hyper parameters for a segmentation task
                     */
                    description?: string;
                    groups?: ({
                        /**
                         * @description Defines the parameter group
                         * @example Learning Parameters
                         */
                        header?: string;
                        /**
                         * @description Description of the parameter group
                         * @example Configuration to control training behaviour
                         */
                        description?: string;
                        /** @enum {string} */
                        type?: "PARAMETER_GROUP";
                        /** @description Name of the parameter group */
                        name?: string;
                        parameters?: ({
                            /** @description User friendly title for the parameter. */
                            header?: string;
                            /** @description User friendly description for what the parameter does. */
                            description?: string;
                            /** @description Warning message (if any) that explains the user to use caution when changing this parameter, and why. */
                            warning?: unknown;
                            /** @description Value that this parameter currently takes. */
                            value?: string | number | boolean;
                            /** @description Default value that should be set for this parameter. */
                            default_value?: string | number | boolean;
                            /** @description Name to identify the parameter by in the system. */
                            name?: string;
                            /**
                             * @description Describes the template type of the parameter. 'selectable' is used for parameters with a fixed set of possible values. 'input' is used for parameters that allow free input, possibly restricted to a certain range.
                             * @enum {string}
                             */
                            template_type?: "selectable" | "input";
                            /**
                             * @description Describes the type of parameter. Parameters can be integers, floats, boolean or string.
                             * @enum {string}
                             */
                            data_type?: "float" | "integer" | "boolean" | "string";
                            /** @description List of values that this parameter can take. Only used for selectable string and selectable float parameters */
                            options?: (number | string)[];
                            /**
                             * Format: float
                             * @description Minimum value that can be set for this parameter. Only used for numeric parameters.
                             */
                            min_value?: number;
                            /**
                             * Format: float
                             * @description Minimum value that can be set for this parameter. Only used for numeric parameters.
                             */
                            max_value?: number;
                            /** @description Not implemented at this moment */
                            ui_rules?: Record<string, never>;
                            /** @description Not implemented at this moment. */
                            editable?: boolean;
                          })[];
                      })[];
                    /** @description Array of configurable parameters */
                    parameters?: ({
                        /** @description User friendly title for the configurable boolean. */
                        header?: string;
                        /** @description User friendly description for what the boolean does. */
                        description?: string;
                        /** @description Warning message (if any) that explains the user to use caution when changing this parameter, and why. */
                        warning?: unknown;
                        /** @description Value that this boolean currently takes. */
                        value?: boolean;
                        /** @description Default value that should be set for this boolean. */
                        default_value?: boolean;
                        /** @description Name to identify the configurable boolean by in the system. */
                        name?: string;
                        /**
                         * @description Describes the template type of the parameter. 'selectable' is used for parameters with a fixed set of possible values. 'input' is used for parameters that allow free input, possibly restricted to a certain range. Template_type is always 'input' for a configurable boolean.
                         * @enum {string}
                         */
                        template_type?: "input";
                        /**
                         * @description Describes the type of parameter. Parameters can be integers, floats, boolean or string. Data_type is always 'boolean' for a configurable boolean.
                         * @enum {string}
                         */
                        data_type?: "boolean";
                        /** @description Not implemented at this moment */
                        ui_rules?: Record<string, never>;
                        /** @description Not implemented at this moment. */
                        editable?: boolean;
                      } | {
                        /** @description User friendly title for the float. */
                        header?: string;
                        /** @description User friendly description for what the float does. */
                        description?: string;
                        /** @description Warning message (if any) that explains the user to use caution when changing this parameter, and why. */
                        warning?: unknown;
                        /**
                         * Format: float
                         * @description Value that this configurable float currently takes.
                         */
                        value?: number;
                        /**
                         * Format: float
                         * @description Default value that should be set for this float.
                         */
                        default_value?: number;
                        /** @description Name to identify the configurable float by in the system. */
                        name?: string;
                        /**
                         * @description Describes the template type of the parameter. 'selectable' is used for parameters with a fixed set of possible values. 'input' is used for parameters that allow free input, possibly restricted to a certain range. Template_type is always 'input' for a configurable float.
                         * @enum {string}
                         */
                        template_type?: "input";
                        /**
                         * @description Describes the type of parameter. Parameters can be integers, floats, boolean or string. Data_type is always 'float' for a configurable float.
                         * @enum {string}
                         */
                        data_type?: "float";
                        /**
                         * Format: float
                         * @description Minimum value that can be set for this parameter.
                         */
                        min_value?: number;
                        /**
                         * Format: float
                         * @description Minimum value that can be set for this parameter.
                         */
                        max_value?: number;
                        /** @description Not implemented at this moment */
                        ui_rules?: Record<string, never>;
                        /** @description Not implemented at this moment. */
                        editable?: boolean;
                      } | {
                        /** @description User friendly title for the integer. */
                        header?: string;
                        /** @description User friendly description for what the integer does. */
                        description?: string;
                        /** @description Warning message (if any) that explains the user to use caution when changing this parameter, and why. */
                        warning?: unknown;
                        /** @description Value that this configurable integer currently takes. */
                        value?: number;
                        /** @description Default value that should be set for this integer. */
                        default_value?: number;
                        /** @description Name to identify the configurable integer by in the system. */
                        name?: string;
                        /**
                         * @description Describes the template type of the parameter. 'selectable' is used for parameters with a fixed set of possible values. 'input' is used for parameters that allow free input, possibly restricted to a certain range. Template_type is always 'input' for a configurable integer.
                         * @enum {string}
                         */
                        template_type?: "input";
                        /**
                         * @description Describes the type of parameter. Parameters can be integers, floats, boolean or string. Data_type is always 'integer' for a configurable integer.
                         * @enum {string}
                         */
                        data_type?: "integer";
                        /** @description Minimum value that can be set for this parameter. */
                        min_value?: number;
                        /** @description Minimum value that can be set for this parameter. */
                        max_value?: number;
                        /** @description Not implemented at this moment */
                        ui_rules?: Record<string, never>;
                        /** @description Not implemented at this moment. */
                        editable?: boolean;
                      } | {
                        /** @description User friendly title for the selectable string. */
                        header?: string;
                        /** @description User friendly description for what the selectable string parameter does. */
                        description?: string;
                        /** @description Warning message (if any) that explains the user to use caution when changing this parameter, and why. */
                        warning?: unknown;
                        /** @description Value that this selectable string currently takes. */
                        value?: string;
                        /** @description Default value that should be set for this selectable string. */
                        default_value?: string;
                        /** @description Name to identify the selectable string parameter by in the system. */
                        name?: string;
                        /**
                         * @description Describes the template type of the parameter. 'selectable' is used for parameters with a fixed set of possible values. 'input' is used for parameters that allow free input, possibly restricted to a certain range. Template_type is always 'selectable' for a selectable string parameter.
                         * @enum {string}
                         */
                        template_type?: "selectable";
                        /**
                         * @description Describes the type of parameter. Parameters can be integers, floats, boolean or string. Data_type is always 'string' for a selectable string parameter.
                         * @enum {string}
                         */
                        data_type?: "string";
                        /** @description List of values that this selectable string can take. */
                        options?: string[];
                        /** @description Not implemented at this moment */
                        ui_rules?: Record<string, never>;
                        /** @description Not implemented at this moment. */
                        editable?: boolean;
                      } | {
                        /** @description User friendly title for the selectable. */
                        header?: string;
                        /** @description User friendly description for what the selectable parameter does. */
                        description?: string;
                        /** @description Warning message (if any) that explains the user to use caution when changing this parameter, and why. */
                        warning?: unknown;
                        /** @description Value that this selectable currently takes. */
                        value?: string;
                        /** @description Default value that should be set for this selectable. */
                        default_value?: string;
                        /** @description Name to identify the selectable parameter by in the system. */
                        name?: string;
                        /**
                         * @description Describes the template type of the parameter. 'selectable' is used for parameters with a fixed set of possible values. 'input' is used for parameters that allow free input, possibly restricted to a certain range. Template_type is always 'selectable' for a selectable parameter.
                         * @enum {string}
                         */
                        template_type?: "selectable";
                        /**
                         * @description Describes the type of parameter. Parameters can be integers, floats, boolean or string. Data_type is always 'float' for a selectable float.
                         * @enum {string}
                         */
                        data_type?: "float";
                        /** @description List of values that this float selectable can take. */
                        options?: number[];
                        /** @description Not implemented at this moment */
                        ui_rules?: Record<string, never>;
                        /** @description Not implemented at this moment. */
                        editable?: boolean;
                      })[];
                  }))[];
                /**
                 * @description Mongo ID of the object
                 * @example 60d31793d5f1fb7e6e3c1a4c
                 */
                task_id?: string;
                /** @description Title of the task the configuration is connected to */
                task_title?: string;
              })[];
          };
        };
      };
      /** @description Object not found. See the examples for details. */
      404: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 400 | 404 | 405 | 409 | 412 | 413 | 415 | 422 | 423 | 500 | 501 | 503;
            /** @description Message from server */
            message: string;
            /** @description Error code from server */
            error_code: string;
          };
        };
      };
    };
  };
  /**
   * Set the configuration for all tasks in the projects' task chain.
   * @description This endpoint sets the configuration for the entire task chain. For every task in the chain, the configuration is subdivided into components, and every component is divided into parameter groups.
   */
  SetTaskChainConfiguration: {
    parameters: {
      path: {
        /** @description The ID of the organization. */
        organization_id: string;
        /** @description The ID of the workspace. */
        workspace_id: string;
        /** @description The ID of the project. */
        project_id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": {
          /** @description Array of task configurations */
          task_chain: ({
              /** @description Array of configurable parameter objects for the different components in the task, as well as the hyper parameters for the current algorithm in the task */
              components: ({
                  entity_identifier: OneOf<[{
                    workspace_id?: string;
                    /**
                     * @description Mongo ID of the object
                     * @example 60d31793d5f1fb7e6e3c1a4c
                     */
                    project_id?: string;
                    /**
                     * @description Mongo ID of the task
                     * @example 60d31793d5f1fb7e6e3c1a4c
                     */
                    task_id?: string;
                    /**
                     * @description If the configuration is a component configuration, describes the component.
                     * @enum {string}
                     */
                    component: "NULL_COMPONENT" | "SUBSET_MANAGER" | "DATASET_COUNTER" | "PROJECT_ACTIVE_LEARNING" | "TASK_ACTIVE_LEARNING" | "TASK_NODE" | "PIPELINE_DATASET_MANAGER";
                    /**
                     * @description Describes the type of the configuration. Set to COMPONENT_PARAMETERS for a configuration that relates to a component.
                     * @enum {string}
                     */
                    type: "COMPONENT_PARAMETERS";
                  }, {
                    workspace_id?: string;
                    /**
                     * @description Mongo ID of the object
                     * @example 60d31793d5f1fb7e6e3c1a4c
                     */
                    model_storage_id: string;
                    /**
                     * @description Describes the type of the configurable parameters. For hyper parameters, type is set to HYPER_PARAMETERS.
                     * @enum {string}
                     */
                    type: "HYPER_PARAMETERS";
                  }, {
                    workspace_id?: string;
                    /**
                     * @description Mongo ID of the object
                     * @example 60d31793d5f1fb7e6e3c1a4c
                     */
                    model_storage_id: string;
                    /** @description The name of the hyper parameter group */
                    group_name: string;
                    /**
                     * @description Describes the type of the component. For hyper parameter groups, type is always set to HYPER_PARAMETER_GROUP
                     * @enum {string}
                     */
                    type: "HYPER_PARAMETER_GROUP";
                  }]>;
                  groups?: ({
                      /** @description Name of the parameter group */
                      name: string;
                      /** @description Array of parameters */
                      parameters: ({
                          /** @description Value to set the parameter to. */
                          value: string | number | boolean;
                          /** @description Name to identify the parameter by in the system. */
                          name: string;
                        })[];
                    })[];
                  parameters?: ({
                      /** @description Value to set the parameter to. */
                      value: string | number | boolean;
                      /** @description Name to identify the parameter by in the system. */
                      name: string;
                    })[];
                })[];
            })[];
        };
      };
    };
    responses: {
      /** @description Configuration updated successfully */
      200: {
        content: {
          "application/json": unknown;
        };
      };
      /** @description Object not found. See the examples for details. */
      404: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 400 | 404 | 405 | 409 | 412 | 413 | 415 | 422 | 423 | 500 | 501 | 503;
            /** @description Message from server */
            message: string;
            /** @description Error code from server */
            error_code: string;
          };
        };
      };
      /** @description Configuration cannot be saved to the server */
      500: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 400 | 404 | 405 | 409 | 412 | 413 | 415 | 422 | 423 | 500 | 501 | 503;
            /** @description Message from server */
            message: string;
            /** @description Error code from server */
            error_code: string;
          };
        };
      };
    };
  };
  /**
   * Get the current configuration for a specific task
   * @description This endpoint pulls the configuration for a specific task. The configuration is subdivided into components, and every component is divided into parameter groups. This endpoint can also be used to pull the configurable parameters related to a single model or an algorithm, from a trainable task.
   */
  GetTaskConfiguration: {
    parameters: {
      query?: {
        /** @description The ID of the model of interest */
        model_id?: string;
        /** @description The name of the algorithm for which we want to pull the configurable parameters */
        algorithm_name?: string;
      };
      path: {
        /** @description The ID of the organization. */
        organization_id: string;
        /** @description The ID of the workspace. */
        workspace_id: string;
        /** @description The ID of the project. */
        project_id: string;
        /** @description The ID of the task of interest. */
        task_id: string;
      };
    };
    responses: {
      /** @description Get configuration response */
      200: {
        content: {
          "application/json": {
            /** @description Array of configurable parameter objects for the different components in the task, as well as the hyper parameters for the current algorithm in the task */
            components?: (({
                /** @description Name of the hyper parameter group */
                name?: string;
                /**
                 * @description ID of the hyper parameter group. The first 24 characters refer to the ID of the underlying HyperParameter object. This is followed by a dash ('-') and the group number (0 to 99) of this particular hyper parameter group.
                 * @example 60d31793d5f1fb7e6e3c1a4c-1
                 */
                id?: string;
                /**
                 * @description Type of the configurable parameters. For a hyper parameter group the type is always 'PARAMETER_GROUP'.
                 * @enum {string}
                 */
                type?: "CONFIGURABLE_PARAMETERS" | "PARAMETER_GROUP";
                entity_identifier?: OneOf<[{
                  workspace_id?: string;
                  /**
                   * @description Mongo ID of the object
                   * @example 60d31793d5f1fb7e6e3c1a4c
                   */
                  project_id?: string;
                  /**
                   * @description Mongo ID of the object
                   * @example 60d31793d5f1fb7e6e3c1a4c
                   */
                  task_id?: string;
                  /** @description Describes the component to which the configurable parameters apply */
                  component?: string;
                  /**
                   * @description Describes the type of the configuration. Set to COMPONENT_PARAMETERS for a configuration that relates to a component.
                   * @enum {string}
                   */
                  type?: "COMPONENT_PARAMETERS";
                }, {
                  workspace_id?: string;
                  /**
                   * @description Mongo ID of the object
                   * @example 60d31793d5f1fb7e6e3c1a4c
                   */
                  model_storage_id?: string;
                  /**
                   * @description Describes the type of the configurable parameters. For hyper parameters, type is set to HYPER_PARAMETERS.
                   * @enum {string}
                   */
                  type?: "HYPER_PARAMETERS";
                }, {
                  workspace_id?: string;
                  /**
                   * @description Mongo ID of the object
                   * @example 60d31793d5f1fb7e6e3c1a4c
                   */
                  model_storage_id?: string;
                  /** @description Name of the hyper parameter group */
                  group_name?: string;
                  /**
                   * @description Describes the type of the component. For hyper parameter groups, type is always set to HYPER_PARAMETER_GROUP
                   * @enum {string}
                   */
                  type?: "HYPER_PARAMETER_GROUP";
                }]>;
                /**
                 * @description The name of the hyper parameter group
                 * @example Learning parameters
                 */
                header?: string;
                /**
                 * @description Description of the hyper parameter group.
                 * @example A set of parameters that control the training process.
                 */
                description?: string;
                groups?: ({
                    /**
                     * @description Defines the parameter group
                     * @example Learning Parameters
                     */
                    header?: string;
                    /**
                     * @description Description of the parameter group
                     * @example Configuration to control training behaviour
                     */
                    description?: string;
                    /** @enum {string} */
                    type?: "PARAMETER_GROUP";
                    /** @description Name of the parameter group */
                    name?: string;
                    parameters?: ({
                        /** @description User friendly title for the parameter. */
                        header?: string;
                        /** @description User friendly description for what the parameter does. */
                        description?: string;
                        /** @description Warning message (if any) that explains the user to use caution when changing this parameter, and why. */
                        warning?: unknown;
                        /** @description Value that this parameter currently takes. */
                        value?: string | number | boolean;
                        /** @description Default value that should be set for this parameter. */
                        default_value?: string | number | boolean;
                        /** @description Name to identify the parameter by in the system. */
                        name?: string;
                        /**
                         * @description Describes the template type of the parameter. 'selectable' is used for parameters with a fixed set of possible values. 'input' is used for parameters that allow free input, possibly restricted to a certain range.
                         * @enum {string}
                         */
                        template_type?: "selectable" | "input";
                        /**
                         * @description Describes the type of parameter. Parameters can be integers, floats, boolean or string.
                         * @enum {string}
                         */
                        data_type?: "float" | "integer" | "boolean" | "string";
                        /** @description List of values that this parameter can take. Only used for selectable string and selectable float parameters */
                        options?: (number | string)[];
                        /**
                         * Format: float
                         * @description Minimum value that can be set for this parameter. Only used for numeric parameters.
                         */
                        min_value?: number;
                        /**
                         * Format: float
                         * @description Minimum value that can be set for this parameter. Only used for numeric parameters.
                         */
                        max_value?: number;
                        /** @description Not implemented at this moment */
                        ui_rules?: Record<string, never>;
                        /** @description Not implemented at this moment. */
                        editable?: boolean;
                      })[];
                  })[];
                /** @description Array of configurable parameters */
                parameters?: ({
                    /** @description User friendly title for the configurable boolean. */
                    header?: string;
                    /** @description User friendly description for what the boolean does. */
                    description?: string;
                    /** @description Warning message (if any) that explains the user to use caution when changing this parameter, and why. */
                    warning?: unknown;
                    /** @description Value that this boolean currently takes. */
                    value?: boolean;
                    /** @description Default value that should be set for this boolean. */
                    default_value?: boolean;
                    /** @description Name to identify the configurable boolean by in the system. */
                    name?: string;
                    /**
                     * @description Describes the template type of the parameter. 'selectable' is used for parameters with a fixed set of possible values. 'input' is used for parameters that allow free input, possibly restricted to a certain range. Template_type is always 'input' for a configurable boolean.
                     * @enum {string}
                     */
                    template_type?: "input";
                    /**
                     * @description Describes the type of parameter. Parameters can be integers, floats, boolean or string. Data_type is always 'boolean' for a configurable boolean.
                     * @enum {string}
                     */
                    data_type?: "boolean";
                    /** @description Not implemented at this moment */
                    ui_rules?: Record<string, never>;
                    /** @description Not implemented at this moment. */
                    editable?: boolean;
                  } | {
                    /** @description User friendly title for the float. */
                    header?: string;
                    /** @description User friendly description for what the float does. */
                    description?: string;
                    /** @description Warning message (if any) that explains the user to use caution when changing this parameter, and why. */
                    warning?: unknown;
                    /**
                     * Format: float
                     * @description Value that this configurable float currently takes.
                     */
                    value?: number;
                    /**
                     * Format: float
                     * @description Default value that should be set for this float.
                     */
                    default_value?: number;
                    /** @description Name to identify the configurable float by in the system. */
                    name?: string;
                    /**
                     * @description Describes the template type of the parameter. 'selectable' is used for parameters with a fixed set of possible values. 'input' is used for parameters that allow free input, possibly restricted to a certain range. Template_type is always 'input' for a configurable float.
                     * @enum {string}
                     */
                    template_type?: "input";
                    /**
                     * @description Describes the type of parameter. Parameters can be integers, floats, boolean or string. Data_type is always 'float' for a configurable float.
                     * @enum {string}
                     */
                    data_type?: "float";
                    /**
                     * Format: float
                     * @description Minimum value that can be set for this parameter.
                     */
                    min_value?: number;
                    /**
                     * Format: float
                     * @description Minimum value that can be set for this parameter.
                     */
                    max_value?: number;
                    /** @description Not implemented at this moment */
                    ui_rules?: Record<string, never>;
                    /** @description Not implemented at this moment. */
                    editable?: boolean;
                  } | {
                    /** @description User friendly title for the integer. */
                    header?: string;
                    /** @description User friendly description for what the integer does. */
                    description?: string;
                    /** @description Warning message (if any) that explains the user to use caution when changing this parameter, and why. */
                    warning?: unknown;
                    /** @description Value that this configurable integer currently takes. */
                    value?: number;
                    /** @description Default value that should be set for this integer. */
                    default_value?: number;
                    /** @description Name to identify the configurable integer by in the system. */
                    name?: string;
                    /**
                     * @description Describes the template type of the parameter. 'selectable' is used for parameters with a fixed set of possible values. 'input' is used for parameters that allow free input, possibly restricted to a certain range. Template_type is always 'input' for a configurable integer.
                     * @enum {string}
                     */
                    template_type?: "input";
                    /**
                     * @description Describes the type of parameter. Parameters can be integers, floats, boolean or string. Data_type is always 'integer' for a configurable integer.
                     * @enum {string}
                     */
                    data_type?: "integer";
                    /** @description Minimum value that can be set for this parameter. */
                    min_value?: number;
                    /** @description Minimum value that can be set for this parameter. */
                    max_value?: number;
                    /** @description Not implemented at this moment */
                    ui_rules?: Record<string, never>;
                    /** @description Not implemented at this moment. */
                    editable?: boolean;
                  } | {
                    /** @description User friendly title for the selectable string. */
                    header?: string;
                    /** @description User friendly description for what the selectable string parameter does. */
                    description?: string;
                    /** @description Warning message (if any) that explains the user to use caution when changing this parameter, and why. */
                    warning?: unknown;
                    /** @description Value that this selectable string currently takes. */
                    value?: string;
                    /** @description Default value that should be set for this selectable string. */
                    default_value?: string;
                    /** @description Name to identify the selectable string parameter by in the system. */
                    name?: string;
                    /**
                     * @description Describes the template type of the parameter. 'selectable' is used for parameters with a fixed set of possible values. 'input' is used for parameters that allow free input, possibly restricted to a certain range. Template_type is always 'selectable' for a selectable string parameter.
                     * @enum {string}
                     */
                    template_type?: "selectable";
                    /**
                     * @description Describes the type of parameter. Parameters can be integers, floats, boolean or string. Data_type is always 'string' for a selectable string parameter.
                     * @enum {string}
                     */
                    data_type?: "string";
                    /** @description List of values that this selectable string can take. */
                    options?: string[];
                    /** @description Not implemented at this moment */
                    ui_rules?: Record<string, never>;
                    /** @description Not implemented at this moment. */
                    editable?: boolean;
                  } | {
                    /** @description User friendly title for the selectable. */
                    header?: string;
                    /** @description User friendly description for what the selectable parameter does. */
                    description?: string;
                    /** @description Warning message (if any) that explains the user to use caution when changing this parameter, and why. */
                    warning?: unknown;
                    /** @description Value that this selectable currently takes. */
                    value?: string;
                    /** @description Default value that should be set for this selectable. */
                    default_value?: string;
                    /** @description Name to identify the selectable parameter by in the system. */
                    name?: string;
                    /**
                     * @description Describes the template type of the parameter. 'selectable' is used for parameters with a fixed set of possible values. 'input' is used for parameters that allow free input, possibly restricted to a certain range. Template_type is always 'selectable' for a selectable parameter.
                     * @enum {string}
                     */
                    template_type?: "selectable";
                    /**
                     * @description Describes the type of parameter. Parameters can be integers, floats, boolean or string. Data_type is always 'float' for a selectable float.
                     * @enum {string}
                     */
                    data_type?: "float";
                    /** @description List of values that this float selectable can take. */
                    options?: number[];
                    /** @description Not implemented at this moment */
                    ui_rules?: Record<string, never>;
                    /** @description Not implemented at this moment. */
                    editable?: boolean;
                  })[];
              }) | ({
                /**
                 * @description Mongo ID of the object
                 * @example 60d31793d5f1fb7e6e3c1a4c
                 */
                id?: string;
                /**
                 * @description Type of the configurable parameters. For component parameters the type is always 'CONFIGURABLE_PARAMETERS'.
                 * @enum {string}
                 */
                type?: "CONFIGURABLE_PARAMETERS" | "PARAMETER_GROUP";
                entity_identifier?: OneOf<[{
                  workspace_id?: string;
                  /**
                   * @description Mongo ID of the object
                   * @example 60d31793d5f1fb7e6e3c1a4c
                   */
                  project_id?: string;
                  /**
                   * @description Mongo ID of the object
                   * @example 60d31793d5f1fb7e6e3c1a4c
                   */
                  task_id?: string;
                  /** @description Describes the component to which the configurable parameters apply */
                  component?: string;
                  /**
                   * @description Describes the type of the configuration. Set to COMPONENT_PARAMETERS for a configuration that relates to a component.
                   * @enum {string}
                   */
                  type?: "COMPONENT_PARAMETERS";
                }, {
                  workspace_id?: string;
                  /**
                   * @description Mongo ID of the object
                   * @example 60d31793d5f1fb7e6e3c1a4c
                   */
                  model_storage_id?: string;
                  /**
                   * @description Describes the type of the configurable parameters. For hyper parameters, type is set to HYPER_PARAMETERS.
                   * @enum {string}
                   */
                  type?: "HYPER_PARAMETERS";
                }, {
                  workspace_id?: string;
                  /**
                   * @description Mongo ID of the object
                   * @example 60d31793d5f1fb7e6e3c1a4c
                   */
                  model_storage_id?: string;
                  /** @description Name of the hyper parameter group */
                  group_name?: string;
                  /**
                   * @description Describes the type of the component. For hyper parameter groups, type is always set to HYPER_PARAMETER_GROUP
                   * @enum {string}
                   */
                  type?: "HYPER_PARAMETER_GROUP";
                }]>;
                /**
                 * @description Name of the configuration
                 * @example Subset splitting
                 */
                header?: string;
                /**
                 * @description Description of the configuration, indicating which part of the system it controls.
                 * @example These parameters control the splitting of the dataset into training, validation and test set.
                 */
                description?: string;
                groups?: ({
                    /**
                     * @description Defines the parameter group
                     * @example Learning Parameters
                     */
                    header?: string;
                    /**
                     * @description Description of the parameter group
                     * @example Configuration to control training behaviour
                     */
                    description?: string;
                    /** @enum {string} */
                    type?: "PARAMETER_GROUP";
                    /** @description Name of the parameter group */
                    name?: string;
                    parameters?: ({
                        /** @description User friendly title for the parameter. */
                        header?: string;
                        /** @description User friendly description for what the parameter does. */
                        description?: string;
                        /** @description Warning message (if any) that explains the user to use caution when changing this parameter, and why. */
                        warning?: unknown;
                        /** @description Value that this parameter currently takes. */
                        value?: string | number | boolean;
                        /** @description Default value that should be set for this parameter. */
                        default_value?: string | number | boolean;
                        /** @description Name to identify the parameter by in the system. */
                        name?: string;
                        /**
                         * @description Describes the template type of the parameter. 'selectable' is used for parameters with a fixed set of possible values. 'input' is used for parameters that allow free input, possibly restricted to a certain range.
                         * @enum {string}
                         */
                        template_type?: "selectable" | "input";
                        /**
                         * @description Describes the type of parameter. Parameters can be integers, floats, boolean or string.
                         * @enum {string}
                         */
                        data_type?: "float" | "integer" | "boolean" | "string";
                        /** @description List of values that this parameter can take. Only used for selectable string and selectable float parameters */
                        options?: (number | string)[];
                        /**
                         * Format: float
                         * @description Minimum value that can be set for this parameter. Only used for numeric parameters.
                         */
                        min_value?: number;
                        /**
                         * Format: float
                         * @description Minimum value that can be set for this parameter. Only used for numeric parameters.
                         */
                        max_value?: number;
                        /** @description Not implemented at this moment */
                        ui_rules?: Record<string, never>;
                        /** @description Not implemented at this moment. */
                        editable?: boolean;
                      })[];
                  })[];
                /** @description Array of configurable parameters */
                parameters?: ({
                    /** @description User friendly title for the configurable boolean. */
                    header?: string;
                    /** @description User friendly description for what the boolean does. */
                    description?: string;
                    /** @description Warning message (if any) that explains the user to use caution when changing this parameter, and why. */
                    warning?: unknown;
                    /** @description Value that this boolean currently takes. */
                    value?: boolean;
                    /** @description Default value that should be set for this boolean. */
                    default_value?: boolean;
                    /** @description Name to identify the configurable boolean by in the system. */
                    name?: string;
                    /**
                     * @description Describes the template type of the parameter. 'selectable' is used for parameters with a fixed set of possible values. 'input' is used for parameters that allow free input, possibly restricted to a certain range. Template_type is always 'input' for a configurable boolean.
                     * @enum {string}
                     */
                    template_type?: "input";
                    /**
                     * @description Describes the type of parameter. Parameters can be integers, floats, boolean or string. Data_type is always 'boolean' for a configurable boolean.
                     * @enum {string}
                     */
                    data_type?: "boolean";
                    /** @description Not implemented at this moment */
                    ui_rules?: Record<string, never>;
                    /** @description Not implemented at this moment. */
                    editable?: boolean;
                  } | {
                    /** @description User friendly title for the float. */
                    header?: string;
                    /** @description User friendly description for what the float does. */
                    description?: string;
                    /** @description Warning message (if any) that explains the user to use caution when changing this parameter, and why. */
                    warning?: unknown;
                    /**
                     * Format: float
                     * @description Value that this configurable float currently takes.
                     */
                    value?: number;
                    /**
                     * Format: float
                     * @description Default value that should be set for this float.
                     */
                    default_value?: number;
                    /** @description Name to identify the configurable float by in the system. */
                    name?: string;
                    /**
                     * @description Describes the template type of the parameter. 'selectable' is used for parameters with a fixed set of possible values. 'input' is used for parameters that allow free input, possibly restricted to a certain range. Template_type is always 'input' for a configurable float.
                     * @enum {string}
                     */
                    template_type?: "input";
                    /**
                     * @description Describes the type of parameter. Parameters can be integers, floats, boolean or string. Data_type is always 'float' for a configurable float.
                     * @enum {string}
                     */
                    data_type?: "float";
                    /**
                     * Format: float
                     * @description Minimum value that can be set for this parameter.
                     */
                    min_value?: number;
                    /**
                     * Format: float
                     * @description Minimum value that can be set for this parameter.
                     */
                    max_value?: number;
                    /** @description Not implemented at this moment */
                    ui_rules?: Record<string, never>;
                    /** @description Not implemented at this moment. */
                    editable?: boolean;
                  } | {
                    /** @description User friendly title for the integer. */
                    header?: string;
                    /** @description User friendly description for what the integer does. */
                    description?: string;
                    /** @description Warning message (if any) that explains the user to use caution when changing this parameter, and why. */
                    warning?: unknown;
                    /** @description Value that this configurable integer currently takes. */
                    value?: number;
                    /** @description Default value that should be set for this integer. */
                    default_value?: number;
                    /** @description Name to identify the configurable integer by in the system. */
                    name?: string;
                    /**
                     * @description Describes the template type of the parameter. 'selectable' is used for parameters with a fixed set of possible values. 'input' is used for parameters that allow free input, possibly restricted to a certain range. Template_type is always 'input' for a configurable integer.
                     * @enum {string}
                     */
                    template_type?: "input";
                    /**
                     * @description Describes the type of parameter. Parameters can be integers, floats, boolean or string. Data_type is always 'integer' for a configurable integer.
                     * @enum {string}
                     */
                    data_type?: "integer";
                    /** @description Minimum value that can be set for this parameter. */
                    min_value?: number;
                    /** @description Minimum value that can be set for this parameter. */
                    max_value?: number;
                    /** @description Not implemented at this moment */
                    ui_rules?: Record<string, never>;
                    /** @description Not implemented at this moment. */
                    editable?: boolean;
                  } | {
                    /** @description User friendly title for the selectable string. */
                    header?: string;
                    /** @description User friendly description for what the selectable string parameter does. */
                    description?: string;
                    /** @description Warning message (if any) that explains the user to use caution when changing this parameter, and why. */
                    warning?: unknown;
                    /** @description Value that this selectable string currently takes. */
                    value?: string;
                    /** @description Default value that should be set for this selectable string. */
                    default_value?: string;
                    /** @description Name to identify the selectable string parameter by in the system. */
                    name?: string;
                    /**
                     * @description Describes the template type of the parameter. 'selectable' is used for parameters with a fixed set of possible values. 'input' is used for parameters that allow free input, possibly restricted to a certain range. Template_type is always 'selectable' for a selectable string parameter.
                     * @enum {string}
                     */
                    template_type?: "selectable";
                    /**
                     * @description Describes the type of parameter. Parameters can be integers, floats, boolean or string. Data_type is always 'string' for a selectable string parameter.
                     * @enum {string}
                     */
                    data_type?: "string";
                    /** @description List of values that this selectable string can take. */
                    options?: string[];
                    /** @description Not implemented at this moment */
                    ui_rules?: Record<string, never>;
                    /** @description Not implemented at this moment. */
                    editable?: boolean;
                  } | {
                    /** @description User friendly title for the selectable. */
                    header?: string;
                    /** @description User friendly description for what the selectable parameter does. */
                    description?: string;
                    /** @description Warning message (if any) that explains the user to use caution when changing this parameter, and why. */
                    warning?: unknown;
                    /** @description Value that this selectable currently takes. */
                    value?: string;
                    /** @description Default value that should be set for this selectable. */
                    default_value?: string;
                    /** @description Name to identify the selectable parameter by in the system. */
                    name?: string;
                    /**
                     * @description Describes the template type of the parameter. 'selectable' is used for parameters with a fixed set of possible values. 'input' is used for parameters that allow free input, possibly restricted to a certain range. Template_type is always 'selectable' for a selectable parameter.
                     * @enum {string}
                     */
                    template_type?: "selectable";
                    /**
                     * @description Describes the type of parameter. Parameters can be integers, floats, boolean or string. Data_type is always 'float' for a selectable float.
                     * @enum {string}
                     */
                    data_type?: "float";
                    /** @description List of values that this float selectable can take. */
                    options?: number[];
                    /** @description Not implemented at this moment */
                    ui_rules?: Record<string, never>;
                    /** @description Not implemented at this moment. */
                    editable?: boolean;
                  })[];
              }) | ({
                /**
                 * @description Mongo ID of the object
                 * @example 60d31793d5f1fb7e6e3c1a4c
                 */
                id?: string;
                entity_identifier?: OneOf<[{
                  workspace_id?: string;
                  /**
                   * @description Mongo ID of the object
                   * @example 60d31793d5f1fb7e6e3c1a4c
                   */
                  project_id?: string;
                  /**
                   * @description Mongo ID of the object
                   * @example 60d31793d5f1fb7e6e3c1a4c
                   */
                  task_id?: string;
                  /** @description Describes the component to which the configurable parameters apply */
                  component?: string;
                  /**
                   * @description Describes the type of the configuration. Set to COMPONENT_PARAMETERS for a configuration that relates to a component.
                   * @enum {string}
                   */
                  type?: "COMPONENT_PARAMETERS";
                }, {
                  workspace_id?: string;
                  /**
                   * @description Mongo ID of the object
                   * @example 60d31793d5f1fb7e6e3c1a4c
                   */
                  model_storage_id?: string;
                  /**
                   * @description Describes the type of the configurable parameters. For hyper parameters, type is set to HYPER_PARAMETERS.
                   * @enum {string}
                   */
                  type?: "HYPER_PARAMETERS";
                }, {
                  workspace_id?: string;
                  /**
                   * @description Mongo ID of the object
                   * @example 60d31793d5f1fb7e6e3c1a4c
                   */
                  model_storage_id?: string;
                  /** @description Name of the hyper parameter group */
                  group_name?: string;
                  /**
                   * @description Describes the type of the component. For hyper parameter groups, type is always set to HYPER_PARAMETER_GROUP
                   * @enum {string}
                   */
                  type?: "HYPER_PARAMETER_GROUP";
                }]>;
                /**
                 * @description Type of the configurable parameters. For hyper parameters the type is always 'CONFIGURABLE_PARAMETERS'.
                 * @enum {string}
                 */
                type?: "CONFIGURABLE_PARAMETERS" | "PARAMETER_GROUP";
                /**
                 * @description The name of the configuration
                 * @example Hyper parameters for a segmentation task
                 */
                header?: string;
                /**
                 * @description Description of model to which this configuration belongs
                 * @example Hyper parameters for a segmentation task
                 */
                description?: string;
                groups?: ({
                    /**
                     * @description Defines the parameter group
                     * @example Learning Parameters
                     */
                    header?: string;
                    /**
                     * @description Description of the parameter group
                     * @example Configuration to control training behaviour
                     */
                    description?: string;
                    /** @enum {string} */
                    type?: "PARAMETER_GROUP";
                    /** @description Name of the parameter group */
                    name?: string;
                    parameters?: ({
                        /** @description User friendly title for the parameter. */
                        header?: string;
                        /** @description User friendly description for what the parameter does. */
                        description?: string;
                        /** @description Warning message (if any) that explains the user to use caution when changing this parameter, and why. */
                        warning?: unknown;
                        /** @description Value that this parameter currently takes. */
                        value?: string | number | boolean;
                        /** @description Default value that should be set for this parameter. */
                        default_value?: string | number | boolean;
                        /** @description Name to identify the parameter by in the system. */
                        name?: string;
                        /**
                         * @description Describes the template type of the parameter. 'selectable' is used for parameters with a fixed set of possible values. 'input' is used for parameters that allow free input, possibly restricted to a certain range.
                         * @enum {string}
                         */
                        template_type?: "selectable" | "input";
                        /**
                         * @description Describes the type of parameter. Parameters can be integers, floats, boolean or string.
                         * @enum {string}
                         */
                        data_type?: "float" | "integer" | "boolean" | "string";
                        /** @description List of values that this parameter can take. Only used for selectable string and selectable float parameters */
                        options?: (number | string)[];
                        /**
                         * Format: float
                         * @description Minimum value that can be set for this parameter. Only used for numeric parameters.
                         */
                        min_value?: number;
                        /**
                         * Format: float
                         * @description Minimum value that can be set for this parameter. Only used for numeric parameters.
                         */
                        max_value?: number;
                        /** @description Not implemented at this moment */
                        ui_rules?: Record<string, never>;
                        /** @description Not implemented at this moment. */
                        editable?: boolean;
                      })[];
                  })[];
                /** @description Array of configurable parameters */
                parameters?: ({
                    /** @description User friendly title for the configurable boolean. */
                    header?: string;
                    /** @description User friendly description for what the boolean does. */
                    description?: string;
                    /** @description Warning message (if any) that explains the user to use caution when changing this parameter, and why. */
                    warning?: unknown;
                    /** @description Value that this boolean currently takes. */
                    value?: boolean;
                    /** @description Default value that should be set for this boolean. */
                    default_value?: boolean;
                    /** @description Name to identify the configurable boolean by in the system. */
                    name?: string;
                    /**
                     * @description Describes the template type of the parameter. 'selectable' is used for parameters with a fixed set of possible values. 'input' is used for parameters that allow free input, possibly restricted to a certain range. Template_type is always 'input' for a configurable boolean.
                     * @enum {string}
                     */
                    template_type?: "input";
                    /**
                     * @description Describes the type of parameter. Parameters can be integers, floats, boolean or string. Data_type is always 'boolean' for a configurable boolean.
                     * @enum {string}
                     */
                    data_type?: "boolean";
                    /** @description Not implemented at this moment */
                    ui_rules?: Record<string, never>;
                    /** @description Not implemented at this moment. */
                    editable?: boolean;
                  } | {
                    /** @description User friendly title for the float. */
                    header?: string;
                    /** @description User friendly description for what the float does. */
                    description?: string;
                    /** @description Warning message (if any) that explains the user to use caution when changing this parameter, and why. */
                    warning?: unknown;
                    /**
                     * Format: float
                     * @description Value that this configurable float currently takes.
                     */
                    value?: number;
                    /**
                     * Format: float
                     * @description Default value that should be set for this float.
                     */
                    default_value?: number;
                    /** @description Name to identify the configurable float by in the system. */
                    name?: string;
                    /**
                     * @description Describes the template type of the parameter. 'selectable' is used for parameters with a fixed set of possible values. 'input' is used for parameters that allow free input, possibly restricted to a certain range. Template_type is always 'input' for a configurable float.
                     * @enum {string}
                     */
                    template_type?: "input";
                    /**
                     * @description Describes the type of parameter. Parameters can be integers, floats, boolean or string. Data_type is always 'float' for a configurable float.
                     * @enum {string}
                     */
                    data_type?: "float";
                    /**
                     * Format: float
                     * @description Minimum value that can be set for this parameter.
                     */
                    min_value?: number;
                    /**
                     * Format: float
                     * @description Minimum value that can be set for this parameter.
                     */
                    max_value?: number;
                    /** @description Not implemented at this moment */
                    ui_rules?: Record<string, never>;
                    /** @description Not implemented at this moment. */
                    editable?: boolean;
                  } | {
                    /** @description User friendly title for the integer. */
                    header?: string;
                    /** @description User friendly description for what the integer does. */
                    description?: string;
                    /** @description Warning message (if any) that explains the user to use caution when changing this parameter, and why. */
                    warning?: unknown;
                    /** @description Value that this configurable integer currently takes. */
                    value?: number;
                    /** @description Default value that should be set for this integer. */
                    default_value?: number;
                    /** @description Name to identify the configurable integer by in the system. */
                    name?: string;
                    /**
                     * @description Describes the template type of the parameter. 'selectable' is used for parameters with a fixed set of possible values. 'input' is used for parameters that allow free input, possibly restricted to a certain range. Template_type is always 'input' for a configurable integer.
                     * @enum {string}
                     */
                    template_type?: "input";
                    /**
                     * @description Describes the type of parameter. Parameters can be integers, floats, boolean or string. Data_type is always 'integer' for a configurable integer.
                     * @enum {string}
                     */
                    data_type?: "integer";
                    /** @description Minimum value that can be set for this parameter. */
                    min_value?: number;
                    /** @description Minimum value that can be set for this parameter. */
                    max_value?: number;
                    /** @description Not implemented at this moment */
                    ui_rules?: Record<string, never>;
                    /** @description Not implemented at this moment. */
                    editable?: boolean;
                  } | {
                    /** @description User friendly title for the selectable string. */
                    header?: string;
                    /** @description User friendly description for what the selectable string parameter does. */
                    description?: string;
                    /** @description Warning message (if any) that explains the user to use caution when changing this parameter, and why. */
                    warning?: unknown;
                    /** @description Value that this selectable string currently takes. */
                    value?: string;
                    /** @description Default value that should be set for this selectable string. */
                    default_value?: string;
                    /** @description Name to identify the selectable string parameter by in the system. */
                    name?: string;
                    /**
                     * @description Describes the template type of the parameter. 'selectable' is used for parameters with a fixed set of possible values. 'input' is used for parameters that allow free input, possibly restricted to a certain range. Template_type is always 'selectable' for a selectable string parameter.
                     * @enum {string}
                     */
                    template_type?: "selectable";
                    /**
                     * @description Describes the type of parameter. Parameters can be integers, floats, boolean or string. Data_type is always 'string' for a selectable string parameter.
                     * @enum {string}
                     */
                    data_type?: "string";
                    /** @description List of values that this selectable string can take. */
                    options?: string[];
                    /** @description Not implemented at this moment */
                    ui_rules?: Record<string, never>;
                    /** @description Not implemented at this moment. */
                    editable?: boolean;
                  } | {
                    /** @description User friendly title for the selectable. */
                    header?: string;
                    /** @description User friendly description for what the selectable parameter does. */
                    description?: string;
                    /** @description Warning message (if any) that explains the user to use caution when changing this parameter, and why. */
                    warning?: unknown;
                    /** @description Value that this selectable currently takes. */
                    value?: string;
                    /** @description Default value that should be set for this selectable. */
                    default_value?: string;
                    /** @description Name to identify the selectable parameter by in the system. */
                    name?: string;
                    /**
                     * @description Describes the template type of the parameter. 'selectable' is used for parameters with a fixed set of possible values. 'input' is used for parameters that allow free input, possibly restricted to a certain range. Template_type is always 'selectable' for a selectable parameter.
                     * @enum {string}
                     */
                    template_type?: "selectable";
                    /**
                     * @description Describes the type of parameter. Parameters can be integers, floats, boolean or string. Data_type is always 'float' for a selectable float.
                     * @enum {string}
                     */
                    data_type?: "float";
                    /** @description List of values that this float selectable can take. */
                    options?: number[];
                    /** @description Not implemented at this moment */
                    ui_rules?: Record<string, never>;
                    /** @description Not implemented at this moment. */
                    editable?: boolean;
                  })[];
              }))[];
            /**
             * @description Mongo ID of the object
             * @example 60d31793d5f1fb7e6e3c1a4c
             */
            task_id?: string;
            /** @description Title of the task the configuration is connected to */
            task_title?: string;
          };
        };
      };
      /** @description Object not found. See the examples for details. */
      404: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 400 | 404 | 405 | 409 | 412 | 413 | 415 | 422 | 423 | 500 | 501 | 503;
            /** @description Message from server */
            message: string;
            /** @description Error code from server */
            error_code: string;
          };
        };
      };
    };
  };
  /**
   * Set the configuration for a specific task.
   * @description This endpoint sets the configuration for a specific task. The configuration is subdivided into components, and every component is divided into parameter groups.
   */
  SetTaskConfiguration: {
    parameters: {
      path: {
        /** @description The ID of the organization. */
        organization_id: string;
        /** @description The ID of the workspace. */
        workspace_id: string;
        /** @description The ID of the project. */
        project_id: string;
        /** @description The ID of the task of interest. */
        task_id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": {
          /** @description Array of configurable parameter objects for the different components in the task, as well as the hyper parameters for the current algorithm in the task */
          components: ({
              entity_identifier: OneOf<[{
                workspace_id?: string;
                /**
                 * @description Mongo ID of the object
                 * @example 60d31793d5f1fb7e6e3c1a4c
                 */
                project_id?: string;
                /**
                 * @description Mongo ID of the task
                 * @example 60d31793d5f1fb7e6e3c1a4c
                 */
                task_id?: string;
                /**
                 * @description If the configuration is a component configuration, describes the component.
                 * @enum {string}
                 */
                component: "NULL_COMPONENT" | "SUBSET_MANAGER" | "DATASET_COUNTER" | "PROJECT_ACTIVE_LEARNING" | "TASK_ACTIVE_LEARNING" | "TASK_NODE" | "PIPELINE_DATASET_MANAGER";
                /**
                 * @description Describes the type of the configuration. Set to COMPONENT_PARAMETERS for a configuration that relates to a component.
                 * @enum {string}
                 */
                type: "COMPONENT_PARAMETERS";
              }, {
                workspace_id?: string;
                /**
                 * @description Mongo ID of the object
                 * @example 60d31793d5f1fb7e6e3c1a4c
                 */
                model_storage_id: string;
                /**
                 * @description Describes the type of the configurable parameters. For hyper parameters, type is set to HYPER_PARAMETERS.
                 * @enum {string}
                 */
                type: "HYPER_PARAMETERS";
              }, {
                workspace_id?: string;
                /**
                 * @description Mongo ID of the object
                 * @example 60d31793d5f1fb7e6e3c1a4c
                 */
                model_storage_id: string;
                /** @description The name of the hyper parameter group */
                group_name: string;
                /**
                 * @description Describes the type of the component. For hyper parameter groups, type is always set to HYPER_PARAMETER_GROUP
                 * @enum {string}
                 */
                type: "HYPER_PARAMETER_GROUP";
              }]>;
              groups?: ({
                  /** @description Name of the parameter group */
                  name: string;
                  /** @description Array of parameters */
                  parameters: ({
                      /** @description Value to set the parameter to. */
                      value: string | number | boolean;
                      /** @description Name to identify the parameter by in the system. */
                      name: string;
                    })[];
                })[];
              parameters?: ({
                  /** @description Value to set the parameter to. */
                  value: string | number | boolean;
                  /** @description Name to identify the parameter by in the system. */
                  name: string;
                })[];
            })[];
        };
      };
    };
    responses: {
      /** @description Configuration updated successfully */
      200: {
        content: {
          "application/json": unknown;
        };
      };
      /** @description Object not found. See the examples for details. */
      404: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 400 | 404 | 405 | 409 | 412 | 413 | 415 | 422 | 423 | 500 | 501 | 503;
            /** @description Message from server */
            message: string;
            /** @description Error code from server */
            error_code: string;
          };
        };
      };
      /** @description Configuration cannot be saved to the server */
      500: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 400 | 404 | 405 | 409 | 412 | 413 | 415 | 422 | 423 | 500 | 501 | 503;
            /** @description Message from server */
            message: string;
            /** @description Error code from server */
            error_code: string;
          };
        };
      };
    };
  };
  /**
   * Get the users' settings for a project or for the entire system
   * @description Get the users' settings for a project or the entire system. If project_id query parameter is not specified, the settings for the entire system are returned.
   */
  GetSettings: {
    parameters: {
      query?: {
        /** @description Select only items related to the given project. */
        project_id?: string;
      };
    };
    responses: {
      /** @description The settings for the user. */
      200: {
        content: {
          "application/json": {
            settings?: string;
          };
        };
      };
      /** @description No settings found for user. */
      204: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 200 | 201 | 202 | 203 | 204 | 205 | 206;
            /** @description Message from server */
            message: string;
          };
        };
      };
    };
  };
  /**
   * Set the users' settings for a project or for the entire system.
   * @description Set the users' settings for a project or for the entire system. If project_id query parameter is not specified, the settings for the entire system are set.
   */
  SetSettings: {
    parameters: {
      query?: {
        /** @description Select only items related to the given project. */
        project_id?: string;
      };
    };
    requestBody: {
      content: {
        "application/json": {
          settings: string;
        };
      };
    };
    responses: {
      /** @description Settings were successfully set. */
      200: {
        content: {
          "application/json": unknown;
        };
      };
      /** @description Posted settings exceed the maximum settings length. */
      400: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 400 | 404 | 405 | 409 | 412 | 413 | 415 | 422 | 423 | 500 | 501 | 503;
            /** @description Message from server */
            message: string;
            /** @description Error code from server */
            error_code: string;
          };
        };
      };
    };
  };
  /**
   * Get all annotation templates of a project
   * @description Get a complete list of annotation templates which belong to the project.
   */
  GetAnnotationTemplates: {
    parameters: {
      path: {
        /** @description The ID of the organization. */
        organization_id: string;
        /** @description The ID of the workspace. */
        workspace_id: string;
        /** @description The ID of the project. */
        project_id: string;
      };
    };
    responses: {
      /** @description The requested list of annotation templates */
      200: {
        content: {
          "application/json": {
            /**
             * @description Mongo ID of the object
             * @example 60d31793d5f1fb7e6e3c1a4c
             */
            id?: string;
            /** @description Name of the annotation template */
            name?: string;
            /** @description The value of the annotation template */
            value?: string;
          };
        };
      };
      /** @description No annotation template in the project. */
      204: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 200 | 201 | 202 | 203 | 204 | 205 | 206;
            /** @description Message from server */
            message: string;
          };
        };
      };
      /** @description Object not found. See the examples for details. */
      404: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 400 | 404 | 405 | 409 | 412 | 413 | 415 | 422 | 423 | 500 | 501 | 503;
            /** @description Message from server */
            message: string;
            /** @description Error code from server */
            error_code: string;
          };
        };
      };
    };
  };
  /**
   * Create an Annotation Template
   * @description Create an annotation template.
   */
  CreateAnnotationTemplate: {
    parameters: {
      path: {
        /** @description The ID of the organization. */
        organization_id: string;
        /** @description The ID of the workspace. */
        workspace_id: string;
        /** @description The ID of the project. */
        project_id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": {
          /** @description Name of the annotation template */
          name: string;
          /** @description The value of the annotation template */
          value: string;
        };
      };
    };
    responses: {
      /** @description Annotation template successfully created */
      201: {
        content: {
          "application/json": {
            /**
             * @description Mongo ID of the object
             * @example 60d31793d5f1fb7e6e3c1a4c
             */
            id?: string;
            /** @description Name of the annotation template */
            name?: string;
            /** @description The value of the annotation template */
            value?: string;
          };
        };
      };
      /** @description Bad request. The provided information is invalid to create an annotation template. */
      400: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 400 | 404 | 405 | 409 | 412 | 413 | 415 | 422 | 423 | 500 | 501 | 503;
            /** @description Message from server */
            message: string;
            /** @description Error code from server */
            error_code: string;
          };
        };
      };
      /** @description Object not found. See the examples for details. */
      404: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 400 | 404 | 405 | 409 | 412 | 413 | 415 | 422 | 423 | 500 | 501 | 503;
            /** @description Message from server */
            message: string;
            /** @description Error code from server */
            error_code: string;
          };
        };
      };
    };
  };
  /**
   * Get information about the product
   * @description Get information regarding product version.
   */
  GetProductInfo: {
    responses: {
      /** @description Product Information */
      200: {
        content: {
          "application/json": {
            /** @description Version number of installed product. */
            "product-version"?: string;
          };
        };
      };
    };
  };
  /**
   * Upload a dataset archive
   * @description Upload a dataset archive to the server.
   *
   * This endpoint allows clients to upload a dataset archive directly to the server without using the TUS protocol.
   */
  DatasetImportUploadFile: {
    parameters: {
      path: {
        /** @description The ID of the organization. */
        organization_id: string;
        /** @description The ID of the workspace. */
        workspace_id: string;
      };
    };
    requestBody: {
      content: {
        "multipart/form-data": {
          /**
           * File
           * Format: binary
           * @description The dataset file to be uploaded.
           */
          file?: string;
        };
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": unknown;
        };
      };
      /** @description Bad Request */
      400: {
        content: {
          "application/json": unknown;
        };
      };
      /** @description Request Entity Too Large */
      413: {
        content: {
          "application/json": unknown;
        };
      };
    };
  };
  /**
   * Start uploading a dataset archive using TUS
   * @description Initiate a new TUS session to upload a dataset archive.
   *
   * This endpoint creates a new upload resource on the server according to the TUS protocol (https://tus.io/protocols/resumable-upload.html).
   * The client provides metadata such as file size and name in the request headers, and the server responds with a location URL for the newly created resource.
   * This URL is used for subsequent upload operations (e.g., PATCH, HEAD).
   */
  CreateTusDatasetUpload: {
    parameters: {
      header?: {
        /** @description version of TUS used by the client */
        "tus-resumable"?: string;
        /** @description size in bytes of the file to be created */
        "upload-length"?: number;
      };
      path: {
        /** @description The ID of the organization. */
        organization_id: string;
        /** @description The ID of the workspace. */
        workspace_id: string;
      };
    };
    responses: {
      /** @description Successfully created TUS upload */
      201: {
        headers: {
          /** @description URL for data upload */
          location?: string;
        };
        content: never;
      };
      /** @description Bad Request */
      400: {
        content: {
          "application/json": unknown;
        };
      };
      /** @description Object not found */
      404: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 400 | 404 | 405 | 409 | 412 | 413 | 415 | 422 | 423 | 500 | 501 | 503;
            /** @description Message from server */
            message: string;
            /** @description Error code from server */
            error_code: string;
          };
        };
      };
      /** @description Unsupported TUS version */
      412: {
        headers: {
          /** @description list of supported TUS versions */
          "tus-version"?: string;
        };
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 400 | 404 | 405 | 409 | 412 | 413 | 415 | 422 | 423 | 500 | 501 | 503;
            /** @description Message from server */
            message: string;
            /** @description Error code from server */
            error_code: string;
          };
        };
      };
      /** @description Request Entity Too Large */
      413: {
        content: {
          "application/json": unknown;
        };
      };
    };
  };
  /**
   * Retrieve server capabilities for TUS uploads
   * @description Get information about the TUS protocol versions and extensions supported by the server.
   * This endpoint allows clients to dynamically adapt their behavior based on server capabilities.
   */
  TusDatasetUploadOptions: {
    parameters: {
      path: {
        /** @description The ID of the organization. */
        organization_id: string;
        /** @description The ID of the workspace. */
        workspace_id: string;
      };
    };
    responses: {
      /** @description Success */
      204: {
        headers: {
          /** @description version of TUS used by the server */
          "tus-resumable"?: string;
          /** @description list of supported TUS versions */
          "tus-version"?: string;
          /** @description list of supported TUS extensions */
          "tus-extension"?: string;
        };
        content: never;
      };
      /** @description Object not found */
      404: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 400 | 404 | 405 | 409 | 412 | 413 | 415 | 422 | 423 | 500 | 501 | 503;
            /** @description Message from server */
            message: string;
            /** @description Error code from server */
            error_code: string;
          };
        };
      };
    };
  };
  /**
   * Cancel a TUS upload of a dataset archive
   * @description Cancel the TUS upload of a dataset archive, removing the uploaded data from the server.
   *
   * This endpoint allows the client to cancel the upload operation and remove the uploaded data from the server.
   * It is useful for cleaning up incomplete uploads.
   */
  TusDatasetUploadDelete: {
    parameters: {
      header?: {
        /** @description version of TUS used by the client */
        "tus-resumable"?: string;
      };
      path: {
        /** @description The ID of the organization. */
        organization_id: string;
        /** @description The ID of the workspace. */
        workspace_id: string;
        /**
         * @description The ID of the file uploaded using the TUS protocol.
         * This can be found in the `Location` response header of [TUS upload initialization](#Project%20Import%2FExport/CreateTUSUpload).
         */
        file_id: string;
      };
    };
    responses: {
      /** @description Success */
      204: {
        content: never;
      };
      /** @description Bad Request */
      400: {
        content: {
          "application/json": unknown;
        };
      };
      /** @description File not found */
      404: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 400 | 404 | 405 | 409 | 412 | 413 | 415 | 422 | 423 | 500 | 501 | 503;
            /** @description Message from server */
            message: string;
            /** @description Error code from server */
            error_code: string;
          };
        };
      };
    };
  };
  /**
   * Get the status of a dataset archive TUS upload
   * @description Retrieve the current status of the TUS upload of a dataset archive.
   *
   * This endpoint provides information such as the current offset of uploaded data through the `Upload-Offset` header,
   * allowing the client to resume uploads from the correct position.
   * It is useful for verifying progress or ensuring consistency before appending further data.
   */
  TusDatasetUploadHead: {
    parameters: {
      header?: {
        /** @description version of TUS used by the client */
        "tus-resumable"?: string;
      };
      path: {
        /** @description The ID of the organization. */
        organization_id: string;
        /** @description The ID of the workspace. */
        workspace_id: string;
        /**
         * @description The ID of the file uploaded using the TUS protocol.
         * This can be found in the `Location` response header of [TUS upload initialization](#Project%20Import%2FExport/CreateTUSUpload).
         */
        file_id: string;
      };
    };
    responses: {
      /** @description Success */
      200: {
        headers: {
          /** @description total size in bytes of the file */
          "upload-length"?: number;
          /** @description size in bytes of data uploaded so far */
          "upload-offset"?: number;
        };
        content: never;
      };
      /** @description Bad Request. File ID is in wrong format. */
      400: {
        content: {
          "application/json": unknown;
        };
      };
      /** @description File not found */
      404: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 400 | 404 | 405 | 409 | 412 | 413 | 415 | 422 | 423 | 500 | 501 | 503;
            /** @description Message from server */
            message: string;
            /** @description Error code from server */
            error_code: string;
          };
        };
      };
      /** @description Unsupported TUS version */
      412: {
        headers: {
          /** @description list of supported TUS versions */
          "tus-version"?: string;
        };
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 400 | 404 | 405 | 409 | 412 | 413 | 415 | 422 | 423 | 500 | 501 | 503;
            /** @description Message from server */
            message: string;
            /** @description Error code from server */
            error_code: string;
          };
        };
      };
    };
  };
  /**
   * Append data to a running TUS upload of a dataset archive
   * @description Upload a chunk of the dataset archive data to the server, appending it to the TUS upload at the specified offset.
   *
   * This endpoint allows the client to resume uploading data with TUS by sending the remaining data from the last known offset.
   * It is recommended to choose a large chunk size (based on server limitations) to speed up the overall upload operation.
   */
  TusDatasetUploadPatch: {
    parameters: {
      header?: {
        /** @description version of TUS used by the client */
        "tus-resumable"?: string;
        "content-type"?: string;
        /** @description size in bytes of data uploaded so far */
        "upload-offset"?: number;
      };
      path: {
        /** @description The ID of the organization. */
        organization_id: string;
        /** @description The ID of the workspace. */
        workspace_id: string;
        /**
         * @description The ID of the file uploaded using the TUS protocol.
         * This can be found in the `Location` response header of [TUS upload initialization](#Project%20Import%2FExport/CreateTUSUpload).
         */
        file_id: string;
      };
    };
    requestBody?: {
      content: {
        "application/offset+octet-stream": string;
      };
    };
    responses: {
      /** @description Success */
      204: {
        headers: {
          /** @description size in bytes of data uploaded so far */
          "upload-offset"?: number;
        };
        content: never;
      };
      /** @description Bad Request */
      400: {
        content: {
          "application/json": unknown;
        };
      };
      /** @description File not found response */
      404: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 400 | 404 | 405 | 409 | 412 | 413 | 415 | 422 | 423 | 500 | 501 | 503;
            /** @description Message from server */
            message: string;
            /** @description Error code from server */
            error_code: string;
          };
        };
      };
      /** @description Unsupported TUS version */
      412: {
        headers: {
          /** @description list of supported TUS versions */
          "tus-version"?: string;
        };
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 400 | 404 | 405 | 409 | 412 | 413 | 415 | 422 | 423 | 500 | 501 | 503;
            /** @description Message from server */
            message: string;
            /** @description Error code from server */
            error_code: string;
          };
        };
      };
      /** @description Unsupported Media Type */
      415: {
        content: never;
      };
    };
  };
  /**
   * Prepare a dataset to be imported as a new project
   * @description Analyze an uploaded dataset archive file and prepare it to be imported as a new project.
   *
   * This endpoint submits a job to prepare the dataset for import. Specifically, the job scans the dataset
   * to determine the compatible task types and to identify potential issues in the data.
   * The status of this operation can be monitored in real-time through the [job status endpoint](#Jobs/GetJob);
   * once the job is finished, the list of compatible task types, labels and warnings can be found in the job metadata.
   */
  PrepareDatasetForImport: {
    parameters: {
      query: {
        /** @description The ID of the uploaded file */
        file_id: string;
      };
      path: {
        /** @description The ID of the organization. */
        organization_id: string;
        /** @description The ID of the workspace. */
        workspace_id: string;
      };
    };
    responses: {
      /** @description Success */
      200: {
        content: {
          "application/json": {
            /**
             * @description Mongo ID of the object
             * @example 60d31793d5f1fb7e6e3c1a4c
             */
            job_id?: string;
          };
        };
      };
      /** @description Bad request */
      400: {
        content: {
          "application/json": unknown;
        };
      };
      /** @description File not found */
      404: {
        content: {
          "application/json": unknown;
        };
      };
      /** @description Conflict */
      409: {
        content: {
          "application/json": unknown;
        };
      };
      /** @description Precondition failed */
      412: {
        content: {
          "application/json": unknown;
        };
      };
    };
  };
  /**
   * Create a new project from a prepared dataset
   * @description Finalize the creation of a new project from an imported dataset, that has been previously uploaded and prepared.
   *
   * This endpoint submits a job to create a new project with a given project name, task type and labels, that will also
   * contain all the media and annotations from the imported dataset.
   * The status of this operation can be monitored in real-time through the [job status endpoint](#Jobs/GetJob);
   * once the job is finished, the id of the created project can be found in the job metadata.
   */
  ImportProjectFromDataset: {
    parameters: {
      path: {
        /** @description The ID of the organization. */
        organization_id: string;
        /** @description The ID of the workspace. */
        workspace_id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": {
          /**
           * File Id
           * @example 60d31793d5f1fb7e6e3c1a4c
           */
          file_id: string;
          /**
           * Project Name
           * @example Pet Classification
           */
          project_name: string;
          /**
           * Task Type
           * @enum {string}
           */
          task_type: "classification" | "classification_hierarchical" | "detection" | "segmentation" | "instance_segmentation" | "anomaly" | "detection_oriented" | "detection_classification" | "detection_segmentation" | "keypoint_detection";
          /**
           * @example [
           *   {
           *     "name": "cat",
           *     "color": "#0014ffff"
           *   },
           *   {
           *     "name": "dog",
           *     "color": "#0015ffff"
           *   }
           * ]
           */
          labels: {
              name?: string;
              color?: string;
            }[];
        };
      };
    };
    responses: {
      /** @description Success */
      200: {
        content: {
          "application/json": {
            /**
             * @description Mongo ID of the object
             * @example 60d31793d5f1fb7e6e3c1a4c
             */
            job_id?: string;
          };
        };
      };
      /** @description Bad request */
      400: {
        content: {
          "application/json": unknown;
        };
      };
      /** @description File not found */
      404: {
        content: {
          "application/json": unknown;
        };
      };
      /** @description Conflict */
      409: {
        content: {
          "application/json": unknown;
        };
      };
      /** @description Precondition failed */
      412: {
        content: {
          "application/json": unknown;
        };
      };
    };
  };
  /**
   * Prepare a dataset to be imported into an already existing project
   * @description Analyze an uploaded dataset archive file and prepare it to be imported into an existing project.
   *
   * This endpoint submits a job to prepare the dataset for import. Specifically, the job scans the dataset
   * to assess the compatibility with the target project and to identify potential issues in the data.
   * The status of this operation can be monitored in real-time through the [job status endpoint](#Jobs/GetJob);
   * once the job is finished, the list of parsed labels and warnings can be found in the job metadata.
   */
  PrepareDatasetForImportToProject: {
    parameters: {
      query: {
        /** @description The ID of the uploaded file */
        file_id: string;
      };
      path: {
        /** @description The ID of the organization. */
        organization_id: string;
        /** @description The ID of the workspace. */
        workspace_id: string;
        /** @description The ID of the project. */
        project_id: string;
      };
    };
    responses: {
      /** @description Success */
      200: {
        content: {
          "application/json": {
            /**
             * @description Mongo ID of the object
             * @example 60d31793d5f1fb7e6e3c1a4c
             */
            job_id?: string;
          };
        };
      };
      /** @description Bad request */
      400: {
        content: {
          "application/json": unknown;
        };
      };
      /** @description File not found */
      404: {
        content: {
          "application/json": unknown;
        };
      };
      /** @description Precondition failed */
      412: {
        content: {
          "application/json": unknown;
        };
      };
    };
  };
  /**
   * Import a prepared dataset into an existing project
   * @description Finalize the import of an already prepared dataset into an existing project.
   *
   * This endpoint submits a job to import the dataset, including all its media and annotations from the imported dataset.
   * The status of this operation can be monitored in real-time through the [job status endpoint](#Jobs/GetJob);
   * once the job is finished, the id of the created project can be found in the job metadata.
   *
   * Within the project, the data may be imported into an existing dataset or a new dataset, depending on the request body:
   * - If one specifies a `dataset_id`, then the target will be that dataset
   * - If one specifies a `dataset_name`, then a new dataset will be created with that name
   *
   * The `labels_map` allows the user to map the labels found in the prepared dataset to the labels of the target project.
   */
  ImportDatasetToProject: {
    parameters: {
      path: {
        /** @description The ID of the organization. */
        organization_id: string;
        /** @description The ID of the workspace. */
        workspace_id: string;
        /** @description The ID of the project. */
        project_id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": OneOf<[{
          /**
           * File Id
           * @example 60d31793d5f1fb7e6e3c1a4c
           */
          file_id: string;
          /**
           * Dataset Id
           * @example 60d31793d5f1fb7e6e3c1a4d
           */
          dataset_id: string;
          /**
           * Dataset name
           * @example
           * @enum {string}
           */
          dataset_name: "";
          /**
           * Map of dataset label names to project label ids
           * @example {
           *   "person": "627d0c97bc34fab51b383f23",
           *   "bicycle": "627d0c97bc34fab51b383f23",
           *   "car": "627d0c97bc34fab51b383f22"
           * }
           */
          labels_map: Record<string, never>;
        }, {
          /**
           * File Id
           * @example 60d31793d5f1fb7e6e3c1a4c
           */
          file_id: string;
          /**
           * Dataset Id
           * @example
           * @enum {string}
           */
          dataset_id: "";
          /**
           * Dataset name
           * @example New dataset name
           */
          dataset_name: string;
          /**
           * Map of dataset label names to project label ids
           * @example {
           *   "person": "627d0c97bc34fab51b383f23",
           *   "bicycle": "627d0c97bc34fab51b383f23",
           *   "car": "627d0c97bc34fab51b383f22"
           * }
           */
          labels_map: Record<string, never>;
        }]>;
      };
    };
    responses: {
      /** @description Success */
      200: {
        content: {
          "application/json": {
            /**
             * @description Mongo ID of the object
             * @example 60d31793d5f1fb7e6e3c1a4c
             */
            job_id?: string;
          };
        };
      };
      /** @description Bad request */
      400: {
        content: {
          "application/json": unknown;
        };
      };
      /** @description File not found */
      404: {
        content: {
          "application/json": unknown;
        };
      };
      /** @description Precondition failed */
      412: {
        content: {
          "application/json": unknown;
        };
      };
    };
  };
  /**
   * Export a dataset as an archive
   * @description Export a dataset as a zip archive file, including all the media and the respective annotations.
   *
   * This endpoint submits a job to export the dataset.
   * The status of the export operation can be monitored in real-time through the [job status endpoint](#Jobs/GetJob);
   * after it completes, the URL to download the exported zip archive can be found in the job metadata.
   *
   * The downloaded dataset archive can be later imported as a new project, or merged into an existing dataset of compatible type.
   */
  TriggerDatasetExport: {
    parameters: {
      query: {
        /** @description The format to which to export the dataset */
        export_format: "coco" | "yolo" | "voc" | "datumaro";
        /** @description Boolean that indicates if unannotated media should be included in the export dataset. */
        include_unannotated_media?: boolean;
        /** @description If true, videos will be exported as a set of images, one for each annotated frame. If the specified dataset format cannot natively represent videos (e.g., VOC, COCO, ...), this parameter is overridden to true by the server. Conversely, if the format is Datumaro and this option is false, videos will be exported fully. */
        save_video_as_images?: boolean;
      };
      path: {
        /** @description The ID of the organization. */
        organization_id: string;
        /** @description The ID of the workspace. */
        workspace_id: string;
        /** @description The ID of the project. */
        project_id: string;
        /** @description The ID of the dataset in the project. */
        dataset_id: string;
      };
    };
    responses: {
      /** @description Success */
      200: {
        content: {
          "application/json": {
            /**
             * @description Mongo ID of the object
             * @example 60d31793d5f1fb7e6e3c1a4c
             */
            job_id?: string;
          };
        };
      };
      /** @description Bad Request */
      400: {
        content: {
          "application/json": unknown;
        };
      };
      /** @description File not Found */
      404: {
        content: {
          "application/json": unknown;
        };
      };
    };
  };
  /**
   * Download an exported dataset archive
   * @description Download a dataset exported as a zip file.
   */
  DownloadExportedDataset: {
    parameters: {
      path: {
        /** @description The ID of the organization. */
        organization_id: string;
        /** @description The ID of the workspace. */
        workspace_id: string;
        /** @description The ID of the project. */
        project_id: string;
        /** @description The ID of the dataset in the project. */
        dataset_id: string;
        /** @description The ID of the export dataset of interest */
        export_dataset_id: string;
      };
    };
    responses: {
      /** @description Redirect to the pre-signed URL for downloading the exported dataset archive */
      307: {
        headers: {
          /** @description The MIME type of the returned content */
          "Content-Type"?: string;
          /** @description Indicates that the server supports range requests */
          "Accept-Ranges"?: string;
          /** @description The URL to which the client is redirected */
          Location?: string;
        };
        content: never;
      };
      /** @description Bad Request. */
      400: {
        content: {
          "application/json": unknown;
        };
      };
      /** @description File not Found */
      404: {
        content: {
          "application/json": unknown;
        };
      };
    };
  };
  /**
   * Start uploading a project archive using TUS
   * @description Initiate a new TUS session to upload a project archive.
   *
   * This endpoint creates a new upload resource on the server according to the TUS protocol (https://tus.io/protocols/resumable-upload.html).
   * The client provides metadata such as file size and name in the request headers, and the server responds with a location URL for the newly created resource.
   * This URL is used for subsequent upload operations (e.g., PATCH, HEAD).
   */
  CreateTusProjectUpload: {
    parameters: {
      header?: {
        /** @description version of TUS used by the client */
        "tus-resumable"?: string;
        /** @description size in bytes of the file to upload */
        "upload-length"?: number;
      };
      path: {
        /** @description The ID of the organization. */
        organization_id: string;
        /** @description The ID of the workspace. */
        workspace_id: string;
      };
    };
    responses: {
      /** @description Successfully created TUS upload */
      201: {
        headers: {
          /** @description URL for data upload */
          location?: string;
        };
        content: never;
      };
      /** @description Object not found */
      404: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 400 | 404 | 405 | 409 | 412 | 413 | 415 | 422 | 423 | 500 | 501 | 503;
            /** @description Message from server */
            message: string;
            /** @description Error code from server */
            error_code: string;
          };
        };
      };
      /** @description Unsupported TUS version */
      412: {
        headers: {
          /** @description list of supported TUS versions */
          "tus-version"?: string;
        };
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 400 | 404 | 405 | 409 | 412 | 413 | 415 | 422 | 423 | 500 | 501 | 503;
            /** @description Message from server */
            message: string;
            /** @description Error code from server */
            error_code: string;
          };
        };
      };
      /** @description Request Entity Too Large */
      413: {
        content: {
          "application/json": unknown;
        };
      };
    };
  };
  /**
   * Retrieve server capabilities for TUS uploads
   * @description Get information about the TUS protocol versions and extensions supported by the server.
   * This endpoint allows clients to dynamically adapt their behavior based on server capabilities.
   */
  TusProjectUploadOptions: {
    parameters: {
      path: {
        /** @description The ID of the organization. */
        organization_id: string;
        /** @description The ID of the workspace. */
        workspace_id: string;
      };
    };
    responses: {
      /** @description Success */
      204: {
        headers: {
          /** @description version of TUS used by the server */
          "tus-resumable"?: string;
          /** @description list of supported TUS versions */
          "tus-version"?: string;
          /** @description list of supported TUS extensions */
          "tus-extension"?: string;
        };
        content: never;
      };
      /** @description Object not found */
      404: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 400 | 404 | 405 | 409 | 412 | 413 | 415 | 422 | 423 | 500 | 501 | 503;
            /** @description Message from server */
            message: string;
            /** @description Error code from server */
            error_code: string;
          };
        };
      };
    };
  };
  /**
   * Get the status of a project archive TUS upload
   * @description Retrieve the current status of the TUS upload of a project archive.
   *
   * This endpoint provides information such as the current offset of uploaded data through the `Upload-Offset` header,
   * allowing the client to resume uploads from the correct position.
   * It is useful for verifying progress or ensuring consistency before appending further data.
   */
  TusProjectUploadHead: {
    parameters: {
      header?: {
        /** @description version of TUS used by the client */
        "tus-resumable"?: string;
      };
      path: {
        /** @description The ID of the organization. */
        organization_id: string;
        /** @description The ID of the workspace. */
        workspace_id: string;
        /**
         * @description The ID of the file uploaded using the TUS protocol.
         * This can be found in the `Location` response header of [TUS upload initialization](#Project%20Import%2FExport/CreateTUSUpload).
         */
        file_id: string;
      };
    };
    responses: {
      /** @description Success */
      200: {
        headers: {
          /** @description total size in bytes of the file */
          "upload-length"?: number;
          /** @description size in bytes of data uploaded so far */
          "upload-offset"?: number;
        };
        content: never;
      };
      /** @description Object not found */
      404: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 400 | 404 | 405 | 409 | 412 | 413 | 415 | 422 | 423 | 500 | 501 | 503;
            /** @description Message from server */
            message: string;
            /** @description Error code from server */
            error_code: string;
          };
        };
      };
      /** @description Unsupported TUS version */
      412: {
        headers: {
          /** @description list of supported TUS versions */
          "tus-version"?: string;
        };
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 400 | 404 | 405 | 409 | 412 | 413 | 415 | 422 | 423 | 500 | 501 | 503;
            /** @description Message from server */
            message: string;
            /** @description Error code from server */
            error_code: string;
          };
        };
      };
    };
  };
  /**
   * Append data to a running TUS upload of a project archive
   * @description Upload a chunk of the project archive data to the server, appending it to the TUS upload at the specified offset.
   *
   * This endpoint allows the client to resume uploading data with TUS by sending the remaining data from the last known offset.
   * It is recommended to choose a large chunk size (based on server limitations) to speed up the overall upload operation.
   */
  TusProjectUploadPatch: {
    parameters: {
      header?: {
        /** @description version of TUS used by the client */
        "tus-resumable"?: string;
        "content-type"?: string;
        /** @description size in bytes of data uploaded so far */
        "upload-offset"?: number;
      };
      path: {
        /** @description The ID of the organization. */
        organization_id: string;
        /** @description The ID of the workspace. */
        workspace_id: string;
        /**
         * @description The ID of the file uploaded using the TUS protocol.
         * This can be found in the `Location` response header of [TUS upload initialization](#Project%20Import%2FExport/CreateTUSUpload).
         */
        file_id: string;
      };
    };
    requestBody?: {
      content: {
        "application/offset+octet-stream": string;
      };
    };
    responses: {
      /** @description Success */
      204: {
        headers: {
          /** @description size in bytes of data uploaded so far */
          "upload-offset"?: number;
        };
        content: never;
      };
      /** @description Object not found */
      404: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 400 | 404 | 405 | 409 | 412 | 413 | 415 | 422 | 423 | 500 | 501 | 503;
            /** @description Message from server */
            message: string;
            /** @description Error code from server */
            error_code: string;
          };
        };
      };
      /** @description Unsupported TUS version */
      412: {
        headers: {
          /** @description list of supported TUS versions */
          "tus-version"?: string;
        };
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 400 | 404 | 405 | 409 | 412 | 413 | 415 | 422 | 423 | 500 | 501 | 503;
            /** @description Message from server */
            message: string;
            /** @description Error code from server */
            error_code: string;
          };
        };
      };
    };
  };
  /**
   * Export a project as an archive
   * @description Export a project as a zip archive file, containing all the project data (including datasets and models).
   *
   * This endpoint submits a job to export a project.
   * The status of the export operation can be monitored in real-time through the [job status endpoint](#Jobs/GetJob);
   * after it completes, the URL to download the exported zip archive can be found in the job metadata.
   *
   * The downloaded project archive can be later imported using the [import project endpoint](#Project%20Import%2FExport/ImportProject).
   */
  TriggerProjectExport: {
    parameters: {
      path: {
        /** @description The ID of the organization. */
        organization_id: string;
        /** @description The ID of the workspace. */
        workspace_id: string;
        /** @description The ID of the project. */
        project_id: string;
      };
    };
    responses: {
      /** @description Success */
      200: {
        content: {
          "application/json": unknown;
        };
      };
      /** @description Object not found */
      404: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 400 | 404 | 405 | 409 | 412 | 413 | 415 | 422 | 423 | 500 | 501 | 503;
            /** @description Message from server */
            message: string;
            /** @description Error code from server */
            error_code: string;
          };
        };
      };
    };
  };
  /**
   * Download an exported project archive
   * @description Download a project archive exported as a zip file.
   */
  DownloadExportedProject: {
    parameters: {
      path: {
        /** @description The ID of the organization. */
        organization_id: string;
        /** @description The ID of the workspace. */
        workspace_id: string;
        /** @description The ID of the project. */
        project_id: string;
        /** @description Identifier of the project export operation */
        export_operation_id: string;
      };
    };
    responses: {
      /** @description Redirect to the pre-signed URL for downloading the exported project archive */
      307: {
        headers: {
          /** @description The MIME type of the returned content */
          "Content-Type"?: string;
          /** @description Indicates that the server supports range requests */
          "Accept-Ranges"?: string;
          /** @description The URL to which the client is redirected */
          Location?: string;
        };
        content: never;
      };
      /** @description Object not found */
      404: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 400 | 404 | 405 | 409 | 412 | 413 | 415 | 422 | 423 | 500 | 501 | 503;
            /** @description Message from server */
            message: string;
            /** @description Error code from server */
            error_code: string;
          };
        };
      };
    };
  };
  /**
   * Import a project from an uploaded archive
   * @description Create a project by importing a project archive file.
   *
   * The project archive file must be first uploaded using the TUS protocol,
   * by means of the [TUS upload endpoints](#Project%20Import%2FExport/CreateTusProjectUpload).
   *
   * This endpoint submits a job to import a project from the uploaded archive.
   * The status of the import operation can be monitored in real-time through the [job status endpoint](#Jobs/GetJob);
   * after it completes, the id of the imported project can be found in the job metadata.
   */
  ImportProject: {
    parameters: {
      path: {
        /** @description The ID of the organization. */
        organization_id: string;
        /** @description The ID of the workspace. */
        workspace_id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": {
          /**
           * @description Mongo ID of the object
           * @example 60d31793d5f1fb7e6e3c1a4c
           */
          file_id: string;
          /** @description The name to assign to the imported project */
          project_name?: unknown;
        };
      };
    };
    responses: {
      /** @description Success */
      200: {
        content: {
          "application/json": {
            /**
             * @description Mongo ID of the object
             * @example 60d31793d5f1fb7e6e3c1a4c
             */
            job_id?: string;
          };
        };
      };
      /** @description Object not found */
      404: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 400 | 404 | 405 | 409 | 412 | 413 | 415 | 422 | 423 | 500 | 501 | 503;
            /** @description Message from server */
            message: string;
            /** @description Error code from server */
            error_code: string;
          };
        };
      };
      /** @description Too many projects */
      409: {
        content: {
          "application/json": unknown;
        };
      };
    };
  };
  /**
   * Prepare code deployment for project
   * @deprecated
   * @description This endpoint triggers preparation for code deployment for a specific project. For single-task projects (Detection, Segmentation, etc), it will export the only model used. For task-chain projects, it will export all the models. Only models in OpenVINO IR format are supported.
   * This endpoint is deprecated. Use the [deployment package endpoint](../deployment_package/download_deployment_package_endpoint.yaml) to prepare and download code deployment.
   */
  PrepareCodeDeployment: {
    parameters: {
      path: {
        /** @description The ID of the organization. */
        organization_id: string;
        /** @description The ID of the workspace. */
        workspace_id: string;
        /** @description The ID of the project. */
        project_id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": {
          /** @description Array of model identifiers */
          models: {
              /**
               * @description Mongo ID of the object
               * @example 60d31793d5f1fb7e6e3c1a4c
               */
              model_id: string;
              /**
               * @description Mongo ID of the object
               * @example 60d31793d5f1fb7e6e3c1a4c
               */
              model_group_id: string;
            }[];
        };
      };
    };
    responses: {
      /** @description Code deployment started successfully */
      200: {
        content: {
          "application/json": {
            /**
             * @description Mongo ID of the object
             * @example 60d31793d5f1fb7e6e3c1a4c
             */
            id?: string;
            /** @description progress of code deployment */
            progress?: number;
            /**
             * @description State of the deployment
             * @enum {string}
             */
            state?: "NONE" | "PREPARING" | "DONE" | "FAILED";
            /** @description Identifiers of the exported models */
            models?: {
                /**
                 * @description Mongo ID of the object
                 * @example 60d31793d5f1fb7e6e3c1a4c
                 */
                model_id: string;
                /**
                 * @description Mongo ID of the object
                 * @example 60d31793d5f1fb7e6e3c1a4c
                 */
                model_group_id: string;
              }[];
            /** @description Id of the user who started the deployment */
            creator_id?: string;
            /** @description Creation time of the model */
            creation_time?: string;
          };
        };
      };
      /** @description Bad Request */
      400: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 400 | 404 | 405 | 409 | 412 | 413 | 415 | 422 | 423 | 500 | 501 | 503;
            /** @description Message from server */
            message: string;
            /** @description Error code from server */
            error_code: string;
          };
        };
      };
      /** @description Object not found. See the examples for details. */
      404: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 400 | 404 | 405 | 409 | 412 | 413 | 415 | 422 | 423 | 500 | 501 | 503;
            /** @description Message from server */
            message: string;
            /** @description Error code from server */
            error_code: string;
          };
        };
      };
    };
  };
  /**
   * Get details of a code deployment process
   * @description Get details for the code deployment process, which includes the state, the progress, models, the creator id and creation time.
   */
  GetCodeDeployment: {
    parameters: {
      path: {
        /** @description The ID of the organization. */
        organization_id: string;
        /** @description The ID of the workspace. */
        workspace_id: string;
        /** @description The ID of the project. */
        project_id: string;
        /** @description The ID of the deployment */
        deployment_id: string;
      };
    };
    responses: {
      /** @description Retrieved details for deployment on code level */
      200: {
        content: {
          "application/json": {
            /**
             * @description Mongo ID of the object
             * @example 60d31793d5f1fb7e6e3c1a4c
             */
            id?: string;
            /** @description progress of code deployment */
            progress?: number;
            /**
             * @description State of the deployment
             * @enum {string}
             */
            state?: "NONE" | "PREPARING" | "DONE" | "FAILED";
            /** @description Identifiers of the exported models */
            models?: {
                /**
                 * @description Mongo ID of the object
                 * @example 60d31793d5f1fb7e6e3c1a4c
                 */
                model_id: string;
                /**
                 * @description Mongo ID of the object
                 * @example 60d31793d5f1fb7e6e3c1a4c
                 */
                model_group_id: string;
              }[];
            /** @description Id of the user who started the deployment */
            creator_id?: string;
            /** @description Creation time of the model */
            creation_time?: string;
          };
        };
      };
      /** @description Object not found. See the examples for details. */
      404: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 400 | 404 | 405 | 409 | 412 | 413 | 415 | 422 | 423 | 500 | 501 | 503;
            /** @description Message from server */
            message: string;
            /** @description Error code from server */
            error_code: string;
          };
        };
      };
    };
  };
  /**
   * Download the deployed code as a zip file
   * @deprecated
   * @description Download the deployed code as a zip file. This endpoint is deprecated. Use the [deployment package endpoint](../deployment_package/download_deployment_package_endpoint.yaml) to prepare and download code deployment.
   */
  DownloadCodeDeployment: {
    parameters: {
      path: {
        /** @description The ID of the organization. */
        organization_id: string;
        /** @description The ID of the workspace. */
        workspace_id: string;
        /** @description The ID of the project. */
        project_id: string;
        /** @description The ID of the deployment */
        deployment_id: string;
      };
    };
    responses: {
      /** @description Retrieved code deployment zipfile */
      200: {
        content: {
          "zip file": string;
        };
      };
      /** @description Object not found. See the examples for detail. */
      404: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 400 | 404 | 405 | 409 | 412 | 413 | 415 | 422 | 423 | 500 | 501 | 503;
            /** @description Message from server */
            message: string;
            /** @description Error code from server */
            error_code: string;
          };
        };
      };
      /** @description Deployment is not ready. See the examples for detail. */
      503: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 400 | 404 | 405 | 409 | 412 | 413 | 415 | 422 | 423 | 500 | 501 | 503;
            /** @description Message from server */
            message: string;
            /** @description Error code from server */
            error_code: string;
          };
        };
      };
    };
  };
  /**
   * Download the deployment package as a zip file
   * @description Download the deployment package as a zip file, e.g. an archive containing trained model files and graphs for deploying model on OpenVino Model Server or locally using the Geti SDK.
   */
  DownloadDeploymentPackage: {
    parameters: {
      path: {
        /** @description The ID of the organization. */
        organization_id: string;
        /** @description The ID of the workspace. */
        workspace_id: string;
        /** @description The ID of the project. */
        project_id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": {
          /** @description Array of model identifiers */
          models: {
              /**
               * @description Mongo ID of the object
               * @example 60d31793d5f1fb7e6e3c1a4c
               */
              model_id: string;
              /**
               * @description Mongo ID of the object
               * @example 60d31793d5f1fb7e6e3c1a4c
               */
              model_group_id: string;
            }[];
          /** @enum {unknown} */
          package_type: "ovms" | "geti_sdk";
        };
      };
    };
    responses: {
      /** @description Retrieved deployment package zipfile */
      200: {
        content: {
          "zip file": string;
        };
      };
      /** @description Object not found. See the examples for detail. */
      404: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 400 | 404 | 405 | 409 | 412 | 413 | 415 | 422 | 423 | 500 | 501 | 503;
            /** @description Message from server */
            message: string;
            /** @description Error code from server */
            error_code: string;
          };
        };
      };
      /** @description Invalid package type */
      422: {
        content: {
          "application/json": {
            /** @enum {integer} */
            http_status: 400 | 404 | 405 | 409 | 412 | 413 | 415 | 422 | 423 | 500 | 501 | 503;
            /** @description Message from server */
            message: string;
            /** @description Error code from server */
            error_code: string;
          };
        };
      };
    };
  };
  /**
   * [SaaS] Get running credits balance
   * @description <i>Not available on on-premises environments.</i><br><br> The running credit balance of an organization is calculated during the current subscription cycle, and consists of 3 values:<br>
   *   1) incoming - credits, allocated to the organization at the start of the subscription cycle;<br>
   *   2) blocked - credits, temporary reserved for the training or optimization jobs in progress;<br>
   *   3) available - credits, which are available for usage.
   */
  get_balance_api_v1_organizations__organization_id__balance_get: {
    parameters: {
      query?: {
        /** @description Optional parameter. If not provided, the current credits balance is returned. */
        date?: number | null;
      };
      path: {
        organization_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": {
            /** Incoming */
            incoming: number;
            /** Available */
            available: number;
            /** Blocked */
            blocked: number;
          };
        };
      };
      /** @description Organization doesn't have any active credit accounts */
      404: {
        content: never;
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": {
            /** Detail */
            detail?: unknown[];
          };
        };
      };
    };
  };
  /**
   * [SaaS] Get credit accounts
   * @description <i>Not available on on-premises environments.</i><br><br> Returns active (not expired) credit accounts of the organization.
   */
  get_credit_accounts_api_v1_organizations__organization_id__credit_accounts_get: {
    parameters: {
      query?: {
        skip?: number;
        limit?: number;
      };
      path: {
        organization_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": {
            /** Total Matched */
            total_matched: number;
            next_page?: {
              /** Limit */
              limit: number;
              /** Skip */
              skip: number;
            } | null;
            /** Credit Accounts */
            credit_accounts: ({
                /**
                 * Id
                 * Format: uuid
                 */
                id: string;
                /** Organization Id */
                organization_id: string;
                /** Name */
                name: string;
                /** Renewable Amount */
                renewable_amount?: number | null;
                /** Renewal Day Of Month */
                renewal_day_of_month?: number | null;
                /** Created */
                created: number;
                /** Updated */
                updated: number;
                /** Expires */
                expires?: number | null;
                /** BalanceResponse */
                balance: {
                  /** Incoming */
                  incoming: number;
                  /** Available */
                  available: number;
                  /** Blocked */
                  blocked: number;
                };
              })[];
          };
        };
      };
      /** @description Organization doesn't have any active credit accounts */
      404: {
        content: never;
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": {
            /** Detail */
            detail?: unknown[];
          };
        };
      };
    };
  };
  /**
   * [SaaS] Get the active subscription
   * @description <i>Not available on on-premises environments.</i><br><br> Information about the organization's active subscription.
   */
  get_active_subscription_api_v1_organizations__organization_id__subscriptions_active_get: {
    parameters: {
      path: {
        organization_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": {
            /**
             * Id
             * Format: uuid
             */
            id: string;
            /** Organization Id */
            organization_id: string;
            /** Workspace Id */
            workspace_id: string;
            /**
             * Product Id
             * Format: uuid
             */
            product_id: string;
            /** Status */
            status: string;
            /** Created */
            created: number;
            /** Updated */
            updated: number;
            /** Next Renewal Date */
            next_renewal_date?: number | null;
            /** Previous Renewal Date */
            previous_renewal_date?: number | null;
          };
        };
      };
      /** @description Organization doesn't have any active subscriptions */
      404: {
        content: never;
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": {
            /** Detail */
            detail?: unknown[];
          };
        };
      };
    };
  };
  /**
   * [SaaS] Get transactions information
   * @description <i>Not available on on-premises environments.</i><br><br> Returns information about finished transactions within specified time range [from_date, to_date].<br> Supports sorting and filtering by project name and usage type.
   */
  get_transactions_api_v1_organizations__organization_id__transactions_get: {
    parameters: {
      query?: {
        skip?: number;
        limit?: number;
        /** @description Milliseconds timestamp */
        from_date?: number | null;
        /** @description Milliseconds timestamp */
        to_date?: number | null;
        sort?: string[];
        project_id?: string | null;
        usage_type?: ("optimization" | "training") | null;
      };
      path: {
        organization_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": {
            /** Total Matched */
            total_matched: number;
            next_page?: {
              /** Limit */
              limit: number;
              /** Skip */
              skip: number;
            } | null;
            /** Transactions */
            transactions: ({
                /** Credits */
                credits: number;
                /** Project Id */
                project_id?: string | null;
                /** Service Name */
                service_name: string;
                /** Milliseconds Timestamp */
                milliseconds_timestamp: number;
              })[];
          };
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": {
            /** Detail */
            detail?: unknown[];
          };
        };
      };
    };
  };
  /**
   * [SaaS] Get credit consumption aggregates
   * @description <i>Not available on on-premises environments.</i><br><br> The aggregating endpoint allows to retrieve credit consumption grouped by various dimensions - such as project, date, usage type, etc.
   */
  get_credit_consumption_aggregates_api_v1_organizations__organization_id__transactions_aggregates_get: {
    parameters: {
      query?: {
        /** @description Milliseconds timestamp */
        from_date?: number | null;
        /** @description Milliseconds timestamp */
        to_date?: number | null;
        project_id?: string[] | null;
        key?: ("project" | "service_name" | "date")[];
      };
      path: {
        organization_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": {
            /** Aggregates */
            aggregates: ({
                /** Group */
                group: ({
                    /** Key */
                    key: string;
                    /** Value */
                    value: string | number;
                  })[];
                /** AggregatesResult */
                result: {
                  /** Credits */
                  credits: number;
                  /** ResourcesAmount */
                  resources: {
                    /**
                     * Images
                     * @default 0
                     */
                    images?: number;
                    /**
                     * Frames
                     * @default 0
                     */
                    frames?: number;
                  };
                };
              })[];
          };
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": {
            /** Detail */
            detail?: unknown[];
          };
        };
      };
    };
  };
}
